import React from 'react';

function BackgroundsAndFrames() {

  return (
    <section className="conspect">
      <h1>Backgrounds & Frames</h1>
      <h2>Backgrounds</h2>
      <h4>background-image, фоновая картинка</h4>
      <p>мелкие картинки, которые нельзя засунуть в спрайты, в data:image base64 в CSS — это экономит кучу запросов к вебсерверу. Аббревиатура URI расшифровывается как Uniform Resource Identifier.</p>
      <p><a href="https://habr.com/ru/post/116538/" target="_blank" rel="noopener noreferrer">Храните мелкие картинки в CSS</a></p>

      <h3>Свойство background-repeat</h3>
      <p>По умолчанию фоновое изображение повторяется. У свойства background-repeat 4 значения:</p>
      <ul>
        <li>repeat — повторять во всех направлениях. Это значение по умолчанию.</li>
        <li>repeat-x — повторять только по горизонтали.</li>
        <li>repeat-y — повторять только по вертикали.</li>
        <li>no-repeat — не повторять.</li>
        <li>round — повторяющиеся картинки по краям блока равномерно растянутся или сожмутся по всей ширине и высоте.</li>
        <li>space — фоновые картинки не сжимаются или растягиваются, а для компенсации ширины блока между ними добавляется пустое пространство.</li>
      </ul>
      <p>background-repeat принимает в качестве значения два аргумента: режим повторения по горизонтали и по вертикали. Если передать один параметр, то он применится к обоим направлениям.</p>
      <pre>{`/* повторение фона repeat по горизонтали и вертикали */
background-repeat: repeat;

/* повторение фона round по горизонтали и repeat по вертикали */
background-repeat: round repeat;`}
      </pre>

      <h3>Свойство background-position</h3>
      <p>Cвойство background-position управляет расположением фонового изображения. Значение свойства состоит из двух частей, разделенных пробелом: x y. x задаёт расположение по горизонтали, а y по вертикали.</p>
      <p>В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.</p>
      <p>В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях. Примеры использования свойства:</p>
      <pre>{`background-position: 50% 50%; // картинка будет по центру;
background-position: right bottom; // правый нижний угол;
background-position: 50px 100px; // отступ 50px от левого края и 100px от верхнего;
background-position: 0 100%; // левый нижний угол;
background-position: left bottom; // левый нижний угол.`}
      </pre>
      <p>Когда фоновое изображение больше блока, то оно обрезается. Управлять тем, какую часть изображения будет видно, также можно с помощью свойства background-position.</p>

      <h3>Свойство background-attachment</h3>
      <p>Обычно фоновое изображение прокручивается вместе с содержимым блока. Значение свойства:</p>
      <ul>
        <li>scroll — фон прокручивается вместе с содержимым. Это значение по умолчанию.</li>
        <li>fixed — фон не прокручивается, зафиксирован на одном месте.</li>
      </ul>

      <h3>Краткая запись background</h3>
      <pre>{`background: [<фон>, ]* <последний_фон>

<фон> = background-image
|| background-position [ / background-size ]?
|| background-repeat
|| background-attachment
|| background-origin
|| background-clip

<последний_фон> = background-image
|| background-position [ / background-size ]?
|| background-repeat
|| background-attachment
|| background-origin
|| background-clip
|| background-color`}
      </pre>
      <div className="note">Если наряду с фоновыми изображениями требуется задать цвет фона элемента, он указывается в последнюю очередь после перечисления. Ни одно значение не является обязательным, поэтому неиспользуемые можно опустить.</div>

      <h4>Несколько фонов</h4>
      <p>Суть техники заключается в том, что мы вкладываем элементы друг в друга и делаем их одинакового размера, а затем каждому элементу задаём свой фон. То есть каждый элемент служит одним слоем фона. Фоны вложенных элементов перекрывают друг друга: чем глубже элемент, тем выше его фон.</p>
      <div className="note">Кстати, для удобства ширину лучше задавать внешнему элементу (так как все вложенные будут той же ширины), а высоту самому глубокому, так как он растянет по высоте всех своих родителей.</div>

      <h4>Эффекты с повторяющимся фоном</h4>
      <ul>
        <li><a href="backgrounds/beos/index.html" target="_blank" rel="noopener noreferrer">горох;</a></li>
        <li><a href="backgrounds/battlement/index.html" target="_blank" rel="noopener noreferrer">зазубренные края;</a></li>
        <li><a href="http://css.yoksel.ru/css-patterns/" target="_blank" rel="noopener noreferrer">CSS-паттерны</a></li>
      </ul>

      <h3>Спрайты</h3>
      <p>Спрайт — это одно большое изображение, в котором содержится много маленьких, как бы карта изображений.</p>
      <p>Спрайты используются, чтобы снизить количество запросов на сервер. Каждая маленькая картинка — это отдельный запрос, а чем меньше запросов, тем лучше. Поэтому маленькие картинки «склеивают» в одну большую.</p>
      <p>Части спрайта отображают в элементах с небольшими размерами. Такому элементу задают картинку-спрайт в качестве фона и смещают её таким образом, чтобы была видна нужная её часть.</p>
      <h4>SVG-спрайты</h4>
      <ol>
        <li>Собираем один общий svg-файл со множеством symbol (элементы спрайта), имеющих свои id . У тега svg задаём style=&quot;display:none&quot;.</li>
        <li>В разметке используем ссылки на symbol при помощи use:
          <pre>{`<a class="social__link" href="#" aria-label="Мы в Instagram">
  <svg class="social__link-icon" width="23" height="22" role="img" aria-hidden="true">
    <use xlink:href="img/sprite.svg#icon-insta"></use>
  </svg>
</a>`}
          </pre>
        </li>
      </ol>
      <p>Недостатки метода:</p>
      <ul>
        <li>управление с уровня CSS не полное: сложно управлять отдельными частями символа (имеющими свои CSS-классы), если он вставлен несколько раз,</li>
        <li>работает только с сервера (локального/удалённого — не важно).
        </li>
      </ul>

      <h3>Размер фона</h3>
      <p>Свойство background-size. Оно принимает в качестве значения два аргумента: первый — это ширина фонового изображения, второй — его высота. Второй аргумент необязательный. Если высота не указывается, то она определяется автоматически в зависимости от ширины и исходных пропорций. По умолчанию оба аргумента равны auto.</p>
      <p>contain - пропорции изображения сохраняются, изображению задаются максимально возможные размеры, при которых оно и по ширине, и по высоте полностью помещается в границы фона, изображение может не закрывать всю фоновую область блока, если пропорции изображения и блока разные.</p>
      <p>cover - пропорции изображения сохраняются, изображению задаются минимально возможные размеры, при которых оно закроет всю фоновую область блока, если пропорции изображения и блока разные, то часть изображения обрезается.</p>

      <h3>Границы фона — background-origin</h3>
      <p>Оно задаёт расположение и размеры области отображения фонового изображения и принимает три значения: padding-box(default), border-box и content-box.</p>
      <p>padding-box - область отображения фонового изображения соответствует внутренней области блока, не включая рамки.</p>
      <p>content-box - область отображения соответствует только области содержимого, не включая рамки и внутренние отступы.</p>
      <p>border-box - область отображения соответствует полному размеру блока, включая и рамки. Фоновое изображение начинается от внешнего края блока и закрывается рамками, если они заданы.</p>

      <h3>Обрезка фона - background-clip</h3>
      <p>border-box(default) - фоновое изображение совсем не обрезается.</p>
      <p>padding-box обрежет фон по внутреннему краю области рамки.</p>
      <p>content-box обрежет фон по краю области содержимого.</p>

      <h3>Множественный фон</h3>
      <p>Пути к изображениям в свойстве background-image или background перечисляются через запятую. При этом выше будет то изображение, которое находится раньше в списке</p>
      <p>Значения других свойств для множественных фоновых изображений тоже задаются через запятую. Порядок значений должен соответствовать порядку фоновых картинок. Например:</p>
      <pre>{`/* для первой картинки масштабирование contain, для второй — 100px */
background-size: contain, 100px;

/* для первой картинки позиционирование top, для второй — 100% */
background-position: top, 100%;`}
      </pre>
      <h4>Как сделать маску на каринку:</h4>
      <pre>{'background: url("img/mask.png"), url("img/catalog-1.jpg") no-repeat;'}
      </pre>

      <h4>Позиция фона от разных сторон</h4>
      <p>расположение фона можно задавать относительно любого угла блока, а не только от левого верхнего.</p>
      <p>Чтобы указать от какой стороны отсчитывать расположение фона, нужно перед значением координат задать ключевые слова: top, right, bottom или left. Например:</p>
      <pre>{`/* по умолчанию координаты задаются для левого верхнего угла */
background-position: 10px 50px; /* слева 10px, сверху 50px */

background-position: right 30px bottom 60px; /* справа 30px, снизу 60px */
background-position: left 50px bottom 10px; /* слева 50px, снизу 10px */
background-position: right 40px top 30px; /* справа 40px, сверху 30px */`}
      </pre>

      <h2>Внешняя рамка - outline</h2>
      <p>внешней рамке нельзя задать параметры отдельных сторон.</p>
      <p>Внешняя рамка всегда отображается снаружи элемента, не влияет на его размер и не занимает места, то есть отображается над другими элементами.</p>
      <pre>{'outline: width style color'}</pre>
      <p>C помощью свойства outline-offset можно изменять расположение рамки. Положительное значение отодвигает рамку от внешнего края элемента, а отрицательное «втягивает» внутрь.</p>

      <h3>Рамки, border</h3>
      <p><code>border: 5px solid red; // ширина рамки, стиль рамки, цвет.</code></p>
      <p>border: border-width || border-style || border-color</p>
      <div className="border-container">
        <div className="border b-1">solid</div>
        <div className="border b-2">dotted</div>
        <div className="border b-3">dashed</div>
        <div className="border b-4">double</div>
        <div className="border b-5">groove</div>
        <div className="border b-6">ridge</div>
        <div className="border b-7">inset</div>
        <div className="border b-8">outset</div>
      </div>

      <h3>Скругление углов - border-radius</h3>
      <p>задаёт радиус скругления углов в пикселях или процентах. Если у блока есть рамка, то скругляется и она.</p>
      <div className="note">Вы можете закруглять отдельные углы с помощью свойств: border-top-left-radius, border-top-right-radius, border-bottom-right-radius и border-bottom-left-radius.</div>
      <p>А ещё можно задавать разные горизонтальные и вертикальные радиусы скругления. Для этого нужно написать два значения через пробел в свойстве скругления угла. Первое значение задаёт радиус по горизонтали, второе — по вертикали.</p>
      <pre>{`/* горизонтальный радиус 30px, вертикальный 15px */
border-top-right-radius: 30px 15px;`}
      </pre>
      <p>Разные горизонтальные и вертикальные радиусы можно задавать и в свойстве border-radius. Для этого нужно использовать /, например:</p>
      <pre>{`/* горизонтальный радиус всех углов 10px, вертикальный 5px */
border-radius: 10px / 5px;
/* разные горизонтальные и вертикальные радиусы у каждого угла */
border-radius: 10px 20px 30px 40px / 5px 15px 25px 35px;`}
      </pre>

      <h3>Изображение рамки - border-image</h3>
      <h4>border-image-source</h4>
      <p>Свойство border-image-source задаёт путь к изображению рамки. По умолчанию картинкой заполнятся только углы рамки.</p>
      <pre>{'border-image-source: url("image.jpg");'}</pre>
      <h4>border-image-slice</h4>
      <p>Каждая рамка имеет 9 областей: 4 угла, 4 стороны и центральную область. Для заполнения этих областей браузер должен нарезать картинку для рамки на 9 частей. Когда браузер не знает, как это сделать, он просто размещает картинку по углам.</p>
      <p>Свойство border-image-slice задаёт отступы от краёв картинки до четырёх линий, которые «разрезают» её на части, как на схеме справа. Если эти отступы небольшие, то получается «нарезка» из 9 частей, которые затем размещаются в соответствующих областях рамки.</p>
      <p>Но если отступы слишком большие (больше половины картинки), то браузер не может получить 9 частей и располагает то, что отрезалось по углам.</p>
      <p>Значение свойства можно задавать числом без единицы измерения (оно обычно обозначает пиксели) или в процентах (относительно размера самой картинки).</p>
      <p>С помощью border-image-slice можно задавать разные отступы линий разреза. Для этого нужно задавать значения через пробел в порядке: верх, право, низ, лево.</p>
      <p>Средняя часть картинки обычно не используется. Но если в значение свойства добавить ключевое слово fill, то средняя часть картинки будет отображаться в средней области рамки: она закроет собой фон блока, но не закроет содержимое.</p>
      <pre>{'border-image-slice: 10 20 30 40 fill;'}</pre>
      <h4>Изображение рамки: border-image-repeat</h4>
      <p>Свойство border-image-repeat задаёт способ заполнения фоном боковых сторон рамки. У свойства четыре значения: stretch, repeat, space и round.</p>
      <p>Значение по умолчанию — stretch. При этом значении фоновые картинки растягиваются на всю длину боковых сторон.</p>
      <pre>{`/* все стороны рамки заполняются в режиме stretch */
border-image-repeat: stretch;

/* горизонтальные стороны — режим repeat, вертикальные — stretch */
border-image-repeat: repeat stretch;`}
      </pre>
      <p>Значение round свойства border-image-repeat тоже устанавливает режим заполнения стороны рамки повторяющимися боковыми участками картинки. Но, в отличие от repeat, если в ширину стороны не вмещается целое число повторяющихся кусочков, крайние части не обрезаются. Кусочки при этом равномерно растягиваются так, чтобы все они стали одного размера и заняли оставшееся место стороны рамки.</p>
      <p>Согласно спецификации при заданном значении space алгоритм похож на round, только для компенсации оставшегося места кусочки картинки не растягиваются, а остаются прежней ширины, при этом между кусочками появляется дополнительное свободное пространство.</p>
      <h4>border-image-width</h4>
      <p>Свойство border-image-width позволяет управлять шириной видимой области рамки-картинки, масштабировать её. Саму ширину рамки это свойство не меняет.</p>
      <p>Если значение этого свойства больше border-width, картинка рамки заползёт под содержимое, даже если не задано свойство fill.</p>
      <pre>{`border-image-width: 10px 20px 30px 40px;
border-image-width: 10px 50px;`}
      </pre>
      <h4>border-image-outset</h4>
      <p>Ещё одно свойство, относящееся к фоновому изображению рамки, border-image-outset. Аналогично outline-offset это свойство позволяет отодвинуть рамку за пределы элемента, но при этом одновременно немного масштабируя картинку. Отрицательные значения border-image-outset не поддерживаются.</p>
    </section>
  );
}

export default BackgroundsAndFrames;
