import React from 'react';

function Flexbox() {
  const FlexCaseOneWrapper = {
    width: '700px',
    display: 'flex',
    margin: '0 auto',
    padding: '20px',
    backgroundColor: 'rgba(252, 241, 145, 0.726)',
  };

  const FlexCaseOneChild1 = {
    display: 'flex',
    alignItems: 'center',
    width: '33%',
    margin: '5px',
    padding: '5px 10px',
    backgroundColor: 'rgba(79, 255, 202, 0.726)',
  };

  const FlexCaseOneChild2 = {
    display: 'flex',
    alignItems: 'center',
    width: '33%',
    margin: '5px',
    padding: '5px 10px',
    backgroundColor: 'rgba(168, 248, 165, 0.726)',
  };

  const FlexCaseOneChild3 = {
    display: 'flex',
    alignItems: 'center',
    width: '33%',
    margin: '5px',
    padding: '5px 10px',
    backgroundColor: 'rgba(248, 199, 204, 0.726)',
  };

  return (
    <section className="conspect">
      <h1>Flexbox</h1>
      <h2>Свойство display: flex (гибкий), flex-элемент</h2>
      <p>Флексбокс — это первый CSS-механизм, предназначенный для построения сеток и создания сложных раскладок блоков.</p>
      <p>Бокс с типом flex называют флекс-контейнером, а его дочерние боксы — флекс-элементами.</p>
      <ul>
        <li>флекс-элементы, в отличие от блочных элементов, не растягиваются на всю ширину контейнера по умолчанию;</li>
        <li>на флекс-элементы не действует свойство float.</li>
      </ul>

      <h2>Свойство flex-direction, главная ось</h2>
      <p>Вместо направлений «лево» и «право» во флексбоксе используется понятие «главная ось». Поток флекс-элементов «течёт» вдоль главной оси от её начала к её концу.</p>
      <p>По умолчанию главная ось направлена слева направо, но её можно разворачивать во всех направлениях с помощью свойства flex-direction, которое задаётся для флекс-контейнера. Значения свойства:</p>
      <ul>
        <li>row — значение по умолчанию, главная ось направлена слева направо.</li>
        <li>column — главная ось направлена сверху вниз.</li>
        <li>row-reverse — главная ось направлена справа налево.</li>
        <li>column-reverse — главная ось направлена снизу вверх.</li>
      </ul>
      <p>Флекс-элементы всегда располагаются вдоль главной оси, независимо от её направления.</p>

      <h2>Поперечная ось flexbox</h2>
      <p>Вместо направлений «верх» и «низ» во флексбоксе используется понятие «поперечная ось». Вдоль этой оси работают «вертикальные» выравнивания.</p>
      <p>Поперечная ось всегда перпендикулярна главной оси и поворачивается вместе с ней. Свойства для поворота поперечной оси нет.</p>

      <h3>Свойство justify-content, выравнивание вдоль главной оси</h3>
      <ul>
        <li>flex-start - значение по умолчанию. При этом значении элементы располагаются у начала главной оси.</li>
        <li>center - элементы располагаются по центру главной оси.</li>
        <li>flex-end расположит элементы в конце главной оси.</li>
        <li>space-between — расстояния между соседними элементами одинаковые, между элементами и краями флекс-контейнера отступов нет.</li>
        <li>space-around — расстояния между соседними элементами одинаковые, между элементами и краями флекс-контейнера есть отступ, равный половине расстояния между соседними элементами.</li>
      </ul>
      <p>Если нужны разные внешние отступы, то justify-content не подойдёт. Нужно использовать margin.</p>

      <h3>Свойство align-items, выравнивание вдоль поперечной оси</h3>
      <p>По умолчанию грид-элементы занимают всё доступное пространство по высоте. Такое поведение можно изменить с помощью свойства align-items. Оно задаётся грид-контейнеру и управляет выравниванием грид-элементов по вертикали.</p>
      <ul>
        <li>stretch - значение по умолчанию. Флекс-элементы растягиваются на всю «высоту» флекс-контейнера. Если флекс-элементам задана высота, то растягиваться они не будут.</li>
        <li>flex-start.</li>
        <li>flex-end.</li>
        <li>center - элементы выравниваются по центру поперечной оси.</li>
        <li>baseline - флекс-элементы будут выравниваться по базовой линии текста в них. Эта воображаемая линия проходит по нижней части букв. Если выровнять флекс-элементы по базовой линии, то они выстроятся так, чтобы текст в них был как бы на «одной строке».</li>
      </ul>

      <h3>Свойство align-self, эгоистичное выравнивание</h3>
      <p>Задать какому-то элементу отличное от других распределение по главной оси нельзя. И это вполне логично, ведь тогда элементы будут «сталкиваться» друг с другом.</p>
      <p>C поперечной осью всё проще. Можно сказать, что у каждого элемента она своя, и можно задавать им разное поперечное выравнивание. Для этого используется свойство align-self, которое задаётся для самих флекс-элементов, а не для флекс-контейнера.</p>
      <p>У свойства align-self те же самые значения, что и у align-items.</p>

      <h3>Свойство flex-wrap, перенос flex-элементов</h3>
      <p>Если флекс-элементов в контейнере станет больше, чем может уместиться в один ряд, то они будут сжиматься до минимально возможной ширины. Даже если им задать ширину явно, механизм флексбокса может её уменьшить. Если они перестанут помещаться в контейнер и после уменьшения, то они выйдут за его пределы, но продолжат располагаться в один ряд. Это чем-то похоже на поведение ячеек в таблице.</p>
      <p>По умолчанию флекс-контейнер однострочный. Чтобы элементы не выпадали из контейнера, его делают многострочным.</p>
      <ul>
        <li>nowrap - значение по умолчанию, то есть перенос флекс-элементов на новую строку запрещён.</li>
        <li>wrap разрешает перенос флекс-элементов на новую строку, если они не помещаются в контейнер.</li>
        <li>wrap-reverse, обратный перенос. Если перенос флекс-элементов разрешён, то ряды элементов располагаются вдоль поперечной оси. Первый ряд располагается в начале поперечной оси, а последний в конце. Но так работает только значение wrap. Если для flex-wrap задать значение wrap-reverse, то элементы будут переноситься, а ряды будут располагаться в обратном порядке: первый в конце поперечной оси, а последний в начале.</li>
      </ul>

      <h3>Свойство align-content, выравнивание строк flex-контейнера</h3>
      <ul>
        <li>flex-start - располагает ряды в начале поперечной оси.</li>
        <li>flex-end - flex-end располагает ряды в конце поперечной оси.</li>
        <li>center,</li>
        <li>space-between - равномерно распределяет ряды вдоль поперечной оси, расстояния между соседними рядами одинаковые, отступов у краёв нет.</li>
        <li>space-around - равномерно распределяет ряды вдоль поперечной оси, расстояния между соседними рядами одинаковые, отступы у краёв равны половине расстояния между соседними рядами.</li>
        <li>stretch, которое есть у align-content, но нет у justify-content, и является значением по умолчанию.</li>
      </ul>
      <p>Свойство align-content «перекрывает» заданное значение align-items, которое управляет выравниванием флекс-элементов вдоль поперечной оси. Это происходит и в случае, когда есть только один ряд флекс-элементов, и когда рядов несколько.</p>
      <p>В случае одновременного задания align-items и align-content свойство align-items не отключается полностью, а может влиять на отображение флекс-элементов в рядах.</p>
      <p>Это происходит, когда мы используем для align-content значение по умолчанию — stretch. Оно растягивает ряды флекс-элементов, при этом оставшееся свободное место между ними делится поровну.</p>
      <p>Отображение строк при align-content: stretch зависит от значения align-items. Если у align-items задано значение stretch, то элементы в строках растягиваются на всю высоту своей строки.</p>
      <p>Если значение отлично от stretch, то элементы в строках ужимаются под своё содержимое и выравниваются в строках в зависимости от значения align-items.</p>

      <h3>Свойство order, порядковый номер flex-элемента</h3>
      <p>Порядковый номер задаётся целым числом, положительным или отрицательным. По умолчанию порядковый номер флекс-элементов равен 0, а сортировка элементов производится по возрастанию номера.</p>
      <p>Это очень полезное свойство, так как с его помощью можно менять порядок следования флекс-элементов в потоке, не меняя HTML-код.</p>
      <p>Свойство order меняет порядок только внутри родительского контейнера. То есть переместить элемент из шапки в подвал с его помощью не получится.</p>

      <h3>Идеальное центрирование, margin: auto у flex-контейнера</h3>
      <p>задать контейнеру раскладку флексбокса, а дочернему флекс-элементу margin: auto. В этом случае флекс-элемент уменьшит свой размер под содержимое и отцентруется по вертикали и горизонтали.</p>

      <h3>Особенности свойства margin</h3>
      <ul>
        <li>внешние отступы не схлопываются, ни по горизонтали, ни по вертикали;</li>
        <li>внешние отступы не выпадают, ни из флекс-контейнера, ни из флекс-элементов;</li>
        <li>значение auto получило премию журнала Форбс в номинации «Самое влиятельное значение CSS-свойства внутри флекс-контейнера».</li>
      </ul>
      <p>Всё дело в механизме распределения свободного места. Если внутри флекс-контейнера есть свободное место, то оно перераспределяется так:</p>
      <ul>
        <li>находятся элементы, у которых есть внешние отступы со значением auto;</li>
        <li>всё свободное место в соответствующих направлениях отдаётся таким отступам (то есть задаётся определённый размер отступа в пикселях);</li>
        <li>если элементов с автоматическими отступами на одном направлении несколько, то место между ними перераспределяется поровну;</li>
        <li>только после этого запускаются механизмы выравнивания.</li>
      </ul>

      <h3>Выравнивание и внешние отступы</h3>
      <p>Автоматический margin влияет и на выравнивание флекс-элементов вдоль поперечной оси. Если у флекс-элемента отступ сверху или снизу автоматический, то на него не влияют, ни align-items, ни align-self. Такой элемент прижмётся либо к верху контейнера, либо к низу.</p>
      <p>А если задать автоматические отступы с противоположных сторон, то элемент разместится по центру флекс-контейнера, так как свободное место «впитается» отступами поровну.</p>
      <p>Дело в том, что «старые нефлексовые» свойства, такие как отступы или размеры, ничего не знают про направление осей. Они «мыслят по-старому», понятиями «верх» и «низ», «право» и «лево».</p>

      <h3>Базовый размер флекс-элемента, flex-basis</h3>
      <p>задаёт базовый размер флекс-элемента или размер вдоль главной оси.</p>
      <p>Если flex-basis не задан или его значение равно auto, то базовый размер берётся из width или height. Свойство flex-basis принимает те же значения, что и width/height:</p>
      <pre>{`
flex-basis: 100px; /* базовый размер 100 пикселей */
flex-basis: 50%;   /* базовый размер 50% контейнера */`}
      </pre>
      <p>Свойство flex-basis «сильнее» свойств width и height, и если у флекс-элемента заданы все три свойства, то flex-basis переопределит либо ширину, либо высоту в зависимости от направления главной оси.</p>

      <h3>Коэффициент растягивания элементов, flex-grow</h3>
      <p>Свойство flex-grow принимает неотрицательные числовые значения, его значение по умолчанию — 0.</p>
      <p>Если внутри флекс-контейнера по главной оси остаётся свободное место, то мы можем попросить флекс-элемент, чтобы он увеличился и занял это место. Это делается с помощью свойства flex-grow, которое можно назвать «коэффициентом флекс-жадности» флекс-элемента.</p>
      <p>Если значение flex-grow больше нуля, то флекс-элемент будет увеличиваться, «захватывая» оставшееся свободное место.</p>
      <p>Если значение flex-grow равно нулю, то флекс-элемент «не претендует» на оставшееся свободное место во флекс-контейнере и не будет увеличиваться, чтобы занять это место.</p>
      <p>Получается, что базовый размер — это исходный размер флекс-элементов до применения flex-grow.</p>

      <h3>Пропорциональное растягивание элементов</h3>
      <p>Если сразу у нескольких флекс-элементов значение flex-grow больше нуля, то они будут делить свободное место между собой.</p>
      <p><span className="hl-5">важно не само значение коэффициента, а его соотношение с коэффициентами остальных элементов.</span></p>

      <h3>Расчёт итогового размера с flex-grow</h3>
      <dl>
        <dt>1 шаг. Рассчитываем свободное место во флекс-контейнере:</dt>
        <dd>Свободное место = Ширина контейнера - Сумма базовых размеров элементов</dd>
        <dt>2 шаг. Считаем размер минимальной доли свободного места:</dt>
        <dd>Доля свободного места = Свободное место / Сумма flex-grow всех элементов</dd>
        <dt>3 шаг. Базовый размер каждого флекс-элемента увеличиваем на размер минимальной доли свободного места, умноженной на значение flex-grow этого элемента:</dt>
        <dd>Итоговый размер = Базовый размер + (Доля свободного места * flex-grow)</dd>
      </dl>
      <p>Использовать flex-basis: 0 и flex-grow для точного управления относительными размерами не стоит. Лучше использовать базовый размер в процентах.</p>
      <div className="note">Тонкость. На размер оставшегося свободного места влияет не только flex-basis, но и рамки, и отступы. Если flex-basis явно задано нулевое значение, то min-width на размер свободного места влиять не будет, так как ограничения размеров к флекс-элементам применяются уже после перераспределения свободного места.</div>

      <h3>Коэффициент сжатия элементов, flex-shrink</h3>
      <p>Если сумма базовых размеров флекс-элементов больше, чем размер флекс-контейнера, то возникает отрицательное пространство.</p>
      <p>Свойство flex-shrink принимает неотрицательные числовые значения, его значение по умолчанию — 1.</p>
      <p>Если значение flex-shrink больше нуля, то флекс-элемент будет уменьшаться, «впитывая» часть отрицательного пространства, если оно существует.</p>
      <p>Если значение flex-shrink равно нулю, то флекс-элемент уменьшаться не будет.</p>
      <p>Флекс-элементы стараются быть максимально «гибкими» и не выпадать из своего контейнера, поэтому у flex-shrink значение по умолчанию равно 1. Но если задавать нулевые значения для коэффициента сжатия, то выпадения элементов добиться можно.</p>

      <h3>Расчёт итогового размера с flex-shrink</h3>
      <p>Ниже описан механизм расчёта размеров элементов, когда места в контейнере не хватает:</p>
      <dl>
        <dt>1 шаг. Рассчитываем отрицательное пространство (ОП) во флекс-контейнере:</dt>
        <dd>ОП = Ширина контейнера - Сумма базовых размеров элементов</dd>
        <dt>2 шаг. Находим сумму произведений базовых размеров (СПБР) элементов на их коэффициенты сжатия:</dt>
        <dd>СПБР = (Базовый размер1 * flex-shrink1) + (Базовый размер2 * flex-shrink2) + … + (Базовый размерn * flex-shrinkn)</dd>
        <dt>3 шаг. Для каждого элемента считаем «нормированный коэффициент сжатия» (НКС), для чего произведение базового размера элемента на его коэффициент сжатия делим на СПБР:</dt>
        <dd>НКС = (Базовый размер * flex-shrink) / СПБР</dd>
        <dt>4 шаг. Базовый размер элемента уменьшаем на часть ОП пропорциональную НКС элемента. ОП для расчёта берём по модулю, то есть отбрасывая минус:</dt>
        <dd>Итоговый размер = Базовый размер - (НКС * ОП)</dd>
      </dl>

      <h3>flex-shrink и min-width</h3>
      <p>Есть несколько тонкостей, касающихся сжатия флекс-элементов:</p>
      <ul>
        <li>элементы сжимаются в пределах своих базовых размеров, внутренние отступы и рамки не сжимаются;</li>
        <li>«ограничительные» свойства, такие как min-width, применяются к элементам после этапа перераспределения свободного места или отрицательного пространства.</li>
      </ul>

      <h2>Сокращённое свойство flex: flex-grow, flex-shrink и flex-basis.</h2>
      <p>Ещё у свойства flex есть особые значения: initial, auto, none. Также второй и третий компоненты необязательны. Ниже показаны различные значения свойства и их расшифровки.</p>
      <pre>{`flex: initial; -> flex: 0 1 auto;
flex: auto;  -> flex: 1 1 auto;
flex: none;  -> flex: 0 0 auto;
flex: 1 0;   -> flex: 1 0 0%;
flex: 1;     -> flex: 1 1 0%;`}
      </pre>
      <p>В некоторых браузерах неполные или особенные значения свойства flex интерпретируются с ошибками. Поэтому лучше задавать все три компоненты в значении этого свойства.</p>

      <h2>Многострочный флекс-контейнер и flex-shrink</h2>
      <p>Как будут растягиваться и сжиматься элементы в многострочном контейнере, с flex-wrap: wrap;?</p>
      <p>В таком контейнере свойство flex-shrink будет работать как обычно, но необходимость в нём будет возникать намного реже. Ведь при нехватке места в строке флекс-элементы будут переноситься на новую строку.</p>
      <p>Но если появятся флекс-элементы, базовый размер которых больше размера флекс-контейнера, то такие элементы будут сжиматься и занимать целую строку. Наверное, это единственный случай, когда flex-shrink делает что-то полезное в многострочном контейнере.</p>

      <h2>Многострочный флекс-контейнер и flex-grow</h2>
      <p>В отличие от flex-shrink, свойство flex-grow в многострочном флекс-контейнере срабатывает намного чаще и пользы приносит намного больше. В каждой строке такого контейнера может быть свободное место и механизм перераспределения этого места работает построчно.</p>
      <p>Поэтому возможность «растянуть» флекс-элементы, чтобы строки заполнялись по ширине полностью, будет возникать достаточно часто.</p>

      <h2>flex-basis: 100% и flex-wrap</h2>
      <p>Если задать базовый размер флекс-элемента 100% и при этом включить перенос элементов на новую строку, то элементы расположатся столбцом, хотя главная ось контейнера будет по-прежнему направлена слева направо.</p>


      <h2>Cases</h2>

      <h3>Выравнивание блоков по высоте с помощью flexbox</h3>
      <p>В обычной блочной модели есть фундаментальный недостаток — соседние блоки ничего не знают друг о друге, поэтому их высоты нельзя «связать». А с помощью флексбоксов эта проблема решается легко и изящно, ведь флекс-элементы по умолчанию растягиваются на всю высоту контейнера.</p>
      <ol>
        <li>Задаём display: flex родительскому контейнеру.</li>
        <li>Задаём display: flex для дочерних блоков.</li>
      </ol>
      <div style={FlexCaseOneWrapper}>
        <div style={FlexCaseOneChild1}><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip</p></div>
        <div style={FlexCaseOneChild2}><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></div>
        <div style={FlexCaseOneChild3}><p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip</p></div>
      </div>
      <p>Теперь текстовые блоки привязаны по высоте друг к другу. Этот приём работает за счёт значения stretch у свойства align-items (и это значение по умолчанию). С помощью этого приёма можно связывать высоту блоков любой вложенности, главное создать неразрывную цепочку вложенных друг в друга флекс-контейнеров.</p>

      <h3>Использование свойства flex-grow для создания «адаптивности от контейнера»</h3>
      <p>«Адаптивность от контейнера»:</p>
      <img src="img/flex/flex-12.png" alt="" width="730" />
      <p>Помимо всего прочего, флекс умеет делать красивое заполнение строк флекс-элементами так, чтобы в каждой строке края флекс-элементов вплотную прилегали к краям контейнера. И работает этот механизм как для фиксированных так и для резиновых контейнеров. Такое поведение возможно благодаря сочетанию flex-wrap: wrap и положительного значения flex-grow.</p>
      <p>Алгоритм заполнения строк состоит из следующих шагов:</p>
      <ol>
        <li>по исходным базовым размерам флекс-элементов браузер определяет, сколько будет флекс-элементов в каждой флекс-строке;</li>
        <li>после распределения флекс-элементов по флекс-строкам для элементов с положительным значением flex-grow включаются гибкие размеры и такие элементы «съедают» свободное пространство в своей строке пропорционально значению свойства flex-grow.</li>
      </ol>
      <p><a href="examples/flex-grow-in-work/index.html" target="_blank" rel="noopener noreferrer">Пример работы</a></p>

      <h3>Адаптивное горизонтальное меню</h3>
      <p>Зададим меню раскладку флексбокса, пункты станут флекс-элементами. С помощью свойства распределения элементов justify-content добьёмся нужного результата.</p>

      <h3>Вертикальный ряд иконок</h3>
      <p>Для начала выстроим два блока, идущих друг за другом, в ряд. Затем изменим порядок их отображения.</p>
      <p>В нашем примере давайте сделаем блок с иконками социальных сетей вложенным флекс-контейнером, а его дочерние флекс-элементы распределим по всей высоте блока.</p>

      <h3>Сортировка элементов на CSS</h3>
      <p>Интересного эффекта можно достичь, если скомбинировать флексбокс и трюк с селектором :checked ~.</p>
      <p>Приём заключается в следующем: с помощью селектора по выделению чекбокса можно управлять порядком флекс-элементов, изменяя направление главной оси с помощью flex-direction. Лучше всего эффект работает, когда направление главной оси меняется с «сверху вниз» на «снизу вверх».</p>
      <p>При этом флекс-контейнер должен находиться в разметке на одном уровне с чекбоксом.</p>
      <p>Таким образом реализуется сортировка на CSS, без использования JavaScript.</p>

      <h3>Заголовок с описанием на флексбоксах</h3>
      <p>Довольно распространённый ход в интерфейсе — блок с заголовком и небольшим уточняющим подзаголовком на одной строке. Заголовок находится в начале строки, а подзаголовок прижат к правому краю.</p>
      <p>Если текст заголовка или подзаголовка сильно увеличится, то вёрстка не должна ломаться — тексты просто должны расположиться друг под другом.</p>
      <p>Сверстать элемент с таким гибким поведением с помощью float или display: table не получится. Ведь нужно, чтоб блоки подписей одновременно и занимали свободное пространство, и чтобы их размеры зависели от текстового содержания, и чтобы в случае переполнения сетка перестраивалась.</p>
      <p>Здесь нам поможет только флексбокс с flex-grow.</p>

      <h3>«Гибкое» меню с переполнением</h3>
      <p>Напомним, что в прошлом варианте пункты равномерно распределялись внутри контейнера меню с помощью justify-content: space-around.</p>
      <p>Новый вариант меню будет более адаптивным: пункты меню будут переноситься на следующую строку, если места будет не хватать. А ещё для достижения красивой симметрии пункты будут растягиваться, чтобы занимать весь контейнер меню. И снова нам поможет flex-grow.</p>
      <p>Создадим базовую раскладку и зададим перенос строк. Теперь остаётся задать элементам меню коэффициент растяжения и проверить, как будет вести себя меню, если мы решим изменить его ширину, либо добавить пункты.</p>
      <p>Получившееся решение удобно применять для адаптации к мобильным интерфейсам. При этом даже не потребуется добавлять дополнительные стили для мобильных вьюпортов.</p>

      <h3>Поля ввода с динамической шириной</h3>
      <ul>
        <li>На одной строке с полем могут находиться другие элементы: кнопки, ссылки, подписи.</li>
        <li>Размер дополнительных элементов не определён, он зависит от их содержимого.</li>
        <li>При этом поле должно растягиваться на всё оставшееся в родительском контейнере место.</li>
        <li>И изменять ширину при изменении размеров контейнера.</li>
      </ul>
      <p>Решить эту задачу можно только при помощи флексбокса. Превратим контейнер поля ввода во флекс-контейнер, все элементы внутри него превратятся во флекс-элементы, базовый размер которых будет зависеть от их содержания — flex-basis: auto;. И останется только задать ненулевой коэффициент растягивания полям ввода.</p>
      <p>В широком контейнере всё будет работать отлично. Проблемы могут появиться в слишком узких контейнерах: по умолчанию поля ввода не будут сжиматься после определённой ширины, что приведёт к выпаданию текста из остальных элементов.</p>
      <p>Чтобы справиться с этими проблемами, надо задать всем элементам кроме полей ввода нулевой коэффициент сжатия, а самим полям ввода явно прописать минимальную ширину.</p>
    </section>
  );
}
export default Flexbox;
