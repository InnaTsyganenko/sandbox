import React from 'react';

function Animations() {

  return (
    <section className="conspect">
      <h1>Динамические эффекты</h1>
      <p><a href="https://habr.com/ru/company/htmlacademy/blog/255583/" target="_blank" rel="noopener noreferrer">Принципы анимации для веба</a></p>
      <p><a href="https://vc.ru/flood/4241-payment-experience-animations" target="_blank" rel="noopener noreferrer">UI-дизайнер Stripe: Как улучшить юзабилити форм оплаты с помощью анимаций</a></p>
      <h2>Анимация</h2>
      <p>Описание CSS-анимации состоит из двух частей: набора ключевых кадров keyframes и параметров самой анимации.</p>
      <p>Вот пример описания ключевых кадров анимации:</p>
      <pre>{`@keyframes stretching {
  0% {
    width: 100px;
  }
  100% {
    width: 200px;
  }
}`}
      </pre>
      <p>Анимация в примере имеет название stretching, и в ней описывается, как будет меняться стиль блока от начальной до конечной точки. Эту анимацию можно применить к любому элементу, для этого достаточно добавить в CSS два свойства — animation-name (название анимации) и animation-duration (длительность) — и задать им нужные значения. Например:</p>
      <pre>{`.button {
  animation-name: stretching;
  animation-duration: 1s;
}`}
      </pre>
      <p>Этот код назначит анимацию stretching элементам с классом button. В результате работы анимации элемент плавно увеличит ширину со 100px до 200px за 1 секунду.</p>

      <h2>@keyframes: раскадровка</h2>
      <p>Для каждой анимации нужно задать имя, описать начальный и конечный ключевые кадры, которые задаются с помощью зарезервированных слов from и to или значений 0% и 100%.</p>
      <p>Также можно описать промежуточные ключевые кадры, которые задаются с помощью процентов.</p>
      <p>Если не задан начальный ключевой кадр, то анимация будет проигрываться из исходного стилевого состояния элемента к ближайшему шагу из перечисленных в keyframes и далее.</p>
      <p>Если не задан конечный кадр, то после достижения последнего промежуточного шага, анимация проиграется в обратном направлении до достижения изначального состояния элемента.</p>
      <p>Ключевые кадры внутри keyframes могут быть написаны в произвольном порядке, но лучше их перечислять по хронологии от меньшего к большему.</p>
      <p>Длительность анимации animation-duration задаётся в секундах или миллисекундах, например: 10s, 100ms.</p>
      <p>Вот пример анимации из 4 кадров:</p>
      <pre>{`@keyframes coloring {
  from { background-color: red; }
  33%  { background-color: yellow; }
  66%  { background-color: green; }
  to   { background-color: blue; }
}`}
      </pre>

      <h3>@keyframes: группировка кадров</h3>
      <p>Ключевые кадры в keyframes можно группировать, для этого нужно перечислить их через запятую. Рассмотрим пример:</p>
      <pre>{`@keyframes stretching {
  0%,
  50% {
    width: 100px;
  }
  100% {
    width: 200px;
  }
}`}
      </pre>
      <p>В этом примере первые два кадра сгруппированы. Анимируемый элемент сначала изменит свою ширину до 100px и останется в этом состоянии половину времени анимации. А за вторую половину времени он растянется от 100px до 200px.</p>

      <h2>Множественная анимация</h2>
      <p>Множественные анимации задаются так же, как и множественные фоны и тени — с помощью перечисления свойств через запятую.</p>
      <p>Одному элементу могут быть одновременно назначены несколько анимаций. Если в этих анимациях меняются разные свойства элемента, то они будут проигрываться одновременно.</p>
      <p>Чтобы назначить элементу вторую анимацию, нужно добавить её название и длительность через запятую в свойствах animation-name и animation-duration. Вот так:</p>
      <pre>{`.element {
  animation-name: move, stretch;
  animation-duration: 5s, 5s;
}`}
      </pre>
      <p>В этом примере две анимации запустятся одновременно, элемент будет параллельно двигаться и удлиняться в течение 5-ти секунд.</p>

      <h2>Количество проигрываний анимации: animation-iteration-count</h2>
      <p>В качестве значения оно принимает положительные числа, ноль или служебное слово infinite: при нуле анимация не будет выполнена, в остальных случаях она повторится указанное число раз, infinite - бесконечно.</p>

      <h3>Направление анимации: animation-direction</h3>
      <p>По умолчанию анимация имеет прямое направление normal. Но можно назначить и обратный порядок анимации, чтобы проигрывание начиналось с конца и шло к началу (то есть за начальную точку считался кадр to, а за конечную — from). Для этого используется значение reverse свойства animation-direction.</p>
      <p>У свойства animation-direction есть ещё два значения. Они используются, когда количество проигрываний анимации animation-iteration-count больше одного. И оба они определяют чередующееся направление анимации.</p>
      <p>Если задано значение alternate, то нечётные проигрывания будут выполняться в прямом направлении, а чётные — в обратном.</p>
      <pre>{`.element {
  animation-name: move;
  animation-duration: 1s;
  animation-iteration-count: 2;
  animation-direction: alternate;
}`}
      </pre>
      <p>В примере анимация move выполнится два раза: в первый (нечётный) раз направление будет прямым, а во второй (чётный) — обратным.</p>
      <p>Если задано значение alternate-reverse, то нечётные проигрывания наоборот будут выполняться в обратном направлении, а чётные — в прямом.</p>

      <h2>Задержка начала анимации: animation-delay</h2>
      <p>Синтаксис свойства animation-delay, с помощью которого и назначается задержка начала, идентичен синтаксису свойства animation-duration.</p>

      <h3>Состояние до и после анимации: animation-fill-mode</h3>
      <p>В предыдущих примерах элементы после проигрывания анимации возвращались в исходное состояние. Но есть свойство, которое определяет, будет ли видимым эффект от анимации, когда сама анимация уже закончилась — это animation-fill-mode. При задании свойству значения forwards элемент будет сохранять состояние после завершения анимации.</p>
      <p>Сохранение свойств анимации по её завершению animation-fill-mode: forwards работает и в случае нескольких повторов анимации или чередующегося направления.</p>
      <p>Другое значение свойства animation-fill-mode — backwards. Это значение определяет состояние элемента до начала анимации.</p>
      <p>Если элементу назначена анимация с задержкой начала проигрывания и animation-fill-mode: backwards, то стили, описанные в первом ключевом кадре from или 0%, будут применены сразу, ещё до начала проигрывания анимации.</p>
      <p>Задание начального состояния анимации до начала её выполнения animation-fill-mode: backwards работает и в случае нескольких повторов или чередующихся направлений анимации.</p>
      <p>Третье значение свойства animation-fill-mode — both.</p>
      <p>Оно объединяет действия forwards и backwards. То есть до начала анимации элементу присваивается состояние первого ключевого кадра, а после завершения — конечное состояние анимации сохраняется.</p>
      <p>Действие animation-fill-mode: both распространяется и на многоразовую, и на чередующуюся анимацию.</p>

      <h3>Остановка и запуск анимации: animation-play-state</h3>
      <p>С его помощью можно поставить анимацию «на паузу», а потом возобновить с места остановки.</p>
      <p>Свойство принимает два значения running и paused. Как видно из названий, paused приостанавливает анимацию, а running начинает или возобновляет анимацию, поставленную на паузу. Значение running задано по умолчанию.</p>

      <h3>«Форма» анимации, animation-timing-function</h3>
      <p>Oпределяет, как именно будет происходить анимация: с какой скоростью и ускорением будут меняться свойства, задействованные в ней.</p>
      <ul>
        <li>ease - анимация начинается медленно, затем ускоряется и к концу движения опять замедляется.</li>
        <li>linear - анимация равномерна, без ускорений и замедлений.</li>
        <li>ease-in - анимация медленно начинается, а к концу ускоряется;</li>
        <li>ease-out — начинается быстро, а к концу замедляется</li>
        <li>ease-in-out - похоже на ease, то есть анимация начинается и заканчивается медленно, но происходит это чуть-чуть интенсивнее.</li>
      </ul>
      <p>Значения этих свойств - довольно сложная математика кубических кривых Безье.</p>
      <p>steps - позволяют задать «ступеньки», по которым будет идти анимация. Синтаксис steps следующий:</p>
      <pre>{'animation-timing-function: steps(число_шагов, направление);'}</pre>
      <p>Тут всё просто: число шагов — это целое число, за которое будет выполнена вся анимация; направление может принимать значение start или end.</p>
      <p>При заданном start первый шаг выполняется одновременно с началом анимации, а в случае c end последний шаг будет выполнен вместе с завершением анимации. То есть при start пошаговая анимация идёт как бы с опережением, а при end — вдогонку.</p>
      <a>Водное путешествие</a>
      <a>Воздушное путешествие</a>
      <a>Эксперимент с аккумуляторами</a>
      <a>Запуск фабрики</a>
      <a>Ракета на старт</a>
    </section>
  );
}
export default Animations;
