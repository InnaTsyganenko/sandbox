import React from 'react';

function FlowGridsLayout() {

  return (
    <section className="conspect">
      <h1>Поток, сетки и макет</h1>
      <h2>Поток документа</h2>
      <p><span className="hl-8"><b>Поток документа</b></span> - порядок отображения элементов на странице и их взаимодействие друг с другом. Потоком можно управлять, изменяя тип боксов и свойства по умолчанию.</p>
      <h2>Сетки</h2>
      <p><span className="hl-9"><b>Сетка</b></span> — это взаимное расположение крупных блоков сайта.  Как правило, количество сеточных элементов на странице не меняется, а их размеры задаются согласно макету.</p>
      <p><span className="hl-6"><b>Модульная сетка</b></span> в веб-дизайне представляет собой единую схему расположения всех элементов и блоков сайта. Этот каркас проходит через все страницы и помогает создать визуальный порядок. По сетке проще располагать элементы, определять расстояния между ними, создавать композиции.</p>
      <p>Когда мы говорим про модульные сетки применительно к сайтам, то прежде всего мы имеем в виду «колоночную систему», то есть когда вёрстку «укладывают» в определённое число ритмично повторяющихся вертикальных полос. К примеру, сайты-визитки и сайты-презентации зачастую вписываются в одноколоночную структуру, а домашние страницы — в двухколоночную.</p>
      <p>Более сложные информационные проекты, соответственно, имеют более сложный и продуманный макет. Двенадцатиколоночный макет считается стандартным и классическим, под него разработаны многие «системы» сеток — шаблонные решения, позволяющие за счёт готового кода сократить объём работы.</p>
      <p>Графические редакторы также содержат в своём арсенале инструменты для работы с сетками. Например в Figma есть инструмент Design/Layout Grid. Комбинируя несколько сеток, можно задать как горизонтальный так и вертикальный ритм в макете.</p>
      <p>В Adobe Photoshop есть похожий инструмент, менее удобный и не такой гибкий.</p>
      <p><span className="hl-10"><b>Макет</b></span> — это изображение веб-страницы.</p>
      <p>Каждому HTML-элементу на странице соответствует прямоугольная область. Такие области называются боксами. Самые распространённые типы боксов — блочные и строчные.</p>
      <p>Блочные элементы отображаются сверху вниз, а строчные элементы располагаются сверху вниз и слева направо и при необходимости переносятся на новую строку.</p>
      <p>Элементы можно вкладывать друг в друга. Чем раньше в коде расположен элемент, тем выше он расположен на странице.</p>
      <p>Некоторые типы элементов могут вести себя в потоке более сложно. Например, они могут располагаться в несколько колонок, как блочно-строчные элементы.</p>
      <p>Любой элемент, который находится в потоке, занимает на странице свою собственную площадь и, если надо, отталкивает от себя соседей с помощью <span className="hl-9">margin</span>.</p>
      <p><a href="https://codepen.io/carolineartz/full/ogVXZj/" target="_blank" rel="noopener noreferrer">Interactive box-model diagram</a></p>
      <p><a href="https://habr.com/ru/post/340420/" target="_blank" rel="noopener noreferrer">Организация отступов в верстке (margin/padding)</a></p>
      <p><a href="https://habr.com/ru/post/465839/" target="_blank" rel="noopener noreferrer">Всё, что вам нужно знать про CSS Margin</a></p>

      <h2>Блочная модель документа</h2>
      <h3>Блочные боксы</h3>
      <p>По умолчанию блочным боксом обладают крупные поточные элементы. До и после блочного бокса существует перенос строки. Для блочных боксов можно задавать ширину, высоту, внутренние и внешние отступы. Занимают всё доступное пространство по горизонтали.</p>
      <p>Блочными боксами по умолчанию обладают такие теги как: <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;ul&gt;</code> и так далее.</p>
      <p>Ещё один важный тег с блочным боксом — это тег <code>&lt;div&gt;</code>, который обозначает просто «блок» или «прямоугольный контейнер». Этот тег чаще всего используется для создания сеток.</p>
      <p>Область, занимаемая блочным боксом, складывается из его ширины и высоты содержания (свойства width и height), внутренних (свойство padding и margin) и внешних отступов, ширины рамок (свойство border).</p>
      <p>По умолчанию блочные боксы занимают всю доступную ширину, которая равна ширине родительского контейнера или окна браузера.</p>
      <p>Высота по умолчанию блочных боксов зависит от их содержимого. Если задать блочному боксу ширину и высоту так, что содержимое не будет в него помещаться, то оно как бы «выпадет» из него.</p>

      <h3>Строчные боксы</h3>
      <p>Строчные боксы — противоположность блочных. Строчные боксы располагаются друг за другом в одной строке, могут разрываться и находиться на нескольких строках</p>
      <p>До и после строчного бокса отсутствуют переносы строки. Ширина и высота строчного бокса зависит только от его содержания, задать размеры с помощью CSS нельзя. Можно задавать только горизонтальные отступы.</p>
      <p>Теги со строчным боксом по умолчанию: <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;span&gt;</code> и так далее.</p>
      <p><span className="hl-4">Строчные боксы не реагируют на задание ширины и высоты в CSS.</span></p>
      <p>Строчные боксы реагируют только на горизонтальные внешние отступы.</p>

      <h3>Внутренние отступы, свойство padding</h3>
      <p>Свойство padding задаёт внутренние отступы блока — отступы от внешней границы блока до его содержимого.</p>
      <pre>{`padding: 10px; // Одинаковые отступы со всех сторон.
padding: 5px 10px; // Отступы сверху и снизу 5px, справа и слева 10px.
padding: 5px 10px 15px; // Отступ сверху 5px, слева и справа 10px, снизу 15px.
padding: 5px 10px 15px 20px; // Разные отступы со всех сторон,
в порядке верхний, правый, нижний, левый.`}
      </pre>
      <p>Для строчных боксов лучше не задавать вертикальных отступов, так как они ведут себя непредсказуемо.</p>

      <h3>«Схлопывание» внешних отступов</h3>
      <p>Вертикальный отступ между двумя соседними элементами равен максимальному отступу между ними. Если отступ одного элемента равен 50px, а второго 30px, то отступ между ними будет 50px.</p>
      <p>Горизонтальные отступы между элементами просто складываются. Например, горизонтальный отступ между двумя элементами с отступами 30px будет равен 60px.</p>

      <h3>«Выпадание» внешних отступов</h3>
      <p>Если внутри родительского блока расположить блок и задать ему отступ сверху, то внутренний блок прижмётся к верхнему краю родительского, а у родительского элемента появится отступ сверху. То есть верхний отступ внутреннего элемента «выпадает» из родительского элемента.</p>
      <p>Если у родительского элемента тоже был задан внешний отступ, то выберется максимальный отступ между собственным и «выпавшим».</p>
      <p>Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу внутренний отступ (паддинг) сверху или добавить рамку сверху.</p>
      <p>Внешние и внутренние отступы всегда складываются.</p>

      <h2>Ширина 100% и ширина по умолчанию</h2>
      <p>CSS-свойство width задаёт не общую ширину блока, а только ширину содержания.</p>
      <p>Вариант по умолчанию, когда ширина не задаётся, соответствует значению width: auto;. В этом случае блок занимает всю ширину родительского блока. Если у блока есть внутренние отступы или рамки, то его ширина содержания автоматически уменьшается, а общая ширина остаётся равной ширине родителя.</p>
      <p>Когда ширина блока задана явно, например, width: 100%;. В этом случае ширина содержания блока равна ширине родительского блока. Если блоку добавить внутренние отступы и рамки, то его общая ширина становится больше ширины родителя.</p>
      <p>Помимо CSS ширина полей ввода может быть задана в значении атрибута size. Ширина width: auto для полей ввода рассчитывается из значения size по умолчанию и не растягивает поля на всю ширину контейнера.</p>
      <p>Представьте, что у нас есть форма, в которой поля должны занимать всю ширину контейнера, но при этом иметь фиксированные внутренние отступы, чтобы текст не прилипал к краям. Форма может быть разной ширины. Для полей такой формы можно задать такие стили:</p>
      <pre>{`input[type="text"] {
  width: 100%;
  padding: 0 10px;
}`}
      </pre>
      <p>Ширина 100% заставит поля быть такой же ширины, как родительский блок, а паддинг добавит отступы. Но за счёт отступов поле станет шире своего контейнера. И эта особенность создаёт проблему.</p>

      <h2>Изменяем блочную модель, свойство <span className="hl-7"><span className="hl-7">box-sizing</span></span></h2>
      <p>Свойство <span className="hl-7">box-sizing</span> в CSS управляет обработкой блочной модели для элемента, к которому она применяется.</p>
      <p>Проблему с шириной тянущихся полей решить сложно. Идеальным вариантом было бы изменение алгоритма расчёта ширины элемента, чтобы свойство width задавало не ширину содержания, а общую ширину.</p>
      <p>Реализуется это с помощью свойства <span className="hl-7">box-sizing</span>, values:</p>
      <ul>
        <li><b>content-box:</b>по умолчанию. Значения ширины и высоты применяются только к содержимому элемента. Отступ и граница добавляются за пределы поля.</li>
        <li><b>padding-box:</b>Значения ширины и высоты применяются к содержимому элемента и его отступу. Граница добавляется за пределами поля. В настоящее время только Firefox поддерживает значение padding-box.</li>
        <li><b>border-box:</b>Значения ширины и высоты применяются к содержимому, отступу и границе. Изменяет режим расчёта ширины элемента на описанный выше: теперь ширина элемента включает и рамку, и внутренние отступы и, собственно, ширину содержания самого элемента.</li>
        <li><b>inherit:</b>наследует свойство от родительского элемента.</li>
      </ul>
      <p>Один из наиболее распространенных способов его использования - применить его ко всем элементам на странице, включая псевдоэлементы:</p>
      <pre>{`*, *::before, *::after {
  box-sizing: border-box;
}`}
      </pre>
      <p>Это называется «универсальным размером коробки», и этот способ отлично работает. Это ширина, которую вы устанавливаете, - это ширина, которую вы получаете, без необходимости выполнять в уме математические вычисления и управлять сложностью, которая возникает из-за ширины, полученной из нескольких свойств.</p>
      <p><a className="text-link" href="https://habr.com/ru/post/149441/" target="blank">Полезная статья про <span className="hl-7">box-sizing</span>.</a></p>

      <h2>Управление типом бокса, свойство display</h2>
      <p><a href="https://webref.ru/css/display" className="text-link" target="blank">Все свойства display</a></p>
      <p>Значение none свойства display используется очень часто. С его помощью можно скрыть элемент, как будто его и не было. Скрытый элемент не отображается и не занимает места на странице.</p>
      <p>Есть ещё одно CSS-свойство, которое используется для сокрытия элементов. Это свойство visibility со значением hidden. Оно «прячет» элемент — он становится невидимым, но занимает место на странице.</p>

      <h3>float</h3>
      <p>Изначально float было предназначено для того, чтобы включать обтекание элементов текстом. Наподобие того, как в более старой версии HTML текст обтекал изображения c атрибутами align=&quot;left&quot; или align=&quot;right&quot;.</p>
      <p>Свойство float имеет следующие значения:</p>
      <ul>
        <li>left — прижимает элемент к левому краю родителя, другие элементы обтекают его справа;</li>
        <li>right — прижимает элемент к правому краю родителя, другие элементы обтекают его слева;</li>
        <li>none — отключает режим обтекания и возвращает элементу нормальное поведение.</li>
      </ul>
      <p>Обратите внимание, что зафлоатить элемент по центру нельзя.</p>

      <h4>float и ширина</h4>
      <p>Если мы задаём элементу свойство float:left или float:right, то он прижимается к левому или правому краю, а также начинает ужиматься по ширине под своё содержимое. С той стороны, которая не прижата к краю родителя, появляется свободное место. Это место может быть занято другими элементами.</p>
      <p>Зафлоаченному элементу можно явно задавать размеры и отступы.</p>
      <p>Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.</p>
      <p>Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.</p>
      <p>Идущие друг за другом флоаты выстраиваются в ряд, пока им хватает свободного места. Если места не хватает, то они начинают переноситься на следующую строчку. Почти как текст.</p>

      <h4>Когда флоатов много, а места мало</h4>
      <p>Когда не влезающий флоат переносится на новую строку, возможно несколько вариантов и не все из них логичны. Например, флоат может «зацепиться» за один из предшествующих флоатов и встать ниже не в самом начале строки, а за предшествующим.</p>

      <h3>Свойство clear</h3>
      <p>Свойство clear запрещает обтекание элемента другими элементами. Вот его значения:</p>
      <ul>
        <li>left — запрещено обтекание слева;</li>
        <li>right — запрещено обтекание справа;</li>
        <li>both — запрещено обтекание с обеих сторон;</li>
        <li>none — обтекание разрешено.</li>
      </ul>
      <p>Если после флоатного элемента расположен элемент с запрещённым обтеканием, то последний опускается под флоатный.</p>

      <h3>Борьба с выпаданием флоатов: распорки</h3>
      <p>Эффект выпадания флоатов из родителя был большой проблемой при построении сеток. Ведь сетки на флоатах обычно делаются вот так:</p>
      <ol>
        <li>Создаём блок-контейнер для колонок.</li>
        <li>В контейнер добавляем флоатные блоки-колонки.</li>
        <li>Рассчитываем ширины колонок так, чтобы им хватало места в родителе.</li>
      </ol>
      <p>Такой подход работает неплохо. Но проблемы начинаются тогда, когда у контейнера есть фон, отличный от фона страницы. Когда колонки выпадали, родитель схлопывался и фон пропадал.</p>
      <p>Необходимо было найти способ борьбы с выпаданием. Тут и пригодилось свойство clear:both.</p>
      <p>То есть начали добавлять после зафлоаченных колонок пустой элемент-распорку со свойством clear:both. Этот элемент видел колонки, не давал им пройти через себя, а заодно и растягивал родительский блок по высоте.</p>
      <p>Для таких распорок прижилось специальное название класса — clearfix.</p>

      <h3>Борьба с выпаданием флоатов: псевдораспорки</h3>
      <p>Благодаря псевдоэлементам появилось решение проблемы флоатов без использования дополнительного элемента.</p>
      <p>Есть несколько его вариаций, но вот одна из распространённых. В CSS добавляется следующее правило:</p>
      <pre>{`.clearfix::after {
  content: "";
  display: table;
  clear: both;
}`}
      </pre>
      <p>А затем класс clearfix добавляется к контейнеру, внутри которого лежат флоатные колонки. После этого в контейнер не нужно добавлять дополнительный элемент-распорку, так как распорка создаётся с помощью псевдоэлемента.</p>

      <h2>Когда flex, а когда grid?</h2>
      <p>CSS Flex Layout ориентирован на одну ось, то есть флексами удобно делать или колонки, или ряды элементов. При этом флексбокс позволяет управлять шириной каждой колонки и отступами между ними. Но одновременно двумя направлениями во флексбоксе управлять сложно.</p>
      <img src="img/flex/grid-20.png" alt="Пример CSS Flex Layout" width="800" />
      <p>CSS Grid Layout оптимизирован для двухмерных макетов: тех, в которых нужно управлять выравниванием содержимого в обоих измерениях.</p>
      <img src="img/flex/grid-21.png" alt="Пример CSS Grid Layout" width="800" />
    </section>
  );
}
export default FlowGridsLayout;
