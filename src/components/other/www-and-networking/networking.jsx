import React from 'react';

function Networking() {

  return (
    <section className="conspect">
      <h1>Работа с сетью</h1>
      <h2>Типы HTTP-запросов</h2>
      <p>Первое слово в первой строке любого HTTP-запроса — это его тип (ещё его называют «методом»). Вот он, GET, в начале:</p>
      <pre>{'GET /index.html HTTP/1.1'}</pre>

      <h3>HTTP-методы для чтения</h3>
      <ul>
        <li>
          <h4>GET</h4>
          <p>Запрос на получение информации с сервера. Это может быть HTML-разметка, CSS-файл, изображение, видео, аудио, JSON-данные или другие ресурсы.</p>
        </li>
        <li>
          <h4>HEAD</h4>
          <p>Запрос для проверки, обновилась ли информация на сервере, и стоит ли заново её скачать, или можно взять версию из кэша.</p>
          <p className="hl-8">Кэширование — подход, заключающийся в сохранении копии полученного ресурса, чтобы вернуть её по запросу, не загружая повторно с сервера. <a className="hl-8" href="https://developer.mozilla.org/ru/docs/Web/HTTP/Caching" target="_blank" rel="noopener noreferrer">Подробнее на MDN</a></p>
          <h5>Зачем нужен такой запрос?</h5>
          <p>Представьте, что вам нужно загрузить видео весом в несколько гигабайт. В первый раз его всё равно придётся загрузить, и браузер сам после загрузки отправит видео в кэш (браузер умный, он экономит ресурсы).</p>
          <p>Но надо ли загружать видео ещё раз? Как понять, что оно не изменилось? Для этого и нужен запрос HEAD.</p>
          <p>В случае запроса HEAD сервер вернёт нам в ответ только заголовки, где содержится подробная информация о ресурсе. По заголовкам можно понять, что видео не изменилось, а значит браузер может отдать его пользователю при повторных запросах из кэша, что будет в разы быстрее, чем снова грузить несколько гигабайт.</p>
        </li>
        <li>
          <h4>OPTIONS</h4>
          <p>Запрос для проверки, какие запросы можно делать к ресурсу.</p>
          <p>У сервера бывает очень много ресурсов, то есть адресов, к которым можно делать запросы. OPTIONS-запрос существует как раз для того, чтобы получить список методов, с помощью которых вы можете запрашивать информацию по данному адресу.</p>
          <p>Например, изображение пользователя на сервере поддерживает только запросы GET и HEAD, потому что картинка «доступна только для чтения». А имя пользователя на сервере кроме GET и HEAD может поддерживать ещё POST и PUT, чтобы была возможность установить или изменить имя.</p>
        </li>
      </ul>
      <h3>HTTP-методы для записи</h3>
      <ul>
        <li>
          <h4>POST</h4>
          <p>Запрос на создание новой записи на сервере. Один из немногих запросов к серверу, который обязательно должен содержать тело.</p>
          <p>Представим, что вы заполнили форму нового комментария. Как отправить этот комментарий на сервер? Сделать запрос POST!</p>
        </li>
        <li>
          <h4>PUT</h4>
          <p>Запрос на перезапись существующей информации на сервере.</p>
          <p>Представим, что вы хотите изменить свой комментарий. Полностью. Для этого нужно сделать запрос PUT с новым комментарием (новой информацией). Он полностью заменит предыдущий комментарий на сервере.</p>
        </li>
        <li>
          <h4>PATCH</h4>
          <p>Запрос на частичную перезапись существующей информации на сервере.</p>
          <p>Представим, что вы опечатались в имени комментатора из прошлого примера. Как изменить только имя, а не гонять туда-сюда большой текст комментария? Представьте, что он ещё и с картинками.</p>
        </li>
        <li>
          <h4>DELETE</h4>
          <p>Запрос на удаление существующей информации на сервере.</p>
        </li>
      </ul>
      <h2>Принципы взаимодействия</h2>
      <p>Программисты в прошлом создали наборы правил по взаимодействию клиента и сервера. Таких наборов правил много, рассмотрим только один из самых популярных, который называется REST.</p>

      <h3><abbr data-title="Representational State Transfer, дословно «передача состояния представления»">REST</abbr></h3>
      <p>Любая работа с данными рано или поздно приводится к системе CRUD: Create, Read, Update, Delete — набору методов для создания, чтения, обновления и удаления информации. Если переложить CRUD на HTTP, то получим методы POST, GET, PUT/PATCH, DELETE соответственно.</p>
      <p>Давайте обратимся к примеру из прошлых статей и рассмотрим, как по REST может быть организована работа с комментариями:</p>
      <pre>{`# Для создания комментария нужно отправить POST-запрос с телом на /comments
POST    /comments

# Для получения комментария нужно отправить GET-запрос на /comments/:id:
GET     /comments/1

# Для обновления комментария нужно отправить
# PUT-запрос с обновленным ресурсом на /comments/:id:
# PATCH-запрос с обновлением на /comments/:id:
PUT     /comments/1
PATCH   /comments/1

# Для удаления комментария нужно отправить DELETE-запрос на /comments/:id:
DELETE  /comments/1`}
      </pre>

      <h4>Адреса — бизнес-логика</h4>
      <p>Поэтому от сайта к сайту адреса по REST могут и будут отличаться. REST не гарантирует, что на каждом сайте комментарии можно получить по адресу /comments/:id:, REST гарантирует, что получить комментарий можно с помощью GET, обновить с помощью PATCH, а удалить с помощью DELETE по одному адресу, например, /comments/:id:.</p>

      <h4>Где взять список доступных адресов?</h4>
      <p>Представим, что и сервер, и клиент готовы работать по REST. Возникает вопрос, а как вам, как фронтендеру, добыть список адресов и поддерживаемых методов? Есть несколько вариантов.</p>
      <ol>
        <li>Спросить у разработчика сервера</li>
        <li>
          <h5>Написать самому (тонкий бэкенд)</h5>
          <p>Тонкий бэкенд — это такая прослойка, обычно на Node.js, между клиентом и сервером. Задача такой прослойки — обрабатывать запросы от клиента и перенаправлять их дальше. Вся логика по работе с базами данных и прочими хранилищами остаётся на сервере.</p>
          <p>В таком случае вы сами придумываете и описываете адреса, поддержку HTTP-методов и логику перенаправления запроса к серверу.</p>
        </li>
        <li>
          <h5>Прочитать документацию к API</h5>
          <p>Этот подход не отменяет двух предыдущих, а вбирает в себя их. Вместо того, чтобы отвечать на вопросы, разработчик сервера документирует все доступные ресурсы на сервере.</p>
          <p>Application programming interface (API) — описание способов, которыми клиент может взаимодействовать с сервером в нашем случае. <a href="https://ru.wikipedia.org/wiki/API" target="_blank" rel="noopener noreferrer">Подробнее на Википедии.</a></p>
        </li>
      </ol>
    </section>
  );
}
export default Networking;
