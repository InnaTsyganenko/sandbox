import React from 'react';

function DevtoolsChrome() {

  return (
    <section className="conspect">
      <h1>Работа с DevTools</h1>
      <h2>Вкладки</h2>
      <h5 className="note"><a href="https://habr.com/ru/post/254007/" target="_blank" rel="noopener noreferrer">15 советов и хитростей инструментов разработчика Chrome, которые вы обязаны знать</a></h5>
      <ul>
        <li>Elements — используется для просмотра и редактирования DOM-дерева и стилей страницы.</li>
        <li>Console — необходима для логирования диагностической информации и ошибок в процессе разработки или взаимодействия с JavaScript. Справа в верхнем углу DevTools выведутся иконки-предупреждения, которые откроют окно консоли.</li>
        <li>Sources — показывает ресурсы, подключённые на странице. Чаще всего эта вкладка используется при отладке кода. Чтобы посмотреть файл в более привычном виде, нажмите на иконку с фигурными скобками внизу окна.</li>
        <li>Network — мониторит процесс загрузки страницы, файлов и сетевых запросов. При первом открытии вкладка может оказаться пустой — тогда просто перезагрузите страницу. После перезагрузки внизу появится таблица всех ресурсов, подключенных к странице, и данные о них. Здесь можно узнать тип запроса, который был отправлен для получения ресурса, статус ответа, размер ресурса и многое другое. Обычно вкладку Network используют, чтобы узнать состояние ресурса, который не отображается на странице, но был к ней подключен. Смотрим в таблицу — если есть какая-то ошибка, ресурс будет гореть красным. Если ошибок нет, то статус каждого запроса — 200. Это значит, что всё хорошо. Если нажать кнопку фильтра, появится возможность посмотреть, как загружаются определенные ресурсы — например, картинки или шрифты. В левом нижнем углу — информация о количестве запросов, трафике и времени загрузки. Ещё мы можем выбрать скорость соединения и проверить, как сайт работает на мобильном где-нибудь за городом.</li>
        <li>Lighthouse — инструмент аудита, показывающий насколько веб-сайт соответствует стандартам Google, предлагает способы исправления проблем производительности и доступности. Инструмент доступен в Google Chrome, также Lighthouse можно установить отдельно в Firefox.</li>
        <li>Device Toolbar — используется для оценки того, как страница выглядит и работает на мобильном устройстве.</li>
      </ul>
      <p>Дополнительные вкладки скрыты под тремя точками → More tools.</p>


      <h2>Как сообщения попадают в консоль</h2>
      <p>Основное назначение консоли браузера в том, чтобы выводить сообщения в ходе работы программы. Сообщения в консоли помогают убедиться, что код программы работает, как задумано.</p>
      <p>Для вывода сообщений предусмотрен объект console, он не является частью JavaScript и существует только внутри браузера. До 2011 года функционал работы с консолью был не везде, но сейчас его поддерживает каждый современный браузер.</p>
      <p>Для вывода сообщения в консоль используется метод log объекта console. Значение, переданное при вызове метода console.log, печатается (логируется) в консоли браузера с указанием места, где метод console.log был вызван.</p>
      <p>При вызове метода console.log внутри самой консоли мы наблюдаем undefined в строке со стрелочкой «влево» — так в консоли помечается возвращаемое значение.</p>
      <p>Дело в том, что метод console.log не возвращает явного значения, а потому возвращается undefined. Однако при вызове console.log из кода программы, undefined в консоль выводиться не будет, так как вызов функции происходит за пределами консоли браузера. Метод console.log принимает неограниченное количество аргументов. Аргументы будут выводиться в консоль по порядку и разделяться пробелом.</p>
      <p>Второй самый используемый метод объекта console — console.error, он используется для вывода ошибок в консоль браузера. Результат его работы аналогичен console.log, разница лишь в том, что сообщение логируется красным текстом и имеет выпадающую справку, в которой показаны все файлы и функции, которые затрагивает ошибка, это называется Stack trace. Подробнее, что такое Stack trace, можно почитать на MDN. Также вызов console.error повышает на единицу счётчик ошибок в правом верхнем углу инструментов разработчика.</p>
      <p>Помимо логирования сообщений и ошибок в console предусмотрено множество других методов. Они помогают в разработке и отладке программы, вот описание некоторых из них:</p>
      <ul>
        <li>сonsole.table — выводит сложные данные в виде таблицы;</li>
        <li>console.group — группирует сообщения, попавшие в консоль;</li>
        <li>console.assert — сравнивает значения между собой;</li>
        <li>console.time и console.timeEnd — замеряют быстродействия участков кода;</li>
        <li>console.warn — выводит в консоль самописное предупреждение.</li>
      </ul>
      <p>Для очистки всех сообщений в консоли браузера используется метод console.clear.</p>
      <p>Также для очистки консоли можно нажать на соответствующую кнопку в левой верхней части консоли или использовать комбинацию клавиш: ctrl+L на Windows и Linux или cmd+K на MacOS.</p>
      <p>При вводе значения в консоли браузера можно опустить вызов console.log(), так как сам факт ввода уже является логированием и приведёт к аналогичному результату.</p>
      <p>Помимо логирования в консоли можно выполнять код. Это бывает очень удобно, когда нужно быстро проверить какую-то гипотезу или выполнить небольшой кусочек кода.</p>
      <ul>
        <li>Как быстро получить ответ на вопрос: «К какому типу данных относится null?». Для этого достаточно открыть консоль и ввести всего одну строку typeof null.</li>
        <li>Или как быстро решить небольшую задачу: найти гипотенузу прямоугольного треугольника. Снова всего одна строка в консоли — и ответ готов: Math.hypot()</li>
        <li>С помощью консоли можно даже сделать запрос к серверу! Полученные данные в формате JSON можно сразу преобразовать в объект (fetch и Promise из примера рассмотрены в другой главе):</li>
      </ul>

      <h3>Почему опасно выполнять незнакомый код в консоли</h3>
      <p>Современный разработчик постоянно использует код, написанный кем-то другим. Мы настолько привыкли к этому, что порой забываем, какую это может нести опасность. Давайте разберёмся, чем может грозить выполнение незнакомого кода в консоли браузера.</p>

      <h4>Похищение данных</h4>
      <p>Предположим, что некий злоумышленник методами социальной инженерии заставил жертву выполнить у себя в браузере вредоносный код. В чём может заключаться его вредоносность? Самый очевидный сценарий — кража данных. Код извлекает из браузера жертвы некую информацию, которая не должна быть общедоступной, затем отправляет её злоумышленнику. Что это может быть за информация?</p>

      <h5>Cookie (куки)</h5>
      <p>Похищаемыми данными могут быть cookie. Cookie — это технология, позволяющая сайту хранить информацию в браузере пользователя так, чтобы она оставалась даже после закрытия вкладки. Эта технология часто используется для аутентификации пользователя, такие cookie называются сессионными.</p>
      <p>Вы можете получить доступ к cookie в консоли, написав document.cookie. Раз можете вы — значит, может и злоумышленник. Получив сессионные куки, злоумышленник может войти в ваш аккаунт на сайте, на странице которого вы выполнили вредоносный код. По крайней мере, теоретически может.</p>
      <p>На самом деле, существует большое количество механизмов защиты от такой атаки. Например, http-only cookie, к которым невозможно получить доступ через клиентский JavaScript. Также существуют другие способы защиты, которые могут использовать разработчики сайта — однако не стоит слепо на это надеяться и выполнять в консоли потенциально вредоносный код.</p>

      <h5>Хранилища данных</h5>
      <p>В современных браузерах существует множество механизмов для хранения данных на стороне клиента — LocalStorage, SessionStorage, IndexedDB. Какие данные находятся в этих хранилищах — зависит от конкретного сайта и архитектурных решений его разработчиков. Как и в cookie, в них может находиться информация, связанная с аутентификацией пользователя — например, JSON Web Token. Или же там может храниться другая приватная информация, представляющая интерес для злоумышленника.</p>

      <h5>Значения глобальных переменных</h5>
      <p>Хороший JS-код, как правило, не использует глобальные переменные. Однако, к сожалению, не все разработчики сайтов пишут хороший код. Может оказаться, что чувствительная информация находится в глобальной области видимости — скажем, в переменной window.superSecretPassword, к которой без труда можно получить доступ из консоли.</p>

      <h5>Информация на странице</h5>
      <p>Имея доступ к DOM-дереву, можно «вытащить» из него текст любого элемента, URL изображения или ссылки — в общем, всё, что видит пользователь, и даже немного больше. В зависимости от того, на какой именно странице выполняется вредоносный скрипт, что-то из этих данных может представлять ценность для злоумышленника. Например, в личном кабинете какого-нибудь банка может отображаться номер банковской карты, а может даже и защитный код. Обычно такая информация отображается только по специальному запросу — как раз для того, чтобы защититься от этой и других подобных атак. Однако даже в том, что злоумышленник получит список последних ваших диалогов в соцсети, нет ничего хорошего.</p>

      <h5>Подделка запросов</h5>
      <p>Вредоносный код может не ограничиться простым похищением данных. Вместо этого он может произвести от вашего имени какие-то действия на странице — например, отправку формы или AJAX-запроса. Выполнив несколько строк непонятного кода во вкладке с соцсетью, можно внезапно обнаружить, что от вашего имени отправлены спам-сообщения всему списку контактов. И это ещё не самый неприятный сценарий.</p>
      <p>Впрочем, существуют техники защиты и от такого типа атак. Отправку AJAX-запросов из консоли можно запретить с помощью CORS. Также браузер умеет отличать события, вызванные пользовательским вводом, от событий, инициированных программно. Однако, как и в предыдущих случаях, не стоит полагаться на то, что на конкретном сайте все эти методы защиты действительно используются.</p>
      <p>Выполнять какой-либо код следует лишь тогда, когда истинно хотя бы одно из трёх условий. Либо вы понимаете, что этот код делает, либо у вас есть причины ему доверять, либо вы выполняете его в таком окружении, где он в принципе не может причинить вред. Код, исполняемый в консоли браузера, способен причинить вред. Поэтому убедитесь, что истинно хотя бы одно из первых двух условий. Если этот код не исходит из авторитетного источника (например, статьи HTML Academy), и если вы не понимаете досконально, как этот код будет работать — не выполняйте его.</p>

      <h3>Обзор вкладки Elements</h3>
      <p>Кнопка inspect позволяет выбрать элемент на странице с помощью мыши. Или правый клик по элементу → Просмотреть код (Inspect).</p>
      <p>Кнопка переключения Device Toolbar используется для оценки того, как страница выглядит и работает на мобильном устройстве. Об этой возможности поговорим отдельно.</p>

      <h4>Секция с вкладками в правой боковой панели DevTools</h4>
      <p>Styles — выводит и позволяет редактировать стили элемента, включая наследуемые от родительских элементов, показывает блочную модель элемента.</p>
      <p>Computed — на этой вкладке перечислены только стили, которые отображаются на экране. Все относительные единицы будут пересчитаны в пиксели.</p>
      <p>Layout — предоставляет наглядное отображение всех CSS grid сеток на странице. Подробнее в документации по Chrome DevTools.</p>
      <p>Event Listeners — выводит обработчики событий элемента.</p>
      <p>DOM Breakpoints — используется для остановки кода, который изменяет выбранный элемент или его детей. Подробнее в документации по Chrome DevTools.</p>
      <p>Properties — выводит все доступные свойства элемента.</p>
      <p>Accessibility — позволяет проверять каждый элемент по метрикам доступности. Подробнее в документации по Chrome DevTools.</p>

      <h5>Элементы управления</h5>
      <p>Кнопка Refresh. Нужна для обновления списка обработчиков событий. Список не обновляется автоматически после добавления нового обработчика, обновлять нужно вручную.</p>
      <p>Чекбокс Ancestors. Когда флажок снят, отображаются только обработчики для текущего выбранного узла. Когда флажок Ancestors включён, вместе с обработчиком текущего выбранного узла отображаются обработчики событий родителей этого узла.</p>
      <p>Фильтры.</p>
      <ul>
        <li>Passive — показывать только обработчики событий, которым передана опция &cub;passive: truer&cub;.</li>
        <li>Blocking — показывать все обработчики, кроме пассивных.</li>
        <li>All — показывать все обработчики.</li>
      </ul>
      <p>Чекбокс Framework listeners. Некоторые фреймворки и библиотеки JavaScript оборачивают события DOM в свои пользовательские API событий. В прошлом это затрудняло проверку обработчиков событий с помощью DevTools, потому что определение функции ссылалось на код фреймворка или библиотеки, а не на место использования. Опция Framework listeners решает эту проблему.</p>
      <p>Когда флажок Framework listeners включён, DevTools не ссылается на фреймворк, а показывает, где вы добавили обработчик в своём коде.</p>

      <h3>Обзор панелей вкладки Sources</h3>
      <p>Вкладка Sources содержит данные о различных файлах исходного кода проекта, которые браузер получает с сервера.</p>
      <p>Она состоит из трёх основных блоков:</p>
      <ul>
        <li>View. Первая вкладка, Page, служит для просмотра файлов, которые загружаются на страницу. Основные данные содержатся в top, это главный фрейм, он есть на любой странице, и в нём отображаются все основные ресурсы: скрипты, стили, шрифты и тому подобное.</li>
        <li>Editor. Если выбрать файл на вкладке Page, он откроется в основном блоке редактирования. Это основной просмотрщик ресурсов страницы, он обладает всем базовым функционалом IDE: через него можно редактировать стили и скрипты, просматривать картинки. Изменения стилей немедленно отобразятся, а для работы скриптов нужно нажать Command+S (Mac) или Ctrl+S (Windows, Linux). Чтобы скрипт отработал, изменения должны быть в вызываемой функции. Будьте осторожны, при перезагрузке страницы эти изменения пропадут. Чаще всего с сервера браузер получает минифицированный код, сложный для восприятия человеком. На этот случай предусмотрена кнопка Pretty print {}, которая разворачивает сжатый код в читаемый.</li>
        <li>Debug. Здесь содержится функционал для работы со скриптами и процессом загрузки страницы. Watch помогает отслеживать значение переменных в файле скриптов. Чтобы добавить переменную к просмотру, нажмите иконку плюса в правом углу, в появившемся поле напишите имя переменной, нажмите Enter. Брейкпоинты (точки останова) останавливают выполнение функции в определенный момент. Остановить выполнение кода можно на конкретной строке (нажать строку во вкладке редактирования файла или добавить в коде ключевое слово debugger), на слушателе события (Event Listener) или при выполнении запроса (XHR breakpoint). Call Stack - как известно, JavaScript — однопоточный язык, стек вызова в нём один, и функции в нём исполняются по цепочке, одна за одной. В этой вкладке можно отследить последовательность вызовов функций на момент остановки скрипта, переключаться между ними по стеку. При переключении показывается строка кода, где вызвана текущая функция и её положение в цепочке вызовов. По умолчанию, если не пользоваться точками останова, Call Stack будет пуст.</li>
      </ul>

      <h3>Точки останова</h3>
      <p>Точки останова (breakpoints) — самый простой и удобный инструмент отладки кода, предоставляемый браузером. Используя его, можно заставить интерпретатор JavaScript остановить выполнение на определённой строке кода, а затем выполнять код в пошаговом режиме, отслеживая значения интересующих разработчика переменных.</p>
      <p>Чтобы начать работу с точками останова, перейдите во вкладку Sources и в левой колонке выберите файл, где находится интересующий вас скрипт.</p>
      <p>Чтобы создать точку останова, достаточно просто кликнуть по номеру строки, на которой вы хотите остановить выполнение JavaScript.</p>
      <p>Чтобы временно отключить точку останова, нужно найти её в правой панели отладчика, в списке Breakpoints, и убрать напротив неё галочку. Чтобы вновь активировать точку останова, достаточно снова поставить галочку.</p>
      <p>Чтобы удалить точку останова, кликните на выделенный номер строки. Выделение будет снято, а точка останова удалена из списка Breakpoints. Также точку останова можно удалить прямо в списке Breakpoints, открыв контекстное меню правой кнопкой мыши и выбрав пункт «Remove breakpoint».</p>

      <h4>Пошаговое выполнение кода</h4>
      <p>После того, как сработает точка останова, браузер переходит в режим отладки. С этого момента выполнение JS-кода на странице происходит только по команде пользователя. Пользователь может дать эту команду с помощью кнопок в верхней части панели отладки.</p>
      <p>Перечислим их слева направо:</p>
      <ol>
        <li>«Продолжить выполнение скрипта» (Resume script execution) — завершает режим отладки. Далее код исполняется в обычном режиме до следующей точки останова.</li>
        <li>«Шагнуть через» (Step over) — выполняет текущую строку кода. Если на ней вызов функции, выполняет эту функцию целиком и переходит к следующей после неё строке.</li>
        <li>«Шагнуть в» (Step into) — выполняет текущую строку кода. Если на ней вызов функции, переходит к первой строке этой функции.</li>
        <li>«Шагнуть из» (Step out) — до конца выполняет текущую функцию, переходит к строке, следующей за её вызовом.</li>
        <li>«Шагнуть» (Step) — работает так же, как «Шагнуть через», существует по историческим причинам. Такое название более привычно для разработчиков, ранее работавших с некоторыми другими языками программирования и средами отладки</li>
      </ol>
      <p>Остановимся подробнее на кнопках «Шагнуть через» и «Шагнуть в». Они делают примерно одно и то же — выполняют текущую строку и переходят к следующей. Разница лишь в том, как они понимают слово «следующая» в случае, если происходит вызов функции. «Шагнуть через» применяется в случае, если нас не интересует внутренняя работа функции, и мы хотим поскорее перейти к следующей за ней строке. «Шагнуть в», напротив, используется тогда, когда внутренняя работа функции нам очень интересна, и мы также хотим её отладить построчно.</p>

      <h3>Обзор вкладки Network</h3>
      <p>С помощью вкладки Network можно выяснить, сколько времени заняла загрузка страницы, какие ресурсы подключились или не подключились к странице и многое другое. При первом открытии вкладка может оказаться пустой, потому что при закрытых инструментах веб-разработчика запись не ведётся, в этом случае просто перезагрузите страницу.</p>
      <p>После перезагрузки внизу появится таблица всех ресурсов, подключенных к странице, и данные о них:</p>
      <ul>
        <li>Name — имя ресурса;</li>
        <li>Status — статус ответа сервера (200, 404, 500 и другие);</li>
        <li>Type — тип ресурса (script, stylesheet, font и другие);</li>
        <li>Initiator — действие или скрипт, которые инициировали загрузку ресурса; при клике на название скрипта скрипт откроется во вкладке Sources;</li>
        <li>Size — размер ресурса; браузер может кэшировать ресурсы, в таких случаях в этом столбце может быть значение memory cache (временный кэш, хранится до закрытия браузера) или disk cache (постоянный кэш, хранится, пока пользователь не очистит его);</li>
        <li>Time — время загрузки ресурса в миллисекундах;</li>
        <li>Waterfall — графическое представление времени загрузки с разделением на этапы; при наведении курсора на полосу появляется окно с подробной информацией.</li>
      </ul>
      <p>Кликнув по таблице правой кнопкой мыши, можно увидеть все доступные столбцы таблицы и выбрать нужные.</p>
      <p>Обычно вкладку Network используют, чтобы узнать состояние ресурса, который не отображается на странице, но был к ней подключён. Смотрим в таблицу — если есть какая-то ошибка, ресурс будет выделен красным. Если ошибок нет, то статус каждого запроса — 200. Это значит, что ресурс загружен успешно.</p>
      <p>Отслеживание ошибок загрузки удобнее производить именно во вкладке Console, так как сообщения об ошибках в ней хорошо заметны, а таблица ресурсов во вкладке Network может быть очень длинной, что затруднит поиск. На вкладке Network есть возможность отфильтровать загруженные ресурсы по типу запроса.</p>
      <p>Чаще всего отлаживать приходится запросы к серверу. Нажав на имя запроса, можно увидеть подробности о его загрузке и содержимом:</p>
      <ul>
        <li>Headers — здесь хранится общая информация о запросе и ответе: URL запроса, метод запроса, код ответа, адрес сервера и так далее.</li>
        <li>Preview, Response — здесь можно увидеть данные, которые вернул сервер в ответ на запрос; разница в том, что во вкладке Preview данные представлены в обработанном виде, а в Response в исходном (например, для SVG файла во вкладке Response мы увидим разметку, а в Preview изображение);</li>
        <li>Initiator — здесь можно увидеть, какое действие пользователя или скрипт инициировали запрос;</li>
        <li>Timing — здесь хранится подробная информация о времени загрузки ресурса, разделенная на этапы;</li>
      </ul>
      <p>Мы можем выбрать скорость соединения и проверить, как сайт будет работать на мобильном устройстве где-нибудь за городом. Для этого необходимо выбрать один из профилей в выпадающем меню. </p>
      <p>Это может быть полезно для оптимизации загрузки ресурсов. При выборе профиля с низкой скоростью (например, Slow 3G), можно отследить, загрузка каких ресурсов занимает наибольшее время и в дальнейшем исправить ситуацию.</p>

      <h3>Проверка вёрстки на мобильных</h3>
      <p>Легко проверить, как выглядит вёрстка на мобильных. Заходим в режим эмуляции - Toggle device toolbar в левом углу или нажмите комбинацию Ctrl+Shift+M — можем поменять ширину экрана, выбрать конкретный девайс (например, айфон), просмотреть все media-выражения, примененные к странице, или выбрать плотность пикселей, чтобы проверить ретиновую графику. Это незаменимый инструмент в работе над адаптивной вёрсткой.</p>
      <p>На этой же панели есть еще одна полезная кнопка — DPR (Device Pixel Ratio). С её помощью проверяют, как выглядят изображения на ретина-дисплеях — экранах с повышенной плотностью. Чтобы посмотреть, как выглядит графика на разных устройствах, измените значение DPR и обновите страницу.</p>

      <h3>Скриншоты страниц</h3>
      <p>Заходим в режим эмуляции и в выпадающем меню выбираем «сделать скриншот» — изображение сразу сохраняется на компьютер. Также есть возможность сделать скриншот всей страницы целиком — для этого выберите пункт Capture full size screenshot.</p>
      <p><b>Elements</b> - просмотр элементов DOM, изменение стилей.</p>
      <p>В разделе Styles также можно проверять, задавать и исправлять стилевые правила для :hover, :active, :focus и других псевдоклассов. Чтобы это сделать, выберите элемент, которому задано интерактивное состояние. Затем в разделе Styles нажмите на кнопку : hov, выберите подходящий псевдокласс и управляйте его стилями.</p>

      <h3>Как использовать точки останова</h3>
      <p>Для начала откройте вкладку Sources и выберите файл со скриптом. Затем кликните по номеру строки, на которой вы хотите приостановить выполнение кода. Выбранные точки сразу появятся на панели справа в разделе Breakpoints.</p>
      <p>Также можно пойти другим путём: кликните на Event Listener Breakpoints и выберите события, на которых нужно приостановить выполнение кода.</p>
      <p>JavaScript выполняется последовательно. Когда Chrome дойдет до точек останова, он остановит выполнение скрипта, и вы сможете отследить, что происходит с кодом. Например, посмотреть значения переменных или разобраться с логикой функций. С этого момента только вы управляете кодом. Можете перейти к следующей точке, шагнуть внутрь функции или отключить точки останова. В этом вам помогут кнопки на панели справа. Для чего они нужны, пойдем по порядку:</p>
      <ul>
        <li><b>Resume Script Execution</b> — продолжает выполнение скрипта до следующей точки останова. Горячая клавиша F8.</li>
        <li><b>Step over next function call</b> — выполняет строку кода и переходит к следующей функции. Горячая клавиша F10.</li>
        <li><b>Step into next call function call</b> — выполняет строку кода и затем ныряет внутрь функции — на первую строку. Горячая клавиша F11.</li>
        <li><b>Step out of current function</b> — выполняет до конца текущую функцию и останавливается на её последней строке. Горячая клавиша Shift + F11.</li>
        <li><b>Step</b> — по принципу действия похожа на Step into of current function. Но если Step into нужен для того, чтобы попасть внутрь функции, то Step просто выполнит её и покажет результат. Горячая клавиша F9.</li>
        <li><b>Deactivate breakpoints</b> — отключает точки останова. Горячая клавиша Ctrl + F8.</li>
        <li><b>Pause on exceptions</b> — выполнение JavaScript приостанавливается, когда появляется какое-то исключение.</li>
      </ul>
      <p>Lighthouse оценивает классические сайты по четырём критериям: производительность, лучшие практики, SEO и доступность. Для сайтов, выполненных по технологии PWA (прогрессивные веб-приложения), добавляется пятый критерий — progressive web app.</p>
      <p><b></b></p>
      <p></p>
      <h2>Как посмотреть обработчики на элементе</h2>
      <p>Для просмотра текущих обработчиков событий на элементе нужно выбрать элемент во вкладке Elements и открыть секцию Event Listeners в боковой панели справа.</p>
      <p>У каждого обработчика указаны:</p>
      <p>Место и строка в коде, где он был добавлен.</p>
      <p>Опции обработчика событий, подробнее <a href="https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B" target="blank">об опциях на MDN</a>.</p>
      <p>Колбэк-функция обработчика.</p>
      <h3>Элементы управления</h3>
      <p>Кнопка Refresh. Нужна для обновления списка обработчиков событий. Список не обновляется автоматически после добавления нового обработчика, обновлять нужно вручную.</p>
      <p>Чекбокс Ancestors. Когда флажок снят, отображаются только обработчики для текущего выбранного узла. Когда флажок Ancestors включён, вместе с обработчиком текущего выбранного узла отображаются обработчики событий родителей этого узла.</p>
      <p>Фильтры.</p>
      <ul>
        <li>Passive — показывать только обработчики событий, которым передана опция <pre>{'{passive: true}'}</pre>.</li>
        <li>Blocking — показывать все обработчики, кроме пассивных.</li>
        <li>All — показывать все обработчики.</li>
      </ul>
      <p>Чекбокс Framework listeners. Некоторые фреймворки и библиотеки JavaScript оборачивают события DOM в свои пользовательские API событий. В прошлом это затрудняло проверку обработчиков событий с помощью DevTools, потому что определение функции ссылалось на код фреймворка или библиотеки, а не на место использования. Опция Framework listeners решает эту проблему.</p>

      <h2>Шаблоны и данные</h2>
      <p>Шаблон — некоторая оболочка для данных, разметка, любой способ отобразить информацию. Шаблон никогда не несёт содержательной информации.</p>
      <p>Данные — информация, которую вводит пользователь, присылает сервер или которая может быть сгенерирована компьютером.</p>
      <p>Данные не должны повторять шаблон, они должны описывать параметры сущностей, которыми мы оперируем. Простой способ отделить шаблон от данных — попробовать изменить одно или другое.</p>
      <p>Например, использовать иной способ отображения данных (отобразить товары в линейку вместо списка) или изменить отображаемую информацию (описать не утюг, а пылесос). Допустим у нас есть структура, описывающая логотип:</p>
      <pre>{`const header = {
logo: {
    src: 'logo.png',
    width: 100,
    height: 30
}
};`}
      </pre>
      <p>С первого взгляда можно подумать, что это данные, однако такую информацию неправильно хранить как данные. Эта информация описывает логотип, расположенный в шапке, она не приходит с сервера, не вводится пользователем, возможно, эта информация никогда не поменяется. Поэтому данная информация не является данными — это шаблон, который описывает, как некоторая сущность должна выглядеть. Данными могут быть: название компании, адрес, телефон и тому подобное.</p>

      <h3>Зачем отделять данные и шаблоны</h3>
      <p>Допустим, что у нас есть список некоторых продуктов интернет-магазина:</p>
      <pre>{`const products = [
{name: 'Утюг'},
{name: 'Чайник'},
{name: 'Пылесос'},
{name: 'Стиральная машина'},
{name: 'Кухонный комбайн'},
{name: 'Автомобиль'}
];`}
      </pre>
      <p>Дизайнер говорит нам, что в интерфейсе мы должны для некоторых пользователей показывать товары списком, а для других (кто хочет) сеткой. Неужели нам придётся заводить два одинаковых списка продуктов? Нет! Как раз список продуктов, приведённый выше, является данными, а способы показа товаров являются шаблоном.</p>
      <p>Данные не должны меняться в зависимости от того, каким образом они должны отображаться. Шаблон отвечает за то, куда вставить данные — в элемент списка или элемент сетки.</p>

      <h3>Создание DOM элементов</h3>
      <p>В условиях использования JavaScript DOM-элемент является шаблоном. DOM-элементы можно создать несколькими способами:</p>
      <ul>
        <li>На основе разметки — в специальные места разметки в тексте разметки подставляются данные;</li>
        <li>На основе строк;</li>
        <li>Компилируемые шаблоны — использование сторонних библиотек, способных переводить некоторый язык в разметку;</li>
        <li>На основе DOM-API:
          <ul>
            <li>На основе шаблонного элемента (template из WebComponents);</li>
            <li>С помощью обёрток над шаблонами (Incremental DOM).</li>
          </ul>
        </li>
      </ul>
      <p>Простой способ отделить шаблон от данных — попробовать заменить их: изменить способ отображения данных или отображаемую информацию.</p>
    </section>

  );
}
export default DevtoolsChrome;
