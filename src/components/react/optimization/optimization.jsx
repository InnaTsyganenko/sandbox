import React from 'react';

function Optimization() {

  return (
    <section className="conspect">
      <h1>Оптимизация производительности</h1>
      <h2>Мемоизация</h2>
      <p><span className="hl-1">Мемоизация</span> - (запоминание, от англ. memoization) — в программировании сохранение результатов выполнения функций для предотвращения повторных вычислений</p>
      <p>Но нам нужно сделать так, чтобы повторный вызов функции с тем же аргументом не вызывал функцию повторно, а сразу возвращал результат.</p>
      <p>Что должно быть в memo для корректной работы? Некое хранилище результатов. Используем для этого Map и замыкания.</p>
      <p>Далее нужно реализовать следующую логику:</p>
      <ul>
        <li>Если оригинальная функция уже вызывалась, вернуть сохранённый результат.</li>
        <li>Если не вызывалась, то вызвать, сохранить результат и вернуть его.</li>
      </ul>
      <p>Обратите внимание, вызываем мы memorizedIncrement дважды, результат получаем дважды, а индикация о вызове оригинальной функции increment — одна. Мемоизация в деле!</p>
      <p>И неважно, сколько раз будет вызвана мемоизованная функция, оригинальная — только один раз.</p>
      <pre>{`const increment = (value) => {
  console.log('Функция increment была вызвана');
  return value + 1;
};

const memo = (originalFn) => {
  const result = new Map();

  return (value) => {
    if (!result.has(value)) {
      result.set(
        value,
        originalFn(value)
      );
    }

    return result.get(value);
  };
};

memorizedIncrement = memo(increment);

console.log(
  memorizedIncrement(1) // > 2
);

console.log(
  memorizedIncrement(1) // > 2
);

console.log(
  memorizedIncrement(3) // > 4
);

console.log(
  memorizedIncrement(5) // > 6
);

console.log(
  memorizedIncrement(7) // > 8
);

console.log(
  memorizedIncrement(9) // > 10
);`}
      </pre>

      <h2>React.memo()</h2>
      <p>React.memo — это компонент высшего порядка (HOC). Он позволяет мемоизировать результат, тем самым избежать повторного рендеринга. Идея проста: если значения пропсов не изменились, то нет смысла рендерить компонент заново. Никакой магии.</p>
      <p>Вернёмся к проблеме. Компонент Counter обёрнут в React.memo(), но он продолжает перерисовываться при вводе символов в компонент About. Дело в том, что по умолчанию React.memo поверхностно сравнивает вложенные объекты в props. В Counter помимо примитивного значения в count передаются две функции — обработчики событий для кнопок. Вот и получается, что при поверхностном сравнении результаты всегда разные. Ну а раз пропсы меняются, то и компонент должен перерисоваться. Всё логично.</p>
      <p>К счастью, ничего не мешает взять сравнение в свои руки. React.memo() вторым параметром принимает функцию. В ней можно реализовать сравнение пропсов самостоятельно. Эта функция принимает два параметра: prevProps и nextProps (названия могут быть любыми).</p>
      <p>Функция сравнения должна вернуть булево значение: true в случае, когда nextProps равны prevProps (следовательно, нет смысла рендерить компонент заново), а false, когда значения изменились (следовательно, необходимо перерендерить компонент).</p>
      <p>Компонент Counter принимает три пропса: count, onIncButtonClick и onDecButtonClick. Два последних содержат функции, поэтому пока не станем добавлять их в условие сравнения. Раз функции и они в App создаются на каждом рендере, то ссылки будут разными. Остаётся учесть в сравнении значение пропса count. После добавления условия попробуйте ввести текст в About и посмотреть сообщение о перерисовке компонентов. Компонент Counter больше не перерисовывается.</p>
      <p>Мы избавились от лишних перерисовок компонента Counter, воспользовавшись методом React.memo(). На практике это оказалось несложно. Однако, может закрасться мысль: «А почему бы всегда (по умолчанию) не применять React.memo() для оптимизации функциональных компонентов?». Ответим сразу — это плохая идея. Во многих случаях это, попросту говоря, бессмысленная затея. А в отдельных может и вовсе привести к ухудшению производительности. Подведём итог, когда уместно применять React.memo(). К React.memo() следует прибегать, когда компонент часто перерисовывается, при этом значения пропсов не изменяются. Такая ситуация, как правило, возникает из-за перерисовки родительского компонента (как в нашем примере).</p>
      <p>Если компонент часто перерисовывается (и должен это делать) и при этом каждый раз получает новые значения для пропсов, применение React.memo() наоборот ухудшит производительность. React сделает бессмысленную проверку и обёртку для компонента. В итоге всё равно перерисует компонент.</p>
      <p>Последнее, что необходимо запомнить: думать о React.memo() следует только в контексте оптимизации производительности. React не будет повторно рендерить мемоизированный компонент в большинстве случаев, но есть исключения, когда React может нарушить это правило. Поэтому не стоит использовать данный способ для предотвращения рендеринга по причинам, отличным от оптимизации.</p>
      <p>Как ещё можно избавиться от повторного создания функций-обработчиков при каждой перерисовке родительского компонента?</p>
      <p>Один из вариантов решения — воспользоваться классовым компонентом и описать обработчик события в виде метода. Тогда ссылка на него сохранится и не будет меняться при перерисовке.</p>
    </section>
  );
}
export default Optimization;
