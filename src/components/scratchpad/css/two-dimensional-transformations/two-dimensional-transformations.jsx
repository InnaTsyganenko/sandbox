import React from 'react';

function TwoDimensionalTransfomations() {

  return (
    <section className="conspect">
      <h1>Двумерные трансформации</h1>
      <h2>Перемещение по горизонтали и вертикали</h2>
      <p>То, что раньше можно было сделать в окне браузера только с помощью JavaScript — плавное перемещение и масштабирование блоков, повороты и наклоны — теперь с лёгкостью реализуется на чистом CSS.</p>
      <p>Для начала давайте разберёмся с системой координат, в которой перемещается объект: её ключевой особенностью является то, что ось Y направлена вниз, а не вверх, так как веб-страница начинается с левого верхнего угла и идет вниз, а в CSS используется обратная система координат.</p>
      <img src="/img/coordinate-system.jpg" alt="Система координат в вебе" width="400" height="300" />
      <p>Для трансформаций используется следующий синтаксис:</p>
      <p><span className="hl-1">transform: функция трансформации(значение трансформации)</span></p>
      <p>Горизонтальное перемещение - translateX, вертикальное - translateY. Значение функции трансформации численное, а возможные единицы измерения — px, %, em или in.</p>
      <pre>{`
      transform: translateY(-100px) translateX(100px); /* перемещение вправо и вверх */`}
      </pre>
      <p>К объекту может быть одновременно применено несколько функций трансформации. При этом функции просто перечисляются через пробел после имени свойства transform, например:</p>

      <h2>Увеличение, уменьшение - scale</h2>
      <p>Значением этой функции может быть любое число. При этом значение 1 считается точкой отсчёта, когда блок имеет оригинальные размеры.</p>
      <p>Вообще функция scale, как и translate, принимает 2 аргумента:</p>
      <p><span className="hl-7">scale(масштаб-по-X [, масштаб-по-Y])</span></p>
      <pre>{`scale(0.5) уменьшит объект в 2 раза;
scale(2) увеличит объект в 2 раза;
scale(0) полностью «схлопнет» объект, и его не будет видно;
scale(1) оставит объект без изменений.`}
      </pre>
      <p>transform: scale(2) то же самое, что transform: scale(2, 2).</p>
      <p>Также в случае, когда необходимо масштабировать объект только по одной оси независимо от другой, существуют функции scaleX(масштаб-по-Х) и scaleY(масштаб-по-Y).</p>

      <h2>Схема работы функции rotate</h2>
      <p><span className="hl-8">transform: rotate(угол наклона)</span></p>
      <p>Положительное значение угла повернёт объект по часовой стрелке, а отрицательное — против. Единица измерения поворота — градусы deg.</p>
      <div className="warn">При совместном применении трансформации поворота и перемещения есть небольшая тонкость. При повороте вместе с объектом на заданный угол поворачивается и вся его система координат.</div>
      <p>Ещё одна возможность CSS-трансформаций — наклон объекта по осям X и Y под заданным углом. Наклоны создаются с помощью функций skewX и skewY, в градусах — deg.</p>
      <p>Для оси X положительное значение угла наклоняет объект влево, а отрицательное — вправо. Для оси Y — вниз и вверх соответственно.</p>
      <p><span className="hl-6">skew(наклон-по-Х [, наклон-по-Y]</span></p>
      <p>Значение наклона по оси Y является необязательным аргументом и по умолчанию равно 0. Но при этом поведение функции skew при трансформации отличается от одновременного применения skewX и skewY.</p>
      <div className="note">Исторически так сложилось, что реализация skew в браузерах поддерживается сейчас только для совместимости прежнего контента, и даже исключалась из рабочего черновика спецификации CSS. В общем, вместо skew лучше пользоваться skewX и skewY.</div>
      <div className="note">Есть особенность transform: scale. А именно то, как ведёт себя объект при задании отрицательных числовых значений: при scaleX(-1), например, оригинальный объект зеркально отражается по горизонтали, а при scale(-1, -1) — отражается и по оси X, и Y. Большее, чем -1 значение ещё шире растянет отзеркалированный объект.</div>

      <h2>Особенности transform-origin</h2>
      <p>Это свойство используется совместно со свойством transform и задаёт точку отсчёта системы координат, в рамках которой будет работать трансформация.</p>
      <p><span className="hl-9">transform-origin: точка-отсчёта-по-X [точка-отсчёта-по-Y]</span></p>
      <p>Значения свойства задаётся в единицах измерения ширины в браузере (px, em...), в %, а также ключевыми словами left, right, top, bottom и center.</p>
      <p>По умолчанию, значение transform-origin равно 50% 50%, то есть начало системы координат находится в центре объекта. Если не указывать значение точка-отсчёта-по-Y, то оно считается равным 50%.</p>

      <h2>Свойство transition</h2>
      <p>Если в двух словах, transition позволяет изменить значение какого-либо свойства плавно. В нашем случае плавно будет меняться свойство transform с функцией scale, а переход между двумя значениями будет длиться полсекунды.</p>
      <p>Зачастую выбор падает на JS-реализацию с помощью библиотеки jQuery, но в большинстве случаев «чистая» CSS-реализация простых визуальных эффектов намного производительнее аналогичных jQuery-функций. Кроме того, в ряде случаев определённые трансформации в CSS могут для повышения производительности задействовать не только центральный процессор компьютера или мобильного девайса, но и ресурсы графического адаптера, что позволяет разгрузить процессор и избавиться от «тормознутости» эффектов.</p>

      <h3>Длительность перехода, transition-duration</h3>
      <p>В отличие от анимаций, которые позволяют управлять любым количеством промежуточных состояний, с помощью transitions можно управлять только переходом между двумя состояниями: начальным и конечным.</p>
      <p>Чтобы обозначить плавный переход в CSS, достаточно задать одно свойство: transition-duration — длительность перехода. Значения задаются в секундах (10s, 3s), долях секунды (0.1s, 0.03s) или миллисекундах (100ms, 333ms).</p>
      <p>Рассмотрим плавный переход на простом примере с кнопкой, у которой по нажатию меняется цвет. Начальное состояние описано в классе .btn, а конечное — в классе .btn-active.</p>
      <p>Плавные переходы и анимацию можно применить только к некоторым CSS-свойствам - например, размер, цвет, позицию элементов. В статье на MDN приведён перечень анимируемых свойств и характер их анимирования.</p>
      <p>Если задана только длительность перехода transition-duration, то по умолчанию плавное изменение затрагивает все свойства элемента и для всех свойств происходит одновременно.</p>

      <h3>transition-property: какие свойства изменять плавно?</h3>
      <p>По умолчанию плавный переход действует на все анимируемые свойства элемента. Такое поведение соответствует значению all свойства transition-property, это значение по умолчанию. Такое поведение часто нежелательно, особенно когда в правиле много свойств.</p>
      <p>Можно указать, какие именно свойства нужно изменять плавно, перечислив их в transition-property через запятую:</p>
      <pre>{`transition-property: width;     // плавно меняется только ширина
transition-property: width, height; // плавно меняются ширина и высота
transition-duration: 1s, 5s; // ширина меняется за 1 секунду, высота за 5`}
      </pre>

      <h3>Задержка перехода, transition-delay</h3>
      <p>Оно определяет задержку перед началом перехода и задаётся в секундах или миллисекундах, как и transition-duration.</p>

      <h3>«Форма» перехода, transition-timing-function</h3>
      <p>Это свойство аналогично свойству animation-timing-function, которое разбирается в главе по анимациям. Свойство transition-timing-function определяет с какой скоростью и ускорением будут меняться свойства во время перехода.</p>
      <p>В предыдущих примерах переходы происходили с одинаковой динамикой. Мы меняли длительность и задержку перехода, но не «форму». Формы перехода:</p>
      <ul>
        <li>ease - переход начинается медленно, затем ускоряется и к концу движения опять замедляется;</li>
        <li>linear - чтобы сделать переход равномерным, без ускорений и замедлений, используется значение linear;</li>
        <li>ease-in - переход медленно начинается, а к концу ускоряется;</li>
        <li>ease-out — начинается быстро, а к концу замедляется;</li>
        <li>ease-in-out - похоже на ease, то есть переход начинается и заканчивается медленно, но происходит это чуть-чуть интенсивнее.</li>
      </ul>
      <p>Ещё один возможный класс значений transition-timing-function — это steps. Они позволяют задать «ступеньки», по которым будет идти переход. Синтаксис steps следующий:</p>
      <p><code>transition-timing-function: steps(число_шагов, направление);</code></p>
      <p>Тут всё просто: число_шагов — это целое число, за которое будет выполнен переход; направление может принимать значение start или end.</p>
      <p>При заданном start первый шаг выполняется одновременно с началом перехода, а в случае c end последний шаг будет выполнен вместе с завершением перехода.</p>
      <p>Кстати, переход можно описать в сокращённом виде свойством transition. Параметры перехода просто перечисляются через пробел: свойство, длительность, форма и задержка:</p>
      <p><code>transition: width 1s ease-in 2s; - переход тут применяется к ширине элемента, будет длиться 1 секунду с формой ease-in и задержкой перед началом в 2 секунды.</code></p>
      <p></p>
      <h2>Применение двумерных трансформаций на практике</h2>
      <h3>Центровка с помощью transform: translate</h3>
      <h3>Поворот текста в блоках</h3>
      <h3>Поворот текста в фоне</h3>
      <h3>Нестандартные тени</h3>
      <h3>Эффекты при наведении: кнопки</h3>
      <h3>Эффекты при наведении: галерея</h3>
      <h3>Круговое меню</h3>
    </section>
  );
}
export default TwoDimensionalTransfomations;
