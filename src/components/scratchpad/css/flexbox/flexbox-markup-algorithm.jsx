import React from 'react';

function FlexboxMarkupAlgorithm() {

  return (
    <section className="conspect">
      <h1>Flex layout algorithm</h1>
      <p>Этот алгоритм более сложный, чем в обычной блочной модели, и состоит из трёх этапов, которые выполняются друг за другом.</p>

      <h2>Этап 1. Определение исходных базовых размеров флекс-элементов</h2>
      <p>Базовый размер — это размер элемента вдоль главной оси.</p>
      <p>Исходный базовый размер — это тот размер, который получается, если к флекс-элементу не применять дополнительные возможности флекс-модели. То есть этот размер зависит от обычных свойств блочной модели (width, height, padding, border) и содержания элемента.</p>
      <ul>
        <li>свойство width или, если width не задано, ширина содержания (например, длина самого длинного слова),</li>
        <li>горизонтальные паддинги,</li>
        <li>горизонтальные рамки.</li>
      </ul>
      <p>Если главная ось направлена вертикально, то на исходный базовый размер влияют:</p>
      <ul>
        <li>свойство height или, если height не задано, высота содержания (например, количество текстовых строк),</li>
        <li>вертикальные паддинги,</li>
        <li>вертикальные рамки.</li>
      </ul>
      <p>С паддингами и рамками получается достаточно логично — в зависимости от направления главной оси в исходном размере учитывается либо вертикальный, либо горизонтальный компонент рамки или паддинга.</p>
      <p>А вот с шириной и высотой содержимого, то есть свойствами width или height, всё вышло не так удачно. Главная ось направлена горизонтально — используем одно свойство, повернули главную ось вертикально — используем другое свойство. Поэтому было добавлено ещё одно свойство — flex-basis. Оно задаёт размер области содержания вдоль главной оси, куда бы ось ни была повёрнута. Свойство flex-basis сильнее width и height, оно их переопределит, если встретится с ними на одном и том же флекс-элементе. Можно ли использовать width/height и не использовать flex-basis? Можно. А наоборот? Тоже можно. Просто помните про поведение этих свойств и направление главной оси.</p>
      <img src="img/flex/flex-1.png" alt="" width="731" height="358" />
      <p>Исходный базовый размер флекс-элемент определяется таким способом:</p>
      <ul>
        <li>1 шаг: Если задано свойство flex-basis (его значение отличается от auto), то в качестве размера области содержимого берём значение flex-basis и переходим к 5 шагу. Иначе идём ко 2 шагу.</li>
        <li>2 шаг: Если главная ось направлена горизонтально и задано свойство width (его значение отличается от auto), то в качестве размера области содержимого берём значение width и переходим к 5 шагу. Иначе идём к 3 шагу.</li>
        <li>3 шаг: Если главная ось направлена вертикально и задано свойство height (его значение отличается от auto), то в качестве размера области содержимого берём значение height и переходим к 5 шагу. Иначе идём к 4 шагу.</li>
        <li>4 шаг: Размер области содержимого определяется по размеру собственно содержимого флекс-элемента вдоль соответствующей оси. Это, кстати, не самый простой процесс. И при построении сеток такой ситуации нужно избегать, так как теряется контроль над размерами колонок. Переходим к 5 шагу.</li>
        <li>5 шаг: К размеру области содержимого прибавляем паддинги и рамки вдоль соответствующего направления главной оси и получаем исходный базовый размер.</li>
      </ul>
      <p className="hl-7">Важное правило: при построении сеток нужно всегда задавать либо flex-basis, либо width/height.</p>
      <p>После того как исходный базовый размер всех флекс-элементов определён, браузер может понять, сколько осталось свободного места во флекс-контейнере. И если место осталось, или если места не хватает, то может начать работать «гибкость» флекс-элементов. А это уже второй этап.</p>

      <h2>Этап 2. Применение гибких размеров и перераспределение свободного пространства</h2>
      <h3>2.1. Применение гибких размеров</h3>
      <p>Начнём сразу с примера. Ширина флекс-контейнера — 500px. Внутри него есть три флекс-элемента, исходный базовый размер каждого из них — 100px. Маргинов нет. Получается, что во флекс-контейнере осталось 500px - 300px = 200px свободного места.</p>
      <img src="img/flex/flex-2.png" alt="Сетка флексбокса" width="731" height="258" />
      <p>В обычной блочной модели эти 200px пикселей так бы и остались незанятыми, так как размеры элементов определяются в один проход. Внутри флекса размеры элементов пересчитываются несколько раз. И на втором проходе происходит перераспределение свободного пространства. Но только для «гибких» элементов. Причём эта «гибкость» существует двух типов: на растяжение и на сжатие.</p>
      <p>Свойство flex-grow отвечает за гибкость на растяжение, или за «жадность» флекс-элемента. Свойство flex-grow может принимать числовые значения и по умолчанию равно нулю, то есть элементы по умолчанию не «жадные». Если задать flex-grow значение больше нуля, то флекс-элемент становится «жадным» и начинает поглощать всё оставшееся в флекс-контейнере свободное пространство.</p>
      <img src="img/flex/flex-3.png" alt="Один «жадный» элемент" width="731" height="358" />
      <p>Посмотрите на картинку. Внутри флекс-контейнера есть два флекс-элемента и осталось свободное пространство. Один элемент мы делаем «жадным», задав ему flex-grow: 1, и он съедает это свободное пространство. Если мы обоим элементам зададим flex-grow: 1, то они свободное пространство разделят пополам.</p>
      <img src="img/flex/flex-4.png" alt="Несколько «жадных» элементов" width="731" height="358" />
      <p>Если флекс-элементам задать одинаковые положительные значения flex-grow, то они поровну поделят между собой свободное пространство. Если у флекс-элементов значения flex-grow будут отличаться, то свободное пространство поделится пропорционально этим значениям.</p>
      <p>Вернёмся к примеру с флекс-контейнером шириной 500px и флекс-элементами с исходным базовым размером 100px. Если этим флекс-элементам задать flex-grow: 1, то они поделят 200px свободного пространства поровну, то есть каждому достанется по 66.6px, и базовый размер каждого станет равен 166.6px. Заметьте, это уже не исходный базовый размер, а итоговый базовый размер (хотя этот итоговый размер позже ещё может измениться).</p>
      <img src="img/flex/flex-5.png" alt="Сетка флексбокса" width="731" height="258" />
      <p>Когда применяется flex-grow? Он нужен для «резиновости» без необходимости соблюдения точных пропорций колонок. Никогда не используйте flex-grow, если вам нужно точно управлять шириной. Например, чтобы каждая колонка была шириной ровно 30% родителя, нужно использовать width: 30% или flex-basis: 30%, но никак не flex-grow.</p>
      <p>Свойство flex-shrink отвечает за гибкость на сжатие. Свойство flex-shrink может принимать числовые значения и по умолчанию равно единице. Получается, что все флекс-элементы по умолчанию могут сжиматься, если после определения исходных базовых размеров выяснилось, что места во флекс-контейнере не хватает. Причём ужимается только область содержимого, а маргины, паддинги и рамки не ужимаются.</p>
      <p>Мы не будем много говорить о flex-shrink, так как оно используется достаточно редко. Действительно, если предвидится большое количество элементов в микросетке, то лучше включить многострочный флекс-контейнер и тогда flex-shrink будет неактуален (за исключением очень редких случаев). Если идёт работа над сеткой, то лучше вообще отключить возможность сжатия у элементов-колонок.</p>

      <h3>2.2. Применение автоматических отступов</h3>
      <p>Если на этом этапе во флекс-контейнере ещё осталось свободное пространство, то приходит череда автоматических отступов. То есть свойств margin со значением auto у флекс-элементов.</p>
      <p>Во флексбоксе автоматические отступы работают намного лучше, чем в обычной блочной модели. Во-первых, они работают во всех направлениях (в обычной блочной модели они работают только в горизонтальном направлении). Во-вторых, они умеют взаимодействовать друг с другом: если на одной оси есть несколько автоматических отступов (у разных элементов или с разных сторон одного элемента), то эти отступы поровну разделяют между собой свободное пространство.</p>
      <p>Разберём пример. Посмотрите, что случилось со вторым элементом. Это эффект от действия автоматических отступов: margin-top: auto и margin-left: auto.</p>
      <pre>{`.flex-container {
  display: flex;
  flex-direction: row;
}

.flex-container div:nth-child(2) {
  margin-top: auto;
  margin-left: auto;
  width: 200px;
}`}
      </pre>
      <img src="img/flex/flex-6.png" alt="Свойство margin: auto" width="731" height="358" />
      <p>Браузеры всегда переводят для отступов значение auto в значение в пикселях. В нашем примере браузер уже «знает» размеры свободного пространства в пикселях вдоль обеих осей. Вдоль главной оси он уже вычел из ширины контейнера ширины элементов, а вдоль поперечной оси он уже вычел из высоты контейнера высоту флекс-элемента (одна строчка текста плюс вертикальные паддинги). Да, вдоль поперечной оси расчёты проще, так как поперечная ось у каждого элемента своя.</p>
      <p>Вдоль главной оси есть всего один автоматический отступ (слева у второго элемента), поэтому его размер стал равен размеру свободного пространства. После этого свободного пространства вдоль главной оси не осталось (оно всё ушло в отступ), второй элемент оттолкнулся от первого и прижал третий к правому краю флекс-контейнера.</p>
      <p>Вдоль поперечной оси второго элемента тоже есть всего один автоматический отступ (сверху) поэтому он тоже стал равен размеру свободного пространства. После этого свободного пространства вдоль поперечной оси второго элемента не осталось, и элемент прижался к концу своей поперечной оси.</p>
      <p>Почему первый и третий элементы тянутся на всю высоту контейнера? Потому что у них свойство align-items равно stretch (это значение по умолчанию), и это значение растягивает флекс-элементы на всю поперечную ось, если им не задан фиксированный размер вдоль поперечной оси, и если вдоль поперечной оси есть свободное место.</p>
      <p>Второй элемент тянуться на всю высоту перестал, хотя ему не задана высота. Значит вдоль его поперечной оси не осталось свободного места. Это место забрал автоматический отступ сверху. Из этого примера важно запомнить, что свойства для выравниваний и распределений срабатывают после автоматических отступов. Если бы отступы работали после выравниваний, то второй элемент по высоте бы не ужался.</p>

      <h3>2.3. Распределение и выравнивание элементов вдоль осей.</h3>
      <p>Если и на этом этапе во флекс-контейнере ещё осталось свободное пространство, то приходит череда свойств для распределения и выравнивания флекс-элементов.</p>
      <p>Свойство justify-content — распределяет флекс-элементы вдоль главной оси. Главная ось общая для всех флекс-элементов, они нанизаны на неё как бусинки на ниточку. То есть флекс-элементы на главной оси друг друга видят и толкают.</p>
      <pre>{`.flex-container {
  display: flex;
  flex-direction: row;
  justify-content: flex-start; /*по умолчанию*/

  /*
  justify-content: flex-end;
  justify-content: center;
  justify-content: space-between;
  justify-content: space-around;
  */
}`}
      </pre>
      <img src="img/flex/flex-7.png" alt="Распределение флекс-элементов вдоль главной оси по умолчанию, свойство justify-content: flex-start" width="731" height="358" />
      <p>На картинке показано, как распределяются элементы вдоль главной оси при разных значениях justify-content. Кстати, значение по умолчанию — flex-start.</p>
      <img src="img/flex/flex-8.png" alt="Значения свойства justify-content" width="731" height="358" />
      <p>Свойство align-items отвечает за выравнивание флекс-элементов вдоль поперечной оси. У каждого флекс-элемента есть своя, отдельная, поперечная ось. Значение по умолчанию у align-items — stretch. При этом значении флекс-элементы растягиваются на всю высоту родительского флекс-контейнера, если ему задана высота и если вдоль поперечной оси есть место (вспоминаем про автоматические отступы).</p>
      <pre>{`.flex-container {
  display: flex;
  flex-direction: row;
  align-items: stretch; /*по умолчанию*/

  /*
  align-items: flex-start;
  align-items: flex-end;
  align-items: center;
  align-items: baseline;
  */
}`}
      </pre>
      <img src="img/flex/flex-9.png" alt="Выравнивание вдоль поперечной оси по умолчанию, align-items: stretch" width="731" height="358" />
      <p>На картинке показано, как распределяются элементы вдоль поперечной оси при разных значениях align-items.</p>
      <img src="img/flex/flex-10.png" alt="Значения свойства align-items" width="731" height="358" />
      <pre>{`.flex-container {
  display: flex;
  flex-direction: row;
  align-items: stretch; /*по умолчанию*/

  align-items: flex-start;
  align-items: flex-end;
  align-items: center;
  align-items: baseline;
}

.flex-container div:nth-child(2) {
  line-height: 50px;
}`}
      </pre>
      <p>Свойство align-items задаётся флекс-контейнеру и действует на все флекс-элементы. Но так как поперечная ось у каждого элемента своя, то и разные элементы можно вдоль неё выравнивать по-разному. Для этого предназначено свойство align-self, это такое «эгоистичное» выравнивание. Это свойство задаётся флекс-элементу, а не флекс-контейнеру, и имеет такие же значения, как свойство align-items.</p>
      <pre>{`.flex-container {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
}

.flex-container div:nth-child(2) {
  align-self: center;
}`}
      </pre>
      <img src="img/flex/flex-11.png" alt="«Эгоистичное» выравнивание с помощью свойства align-self" width="731" height="358" />

      <h2>Этап 3. Применение ограничений размеров</h2>
      <p>На последнем этапе алгоритма раскладки флексбокса в дело включаются так называемые «ограничивающие» свойства: min-width, max-width, min-height, max-height. Эти свойства начинают работать уже после применения коэффициентов гибкости (flex-grow и flex-shrink) и могут приводить к очень странным эффектам, похожим на эффекты выпадения из потока.</p>
      <p>Детально работу этих свойств мы разбирать не будем, потому что с ними вы будете сталкиваться нечасто. Однако всегда помните, что наличие min-width, max-width, min-height, max-height у флекс-элементов могут приводить к странным эффектам.</p>

      <h3>И напоследок ещё несколько советов по созданию сеток:</h3>
      <ul>
        <li>В сетках всегда нужно явно задавать размер колонок. Используйте для этого свойства width или flex-basis.</li>
        <li>Если размер нужно контролировать точно, то задавайте width или flex-basis в пикселях или процентах.</li>
        <li>Если нужно, чтобы колонка просто тянулась без соблюдения точных пропорций, то width или flex-basis всё равно задаются, но их можно дополнить ненулевым flex-grow.</li>
        <li>Свойство flex-grow не подходит для точного контроля размера колонок.</li>
        <li>Расстояния между колонок можно задавать с помощью justify-content: space-between или justify-content: space-around в случае, если расстояния между колонок одинаковые и количество колонок неизменно.</li>
        <li>Однако justify-content не подходит, когда расстояния не одинаковые, либо когда количество колонок может меняться (например, в карточных раскладках). В этом случае лучше использовать justify-content: flex-start в сочетании с margin.</li>
        <li>Псевдоэлементы внутри флекс-контейнера тоже становятся флекс-элементами и могут влиять на расположение флекс-элементов, созданных обычными тегами.</li>
        <li>Существует составное свойство flex, которое задаётся для флекс-элемента. Например: flex: 0 1 auto; Это комбинация из трёх свойств: flex-grow, flex-shrink, flex-basis.</li>
      </ul>
    </section>
  );
}
export default FlexboxMarkupAlgorithm;
