import React from 'react';

function Selectors() {

  return (
    <section className="conspect">
      <h1>Селекторы в CSS</h1>
      <h2>Общие правила CSS</h2>
      <h3>Свойства и значения</h3>
      <p>Список свойств и значений находится внутри фигурных скобок CSS-правила. Свойство определяет, какую характеристику внешнего вида мы хотим изменить, а значение — как именно.</p>
      <pre>{`.feature-kitten {;
  padding-top: 60px;
}`}
      </pre>

      <h2>Наследование</h2>
      <p>Наследование в CSS — это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам. Стили, присвоенные одному элементу, наследуются всеми потомками (вложенными элементами, но только в том случае, если они где-то явно не переопределены.</p>
      <p>Не все свойства в CSS наследуются. К наследуемым относятся в основном свойства, определяющие параметры отображения текста:</p>
      <p><span className="hl-8">font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction, list-style, cursor, visibility, border-collapse и другие.</span></p>
      <p>Весь список наследуемых свойств вы можете найти в стандарте CSS. Если в колонке Inherited? напротив свойства стоит yes, то свойство наследуемое, иначе ненаследуемое.</p>
      <p>Наследуемые свойства можно и нужно задавать через предков, следуя структуре документа.</p>
      <p>Например, параметры текста зачастую не меняются в пределах крупных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях этих крупных блоков.</p>

      <h2>Ненаследуемые свойства</h2>
      <p>Основные ненаследуемые свойства — это параметры позиционирования, размеров, отступов, фона, рамок:</p>
      <p><span className="hl-9">background, border, padding, margin, width, height, position и другие</span></p>
      <p>Не наследуются они из соображений здравого смысла.</p>
      <p>Например, если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.</p>

      <h2>Составные свойства</h2>
      <p>В CSS есть составные свойства, управляющие одновременно несколькими параметрами. Например, свойство font. Оно задаёт сразу шесть параметров: размер и название шрифта, высоту строки и некоторые другие.</p>
      <p><span className="hl-2">font: 16px/26px &quot;Arial&quot;, sans-serif;</span></p>
      <p>Если значение обычного свойства не было задано в составном, то браузер при «расшифровке» использует исходное значение этого свойства.</p>
      <p>Некоторые составные:</p>
      <p><span className="hl-4">animation: animation-duration || animation-timing-function || animation-delay || animation-iteration-count || animation-direction || animation-fill-mode || animation-play-state || [none | animation-name]</span></p>
      <p><span className="hl-6">background: [<code>&lt;фон&gt;</code>, ]* <code>&lt;последний_фон&gt;</code></span></p>
      <p><span className="hl-6">Здесь: <code>&lt;фон&gt;</code> = background-image || background-position [ / background-size ]? || background-repeat || background-attachment || background-origin || background-clip <code>&lt;последний_фон&gt;</code> = background-image || background-position [ / background-size ]? || background-repeat || background-attachment || background-origin || background-clip || background-color</span></p>
      <p><span className="hl-8">border: border-width || border-style || border-color</span></p>
      <p><span className="hl-7">font: [font-style||font-variant||font-weight||font-stretch] font-size [/line-height] font-family</span></p>
      <p><span className="hl-6">padding, margin: [<code>&lt;размер&gt;</code> | <code>&lt;проценты&gt;</code> | auto] <code>{'{1,4}'}</code></span></p>
      <p><span className="hl-5">outline: outline-color || outline-style || outline-width</span></p>
      <p><span className="hl-4">transition: <code>&lt;переход&gt;</code> [, <code>&lt;переход&gt;</code> ]*</span></p>
      <p><span className="hl-3">Здесь: <code>&lt;переход&gt;</code> = [ none | <code>&lt;transition-property&gt;</code> ] || <code>&lt;transition-duration&gt;</code> || <code>&lt;transition-timing-function&gt;</code> || <code>&lt;transition-delay&gt;</code></span></p>
      <p>Разрешается использовать одно, два, три или четыре значения, разделяя их между собой пробелом.</p>
      <dl>
        <dt>1</dt>
        <dd>Отступы будут установлены одновременно от каждого края элемента.</dd>
        <dt>2</dt>
        <dd>Первое значение устанавливает отступ от верхнего и нижнего краёв, второе — от левого и правого.</dd>
        <dt>3</dt>
        <dd>Первое значение задает отступ от верхнего края, второе — одновременно от левого и правого краёв, а третье — от нижнего края.</dd>
        <dt>4</dt>
        <dd>Поочередно устанавливается отступ от верхнего, правого, нижнего и левого края.</dd>
        <dt>auto</dt>
        <dd>Указывает, что размер отступов будет автоматически рассчитан браузером.</dd>
      </dl>
      <p>Величину отступов можно указывать в пикселях (px), процентах (%) или других допустимых для CSS единицах. Значение может быть как положительным, так и отрицательным числом.</p>

      <h3>Типы значений: абсолютные и относительные</h3>
      <p>Абсолютные единицы измерения привязаны к настоящим физическим размерам и связаны между собой жёсткими пропорциями. Пиксели, px, используют чаще всего, остальные абсолютные единицы почти не применяют. Примеры абсолютных единиц измерения:</p>
      <pre>{`font-size: 1cm;
font-size: 10mm;
font-size: 38px; `}
      </pre>
      <p>Относительные единицы измерения описывают значения, которые зависят от других значений. Например, ширина элемента в процентах зависит от ширины родительского элемента, а ширина элемента в em зависит от размера шрифта самого элемента. К относительным единицам относятся em, rem, vh, vw и некоторые другие, ну и, конечно же, проценты.</p>
      <p>Перечень всех абсолютных единиц измерения и их соотношений есть в <a className="text-link" href="https://www.w3.org/TR/css-values-4/#lengths" target="blank">спецификации</a>. Там же, в спецификации, есть перечень всех относительных единиц измерения и описание правил расчёта.</p>

      <h2>Стили по умолчанию</h2>
      <p>Некоторым элементам можно не задавать никаких стилей, но у них всё равно будет какое-то оформление. Например, у списка <code><code>&lt;ul&gt;</code></code>есть отступы и маркеры. Такие стили называются стилями по умолчанию и задаются внутри браузерных стилей изначально. Их можно переопределить или сбросить, задав другие значения свойств элементу.</p>

      <h2>Каскадирование</h2>
      <p>Когда браузер отрисовывает страницу, он должен определить итоговый вид каждого HTML-элемента. Для этого он собирает все CSS-правила, которые относятся к каждому элементу, ведь на элемент могут влиять сразу несколько CSS-правил. Механизм комбинирования стилей из разных источников в итоговый набор свойств и значений для каждого тега называется каскадностью. Например, есть такой элемент в разметке:</p>
      <p><span className="hl-3"><code>&lt;p class=&quot;beloved-color&quot;&gt;</code>Зелёный - мой любимый цвет<code>&lt;/p&gt;</code></span></p>
      <pre>{`Заданные стили:
  .beloved-color { color: green; }

  Браузерные стили:
  margin: 1em 0;

  Итоговые стили:
  color: green;
  margin: 1em 0;`}
      </pre>

      <h2>Конфликт свойств</h2>
      <p>На один элемент могут действовать несколько CSS-правил. Если в этих правилах есть одинаковые свойства с разными значениями, то возникает конфликт. Например:</p>
      <pre>{`ul { list-style: disc; }
.blog-navigation ul { list-style: none; }`}
      </pre>
      <p>Конфликт разрешается браузером максимум за три шага. Если на текущем шаге определиться не удалось, то выполняется следующий шаг. Вот эти шаги:</p>
      <ol>
        <li>Сравниваются приоритеты стилевых файлов, в которых находятся конфликтующие свойства. Например, авторские (то есть наши) стили приоритетнее браузерных.</li>
        <li>Сравнивается специфичность селекторов у CSS-правил с конфликтующими свойствами. Например, селектор по классу более специфичен, чем селектор по тегу.</li>
        <li>Побеждает то свойство, которое находится ниже в коде.</li>
      </ol>
      <p>Каскад работает и внутри CSS-правил. Использование нескольких классов в разметке помогает явно указать, какие стили будут смешиваться с помощью каскада. И, конечно, эти стили удобнее всего разместить в коде рядом друг с другом.</p>
      <p>Использование однотипных селекторов (например, по классам) позволяет использовать самый простой механизм разрешения конфликтов — по порядку в коде. Размещаем частные CSS-правила после общего, и всё что нужно точно переопределится.</p>

      <h2>Подключение внешних стилей</h2>
      <p>Встраивание стилей в тег <code><code>&lt;style&gt;</code></code>. Его обычно размещают внутри <code><code>&lt;head&gt;</code></code>:</p>
      <pre>{`<head>
  <style>
    CSS-код
  </style>
</head>`}
      </pre>
      <p>Такой способ используется для оптимизации загрузки страницы, ведь в таком случае браузер не будет отправлять дополнительных запросов на сервер.</p>
      <p>Встраивание в атрибут style:</p>
      <p><span className="hl-3"><code>&lt;div style=&quot;width: 50%;&quot;&gt;</code><code>&lt;/div&gt;</code></span></p>
      <p>Свойства и значения, прописанные таким образом, применятся точечно к одному элементу. <span className="hl-4">Обычно использование этого способа считается плохой практикой.</span> Но иногда в виде исключения бывает удобнее воспользоваться встраиванием стилей в атрибут style, чем писать отдельные CSS-правила. Например, когда нужно управлять стилями именно из разметки, и создавать отдельные классы при этом будет излишне. Так бывает, когда какие-то стилевые параметры устанавливаются с помощью сторонних программ или другими людьми, например, через CMS.</p>
      <p>Давайте подробнее разберём пример со style=&quot;width: 50%;&quot;. Предположим, что нужно иметь возможность управлять в разметке шириной с помощью свойства width в диапазоне от 0% до 100%. Чтобы сделать это через CSS, пришлось бы создать 100 классов, и применять их, например:</p>
      <pre>{`.width-0 &#123; width: 0% &#125;
.width-1 &#123; width: 1% &#125;
.width-2 &#123; width: 2% &#125;
/* и так далее… */`}
      </pre>
      <p>Намного удобнее будет сделать точечное встраивание стиля с шириной в атрибут style.</p>

      <h2>Селекторы по тегам:</h2>
      <p><span className="hl-6">h1 &#123; color: red; &#125;</span></p>
      <p>Стилями по тегу нужно описывать общие свойства для всех тегов. Подходит для сброса отступов по умолчанию для списков например.</p>

      <h2>Селекторы по классам:</h2>
      <p>Класс — это один из атрибутов тегов. Выглядит он вот так:</p>
      <p><span className="hl-6"><code>&lt;li class=&quot;first&quot;&gt;</code><code>&lt;/li&gt;</code></span></p>
      <p>Имена классов могут состоять из латинских символов, цифр и знаков - и _. Имя класса должно начинаться с латинской буквы.</p>
      <p><span className="hl-7">.info &#123; color: blue; &#125;</span></p>
      <p><span className="hl-8">Селекторы по классам предпочтительнее, чем по тегам.</span></p>
      <p>Если у CSS-правил отличаются только селекторы, а свойства и значения одинаковые, то их можно сгруппировать через запятую: <span className="hl-2">h1, .danger &#123; color: red; &#125;</span></p>
      <p>Также можно комбинировать любые типы селекторов через пробел. Такие селекторы называются вложенными или контекстными и читаются справа налево. Например:</p>
      <pre>{`nav a {…};
  .menu ul {…}
  .post .title {…}`}
      </pre>

      <h2>Вложенные селекторы</h2>
      <p>Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.</p>
      <p>Вы можете комбинировать любые типы селекторов через пробел. Такие селекторы называются вложенными или контекстными и читаются справа налево. Например:</p>
      <pre>{`nav a {…}        /* выберет теги a внутри тегов nav */
.menu ul {…};     /* теги ul внутри тегов с классом menu */
.post .title {…} /* теги с классом title внутри тегов с классом post */`}
      </pre>
      <p>Комбинировать можно любое количество селекторов, но лучше использовать двойную или максимум тройную вложенность. Вложенные селекторы спасают нас от необходимости придумывать имена классов и загромождать ими разметку.</p>

      <h3>Соседние селекторы</h3>
      <p>Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.</p>
      <p>Например, теги <code>&lt;li&gt;</code> в списке являются соседними по отношению друг к другу и вложенными в тег <code>&lt;ul&gt;</code>.</p>
      <p>Соседние селекторы записываются с помощью знака +, например, селектор1 + селектор2. Стили применятся к элементу, подходящему под селектор2, только если сразу перед ним расположен элемент, подходящий под селектор1.</p>

      <h3>Контекстные и соседние селекторы</h3>
      <p>Селекторы в CSS можно очень гибко комбинировать. В частности, можно комбинировать контекстные и соседние селекторы.</p>

      <h2>Дочерние селекторы</h2>
      <p>Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:</p>
      <pre>{`<ul>
  <li><span>...</span></li>
  <li><span>...</span></li>
</ul>`}
      </pre>
      <p>По отношению к списку <code>&lt;ul&gt;</code> элементы <code>&lt;li&gt;</code> являются дочерними элементами и потомками, а <code>&lt;span&gt;</code> — потомки, но не дочерние элементы.</p>
      <p>Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.</p>
      <p>Для этого существует дочерний селектор, в котором используется символ <code>&gt;</code>. Например: <code>ul &gt; li или ul &gt; li &gt;</code> span.</p>

      <h2>Псевдоклассы и псевдоэлементы</h2>
      <p className="hl-8">Псевдоэлементы служат для обращения к отдельным частям элементов, тогда как псевдоклассы позволяют стилям различать разные типы элементов.</p>

      <h3>Псевдоклассы</h3>
      <p>Псевдоклассы — это дополнения к обычным селекторам, которые делают их ещё точнее и мощнее. Обычный селектор — это снайперский прицел, а с псевдоклассом он становится прибором ночного видения.</p>
      <p>Псевдокласс добавляется к селектору c помощью символа :, вот так селектор:псевдокласс. Например:</p>
      <pre>{`a:visited { ... }
li:last-child { ... }
.alert:hover { ... }`}
      </pre>
      <p>Псевдокласс first-child позволяет выбрать первый дочерний элемент родителя, а last-child — последний дочерний элемент. Например:</p>

      <h4>Псевдокласс :nth-child</h4>
      <p>С помощью псевдокласса nth-child можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: селектор:nth-child(выражение). Выражением может быть число или формула. Например:</p>
      <pre>{`1. li:nth-child(2) { ... }
2. li:nth-child(4) { ... }
3. li:nth-child(2n) { ... }`}
      </pre>
      <p>Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элементы.</p>

      <h4>:nth-child и контекстные селекторы</h4>
      <p>Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами. Например, следующий селектор выберет третий тег <code>&lt;li&gt;</code> внутри блока с классом shooter-2</p>
      <p><span className="hl-1">.shooter-2 li:nth-child(3) &#123; ... &#125;</span></p>
      <p>Селектор не обязательно должен заканчивается псевдоклассом. Например, следующий селектор выберет элемент с классом .text в четвёртом элементе списка</p>
      <p><span className="hl-2">li:nth-child(4) .text &#123; ... &#125;</span></p>

      <h4>Псевдокласс :hover</h4>
      <p>Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата.</p>
      <pre>{`1. a:hover { ... }
2. tr:hover { ... }
3 .menu-item:hover { ... }`}
      </pre>
      <p>Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом menu-item, но только в том случае, если на них наведён курсор мыши.</p>

      <h5>Динамические эффекты с помощью :hover</h5>
      <p>Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:</p>
      <pre>{`li.top ul.submenu {
  display: none;
}`}
      </pre>
      <p>Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто.</p>
      <p>Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. То есть всё работает на контекстных селекторах вида селектор1:hover селектор2.</p>

      <h5>Псевдоклассы :link, :visited и :active</h5>
      <p><span className="hl-6">:link выбирает ещё не посещённые ссылки.</span></p>
      <p><span className="hl-7">:visited выбирает посещённые ссылки.</span></p>
      <p><span className="hl-7">:active выбирает активные ссылки (кнопка мыши зажата на ссылке).</span></p>
      <p>Пример задания CSS-правил для ссылок:</p>
      <pre>{`a:link { ... }
a:visited { ... }
a:hover { ... }
a:active { ... }`}
      </pre>
      <p>Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.</p>

      <h5>Псевдокласс :focus</h5>
      <p>Псевдокласс :focus позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе.</p>
      <p>В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.</p>
      <p>Пример использования псевдокласса:</p>
      <pre>{`input:focus {
  /* стили для поля в фокусе */
}`}
      </pre>

      <h2>Селекторы атрибутов</h2>
      <p>Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.</p>
      <p>Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:</p>
      <pre>{`1. input[checked] { ... }
2. input[type="text"] { ... }`}
      </pre>
      <p>Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.</p>

      <h2>Селектор по id</h2>
      <p>Существует ещё один HTML-атрибут, для которого существует специальный селектор. Этот атрибут id (идентификатор), а селектор записывается с помощью символа #, например, #some-id.</p>
      <p>На значение id распространяются те же ограничения, что и на имя класса. Также id должен быть уникальным на странице. Пример:</p>
      <pre>{`HTML<p id="greeting">Приветствие!</p>
CSS#greeting {
  ...
}`}
      </pre>
      <p>Использование селекторов по id при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.</p>

      <h2>Объединение селекторов</h2>
      <p>В CSS есть запись, которая фактически выполняет операцию логического умножения, «И». Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов:</p>
      <p><span className="hl-1">.class1.class2 { }</span></p>
      <p>Стили будут применяться ко всем элементам, которые одновременно имеют класс class1 и class2. По такому же принципу можно объединять любое количество абсолютно разных селекторов. И чем больше селекторов вы объединяете, тем больше условий должно совпасть для применения стилей.</p>
      <p>В программировании похожую операцию часто обозначают как &&. Например:</p>
      <pre>{'if (firstSelector && secondSelector) { ... }'}
      </pre>

      <h2>Псевдокласс :not</h2>
      <p>Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбрать элементы, которые НЕ содержат указанный селектор:</p>
      <pre>{'li:not(:last-child) { }'}
      </pre>
      <p>Этот селектор выберет все теги li, НЕ являющиеся последними в их родителе.</p>
      <pre>{'if (!selector) { ... }'}
      </pre>
      <p>Псевдокласс :not похож на оператор ! в программировании:</p>
      <p>В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс :not, то есть конструкция :not(:not(...)) не сработает.</p>
      <p>Также в комбинации с :not не применяются:</p>
      <ul>
        <li>объединение селекторов: например, li:not(.heart.jack) — некорректный селектор;</li>
        <li>псевдоэлементы: li:not(::after) — неправильная запись (подробнее о псевдоэлементах рассказано далее в курсе);</li>
        <li>селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span).</li>
      </ul>

      <h5>Комбинируем :not</h5>
      <p>Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с другими. Например:</p>
      <p><span className="hl-3">li:not(:first-child):not(:last-child) &#123; &#125;</span></p>
      <p>Выберет все теги <code>&lt;li&gt;</code>, которые НЕ являются первыми и последними в их родителе.</p>
      <p>Объединять можно неограниченное количество селекторов.</p>

      <h3>Псевдокласс :nth-last-child</h3>
      <p>Псевдокласс :nth-last-child используется для добавления стиля к элементам на основе нумерации в дереве элементов. В отличие от псевдокласса :nth-child, отсчет ведется не от первого элемента, а от последнего. Вот и все различия.</p>

      <h3>Псевдокласс :first-of-type</h3>
      <p>Псевдокласс :first-of-type очень похож на :first-child. Он выбирает первый дочерний элемент родителя, только <span className="hl-4">с учетом типа элементов</span>.</p>
      <p>Например, здесь перед списками с картами есть блок с текстом. У списков и у блока с текстом общий родитель — body.</p>
      <pre>{`<body>
  <div class="paper"> … </div>
  <ul class="cards"> … </ul>
  <ul class="cards"> … </ul>
</body>

Сравним две записи:
ul:first-child {
  background-color: #ffffee;
}

и

ul:first-of-type {
  background-color: #ffffee;
}`}
      </pre>
      <p>Верхний селектор выбирает первый дочерний элемент в родителе, причем этот элемент должен быть ul. В нашем случае не выберется ничего, потому что первым дочерним элементом body является div.</p>
      <p>Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе. В нашем случае будет выбрана первая строка с картами.</p>

      <h3>Псевдокласс :last-of-type</h3>
      <p>Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа. Пример записи:</p>
      <pre>{`ul:last-of-type {
  ...
}`}
      </pre>

      <h3>Псевдокласс :nth-of-type</h3>
      <p>Псевдокласс :nth-of-type работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тип элемента.</p>
      <pre>{`ul:nth-child(2) { }
ul:nth-of-type(2) { }`}
      </pre>
      <p>Верхний cелектор выберет второй по счёту дочерний элемент и этот элемент должен быть ul. В нашем случае выберется первая строка карт.</p>
      <p>А нижний селектор выберет второй по счету ul среди дочерних ul. В нашем случае выберется вторая строка карт.</p>

      <h5>Псевдокласс :nth-last-of-type</h5>
      <p>Элементы выбираются по их расположению, отсчет ведется от конца, учитывается тип элемента.</p>
      <p>Пример записи:</p>
      <pre>{'ul:nth-last-of-type(2) { }'}
      </pre>
      <p>Когда набор элементов не очень большой, все эти псевдоклассы :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type можно легко заменить один другим.</p>
      <p>На более сложных структурах зачастую бывает удобнее использовать только определённые из них. Например, когда нужно выделять второй элемент с конца, но количество элементов в списке изменяется.</p>

      <h2>Cелектор последующих элементов (селектор1 ~ селектор2)</h2>
      <p>Стили применятся к элементу, подходящему под селектор2, только если перед ним расположен элемент, подходящий под селектор1. Оба элемента должны принадлежать одному родителю.</p>
      <p>Отличие от соседнего селектора состоит в том, что между элементами селектор1 и селектор2 могут находиться другие элементы.</p>
      <pre>{`<ul class="cards">
  <li class="king diamond">
  <li class="queen heart">
  <li class="jack spade">
  <li class="ace heart">
  <li class="king club">
</ul>
.queen.heart + li {
  background-color: #ffff99;
}

.king.diamond ~ li {
  background-color: #99ddff;
}`}
      </pre>
      <p>В первом случае выделится одна карта, расположенная сразу за червовой дамой, то есть пиковый валет.</p>
      <p>Во втором случае выделятся все карты, которые стоят за бубновым королем, то есть червовая дама, пиковый валет, червовый туз и трефовый король.</p>

      <h2>Псевдокласс :empty</h2>
      <p>Псевдокласс :empty, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов). Учтите, что даже переход на новую строку считается текстовым узлом, помните об этом в процессе проектирования структуры страницы.</p>

      <h2>Псевдокласс :only-child</h2>
      <p>Псевдокласс :only-child пригодится, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.</p>
      <pre>{`li:only-child {
  ...
}`}
      </pre>
      <p>Сработает, когда этот <code>&lt;li&gt;</code> в списке единственный.</p>
      <p>Cелектор :only-child эквивалентен селектору elem:last-child:first-child.</p>

      <h2>Псевдокласс :only-of-type</h2>
      <p>Псевдокласс :only-of-type работает почти так же, как и :only-child. Отличие состоит в том, что он учитывает тип элемента.</p>

      <h3>Псевдоэлементы</h3>
      <h4>Псевдоэлемент ::before</h4>
      <p>Псевдоэлемент before позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Cодержимое псевдотега задаётся с помощью свойства content.</p>
      <p>Исходный HTML-код не изменится, тег <code>&lt;before&gt;</code> не попадёт в код страницы, а будет «виртуально» существовать где-то в браузере. Поэтому мы и используем приставку псевдо.</p>
      <p>Ведёт себя псевдотег так же, как обычный span с текстом. Ему можно задавать дополнительные стили.</p>
      <pre>{`.heart::before {
  content: "Черви";
  color: red;
}`}
      </pre>
      <p>Чтобы псевдоэлемент появился, ему необходимо задать свойство content. Достаточно даже пустой строки в значении свойства — content: &quot;&quot;;.</p>

      <h4>Псевдоэлемент ::after</h4>
      <p>Псевдоэлемент after аналогичен before. Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента.</p>
      <p>Псевдоэлементы before и after можно использовать одновременно. Это означает, что с помощью CSS вы можете добавить к любому элементу на странице два псевдоэлемента.</p>
      <p><span className="hl-4">Обратите внимание, что псевдоэлементы пишутся с двойным двоеточием. Этим они отличаются от псевдоклассов, которые используют одинарное двоеточие.</span></p>

      <h2>Позиционирование псевдоэлементов</h2>
      <p>Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее.</p>
      <p>Этими возможностями особенно часто пользуются при создании различных декоративных эффектов.</p>

      <h4>Псевдоэлементы ::first-line и ::first-letter</h4>
      <p>Псевдоэлемент first-line задает стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и так далее. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.</p>
      <p>Аналогично псевдоэлемент first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.</p>

      <h2>Ищем в начале строки: [foo^=&quot;bar&quot;]</h2>
      <p>В первом курсе про селекторы мы разбирали селектор по атрибутам, когда запись input[type=&quot;text&quot;] выберет все элементы input, у которых атрибут type равен text.</p>
      <p>У этого механизма есть дополнительные возможности: можно выбирать элементы по вхождению подстроки в значение атрибута.</p>
      <p>Запись вида [foo^=&quot;bar&quot;] выберет все элементы, у которых значение атрибута foo начинается с подстроки bar.</p>
      <p>Представьте, что у вас есть три класса для задания колонок разной ширины, например: column-1, column-2 и column-3.</p>
      <p>У этих классов часть свойств повторяется, а разной является только ширина. Чтобы не дублировать CSS-код, вы можете вынести общие свойства колонок в правило с селектором [class^=&quot;column-&quot;], а в остальных правилах задать только ширину:</p>
      <pre>{`[class^="column-"] {
  /* общие свойства: отступы, рамки, фон и так далее */
}
.column-1 { width: 100px; }
.column-2 { width: 200px; }
.column-3 { width: 300px; }
То есть, первый селектор выберет все дивы с классами, начинающимися на column-:

<div class="column-1"></div>
<div class="column-2"></div>
<div class="column-3"></div>`}
      </pre>
      <p><span className="hl-4">Обратите внимание, что селектор чувствителен к регистру.</span></p>

      <h3>Ищем в конце строки: [foo$=&quot;bar&quot;]</h3>
      <p>Селектор вида [foo$=&quot;bar&quot;] выбирает все элементы, значение атрибута foo которых оканчивается строкой bar.</p>
      <p>Представьте, что у вас на сайте есть раздел с файлами для скачивания в разных форматах и вам нужно для каждого типа файлов добавить свою иконку. Пример разметки:</p>
      <pre>{`<a href="batman.pdf">Скачать</a>
<a href="superman.doc">Скачать</a></code></pre>
В этом случае вы можете назначать иконки в CSS по расширениям файлов:
<pre><code>
a[href$=".pdf"] {
  /* иконка для PDF */
}
a[href$=".doc"] {
  /* иконка для DOC */
}</code></pre>
И снова, селектор чувствителен к регистру.
</p>
<h3>Поиск подстроки везде: [foo*="bar"]</h3>
  <p>
Будут выбраны все элементы, у которых значение атрибута foo
содержит подстроку bar на любой позиции
</p>
  <p>
Среди трёх элементов:
<pre><code>
<p class="person-name"></p>
<div class="some-person-info"></div>
<span class="date-person"></span>`}
      </pre>
      <p>селектор [class*=&quot;person&quot;] выберет все.</p>
      <p><span className="hl-4">Обратите внимание, что селектор чувствителен к регистру.</span></p>

      <h3>Поиск слов внутри строки: [foo~=&quot;bar&quot;]</h3>
      <p>Такой селектор выберет все элементы, у которых значение атрибута foo содержит слово bar.</p>
      <p>Входить должно именно слово, а не просто подстрока. То есть вхождение bar должно содержать с обеих сторон разделители: пробелы или начало/конец строки.</p>

      <h3>Поиск префиксов: [foo|=&quot;bar&quot;]</h3>
      <p>Селектор по атрибутам вида [foo|=&quot;bar&quot;]</p>
      <p>В данном случае будут выбраны все элементы, у которых значение атрибута foo содержит префикс bar, то есть либо полностью совпадает с bar, либо начинается со строки bar- (наличие знака переноса существенно). Другими словами, используя уже знакомые записи селекторов, этот можно заменить на два:</p>
      <p>1. [foo=&quot;bar&quot;] — все элементы, у которых значение атрибута foo полностью совпадает со значением bar.</p>
      <p>2. [foo^=&quot;bar-&quot;] — все элементы, у которых значение атрибута foo начинается со значения bar-.</p>

      <h3>Псевдоклассы :enabled и :disabled</h3>
      <p>Для обращения к элементам, которые являются доступными на сайте (не заблокированными), можно использовать псевдокласс :enabled. Заблокированными считаются элементы форм, у которых установлен атрибут disabled.</p>
      <pre>{`input:enabled {
  /* какие-то стили */
}`}
      </pre>

      <h3>Псевдоклассы :read-only и :read-write</h3>
      <p>Как мы уже рассматривали в предыдущих курсах, есть разные способы запретить редактирование пользователем полей. Одним из таковых является установка атрибута readonly. Значение в данном случае доступно для чтения и копирования, но недоступно для редактирования.</p>
      <p>Селектор :read-write выберет все поля доступные для редактирования.</p>
      <p>Селектор :read-only выберет все поля доступные только для чтения.</p>
      <pre>{`input[readonly] {} /* аналог :read-only */
input:not([readonly]) {} /* аналог :read-write */`}
      </pre>
      <p><span className="hl-2">Однако, обратите внимание, что input:not([readonly]) помимо доступных для редактирования текстовых полей выберет кнопки и другие нетекстовые поля input, например, input[type=&quot;submit&quot;].</span></p>
      <p>На момент написания главы псевдоклассы :read-write и :read-only в браузере Mozilla Firefox работают только с префиксом -moz-. Для прохождения задания в Firefox используйте псевдоклассы :-moz-read-only и :-moz-read-write.</p>

      <h3>Псевдокласс :required</h3>
      <p>Используя селектор :required можно задать отдельные стили для обязательных полей</p>

      <h3>Псевдокласс :optional</h3>
      <p>Помимо :required существует селектор :optional, выполняющий обратное действие. То есть выберутся все элементы, у которых НЕ указан атрибут required.</p>

      <h3>Псевдокласс :checked</h3>
      <p>При помощи селектора :checked можно обратиться ко всем элементам input с типами checkbox или radio, которые являются выбранными (отмеченными).</p>

      <h3>Псевдоклассы :invalid и :valid</h3>
      <p>При помощи разных типов полей (email, url и др.) или специфических настроек (pattern, min/max и др.) можно указать браузеру, какие именно данные мы ожидаем от пользователя в том или ином поле.</p>
      <p>Селектор :valid выберет все элементы, у которых введенное значение удовлетворяет требованиям.</p>
      <p>А селектор :invalid соответственно выберет элементы, у которых введенное значение некорректно.</p>
      <pre>{'input:invalid { }'}
      </pre>

      <h3>Псевдоклассы :in-range и :out-of-range</h3>
      <p>Селектор :in-range выбирает все элементы, значение которых попадает в указанный диапазон.</p>
      <p>А селектор :out-of-range выбирает все элементы, значение которых НЕ попадает в указанный диапазон.</p>

      <h3>Объединяй и властвуй</h3>
      <pre>{'input[type="checkbox"]:required:checked {}'}
      </pre>
      <p>В данном примере будут выбраны все чекбоксы, которые являются обязательными для заполнения и отмечены галочкой</p>
      <p>Благодаря селектору :checked, с помощью чистого CSS можно создавать очень много интересных эффектов, так как мы можем не просто выбирать отмеченные поля форм, но и влиять с помощью этих полей на другие элементы.</p>
      <p>Для этого нам нужно комбинировать :checked и ~, который позволяет выбрать все элементы, идущие за отмеченным полем. Пример:</p>
      <pre>{`input:checked ~ .item {
  color: red;
}`}
      </pre>
      <p>Такое CSS-правило задаст красный цвет, всем элементам с классом item, расположенным после отмеченного поля.</p>
      <p>С помощью этого приёма, например, делают переключающиеся вкладки, которые работают без JavaScript.</p>

      <h3>Испытание: UI-кит для формы</h3>
      <p>В этом задании вы создадите простой набор стилей для полей форм, или User Interface кит.</p>
      <p>Ваша задача — подобрать недостающие селекторы, чтобы этот интерфейс выглядел так, как в образце.</p>
      <p>Сами по себе поля форм стилизуются очень тяжело. Но поля можно спрятать, а их состояние передавать в соседние label, задавая подписям разные фоны или другие стили в зависимости от состояния полей. То есть внешний вид поля рисуется внутри label, иногда с помощью псевдоэлементов.</p>
      <p>Вот пример набора селекторов для стилизации радиобаттона:</p>
      <pre>{`input[type=radio] + label {...}
input[type=radio]:checked + label {...}
input[type=radio]:disabled + label {...}`}
      </pre>
      <p>Подсказки:</p>
      <p>в одном селекторе может группироваться несколько через запятую;</p>
      <p>при стилизации в некоторых элементах были использованы псевдоэлементы.</p>
    </section>
  );
}

export default Selectors;
