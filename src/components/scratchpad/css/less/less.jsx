import React from 'react';

function Less() {

  return (
    <section className="conspect">
      <h1>Препроцессор Less и автоматизация</h1>
      <p>CSS-препроцессоры — это «программистский» подход к CSS. Они позволяют при написании стилей использовать свойственные языкам программирования приёмы и конструкции: переменные, вложенность, наследуемость, циклы, функции и математические операции. Синтаксис препроцессоров похож на обычный CSS. Код, написанный на языке препроцессора, не используется прямо в браузере, а преобразуется в чистый CSS-код с помощью специальных библиотек.</p>
      <p>Три самых известных препроцессора — это Less, SASS и Stylus. Они во многом похожи между собой, но имеют и ключевые различия.</p>
      <p>Препроцессор позволяет использовать компонентный подход. Компонентный подход позволяет структурировать большие объёмы кода и легко масштабировать проекты. Из компонентов можно собирать цельные интерфейсы.</p>

      <h2>Подключение</h2>
      <p><a href="https://lesstester.com/" target="_blank" rel="noopener noreferrer">Компилятор less в css</a></p>
      <p><a href="https://lesscss.org/" target="_blank" rel="noopener noreferrer">Инструкция подключения на сайте less</a></p>
      <p>Подключение в CSS. Импортировать можно только в начале файла стилей.</p>
      <pre>{`/* style.css */
@import "normalize.css";

body {
  background-color: tomato;
}

/* normalize.css */
body {
  margin: 0;
  }`}
      </pre>
      <p>Подключение в Less. Импортировать можно где угодно.</p>
      <pre>{`/* style.less */
  @import "normalize.less";
  body {
    background-color: tomato;
  }

  /* normalize.less */
  body {
    margin: 0;
  }`}
      </pre>
      <p>Препроцессоры склеивают файлы style и normalize. В браузере работает только CSS, препроцессоров там нет.</p>

      <h2>Переменные</h2>
      <h3>Переменные в CSS</h3>
      <pre>{`/* CSS */
html {
    --fancy-color: tomato;
}
body {
    color: var(--fancy-color);
}

Видимость в CSS
/* CSS */
p {
    --fancy-color: tomato;
}
em {
    color: var(--fancy-color);
}
/* HTML */
<p><em>Я томат</em></p>
<p></p>
<em>А я нет</em>`}
      </pre>
      <h3>Переменные в Less</h3>
      <p>Создав переменную один раз, можно использовать её в любом месте кода. Так что если нужно изменить цвет, который указан во многих местах, достаточно изменить переменную.</p>
      <pre>{`/* LESS */
@fancy-color: tomato;
body {
  color: @fancy-color;
}
/* CSS */
body {
  color: tomato;
}

Видимость в Less
p {
  @fancy-color: tomato;
}
em {
  color: @fancy-color;
}
p {
  @fancy-color: tomato;
em {
  color: @fancy-color;
  }
}`}
      </pre>
      <p>Простая замена псевдонимов на значения. Происходит только один раз во время сборки.  Для тем нужно собирать отдельные файлы.</p>
      <p>Переменные можно объявлять как «снаружи» правил, так и «внутри». В случае «внутреннего» объявления переменная будет доступна только внутри правила, в котором она объявлена:</p>
      <pre>{`.rule-1 {
  @align: right;
  text-align: @align; // text-align задаётся значение right
}
.rule-2 {
  text-align: @align; // в этом месте произойдёт ошибка
}`}
      </pre>
      <div className="warn">Если переменная объявлена и «внутри» правила, и «снаружи» — Less применит «внутреннее» значение. То есть её можно переопределить в только конкретном месте. Таким образом можно «переопределять» глобальные переменные в локальном контексте.</div>
      <pre>{`@align: left;

.rule-1 {
  @align: right;
  text-align: @align; // text-align задаётся значение right
}

.rule-2 {
  text-align: @align; // text-align задаётся значение left
}`}
      </pre>

      <h2>Интерполяция</h2>
      <p>Интерполяция переменных. То есть переменные можно склеивать со строками - и с названием селектора, и со значениями стилей. Это как писать ребус, не рекомендовано к использованию в простых проектах.</p>
      <pre>{`@where: bottom;
.no-@{where} {
    border-@{where}: none;
}

Результат интерполяции

.no-bottom {
    border-bottom : none;
}

Математические операции в CSS
--body-font-size

html {
    --body-font-size: 16px;
}
body {
    margin-left: calc(-10px * 2);
    font-size: calc(var( ) * 1.25);
}`}
      </pre>
      <p>Рассчитываются вживую, прямо в браузере. Можно использовать относительные единицы: % , em , vw .</p>

      <h2>Цветовые функции</h2>
      <p>Цветовая схема — основа любого дизайна в вебе. Вынос всех цветов в переменные — очень прагматичный подход. Переменные можно легко собрать в одном файле, что позволяет гибко конфигурировать внешний вид базовых компонентов. При этом цвета всех элементов будут консистентны и их можно легко конфигурировать.</p>
      <h3>Операции с цветами в CSS</h3>
      <pre>{`body {
  color: #302682;
  color: rgba(47, 38, 130, 0.5);
  color: hsla(246, 55%, 33%, 0.5);
  }`}
      </pre>
      <p>HSL — Hue, Saturation, Lightness (оттенок, насыщенность, светлость). a - альфа-канал, который является термином из графического дизайна означающим прозрачность.</p>

      <h3>Операции с цветами в Less</h3>
      <pre>{`body {
  color: fade(#302682, 50%);
  color: desaturate(#302682, 30%);
  color: lighten(#302682, 20%);
  }`}
      </pre>
      <p>Рассчитывается финальное значение в HEX. Широкий набор функций по настройке цветов.</p>

      <h3>Комплементарные цвета на цветовом колесе</h3>
      <p>Все цвета модели RGB можно расположить на цветовом колесе, где они плавно переходят друг в друга. Противоположный цвет на колесе называется комплементарным. Он находится под углом 180° к заданному цвету. Комплементарные цвета используют для создания контраста.</p>
      <p>С помощью Less-функции spin можно повернуть цветовое колесо на определённый угол относительно заданного цвета и получить новый цвет. Функция принимает два параметра, синтаксис её такой:</p>
      <pre>{'spin(цвет, угол_поворота)'}</pre>
      <p>Цвет можно задавать в любом цветовом формате. Значение угла может быть как положительным, так и отрицательным. При положительном угле функция повернёт колесо по часовой стрелке, при отрицательном — против. Примеры:</p>
      <pre>{`color: spin(red, 90); // цвет повернётся от красного на 90° по часовой
border-color: spin(#f0f, -45); // цвет на 45° от #f0f против часовой`}
      </pre>
      <p>Less-функции для работы с цветом:</p>
      <ul>
        <li><span className="hl-6">lighten/darken</span></li>
        <li><span className="hl-7">saturate/desaturate</span> - увеличивают и уменьшают насыщенность заданного цвета</li>
      </ul>
      <pre>{`color: saturate(green, 20%); // green насыщеннее на 20%
color: desaturate(blue, 50%); // blue бледнее на 50%`}
      </pre>
      <p>То есть функции можно «вкладывать» друг в друга, используя их в качестве аргументов.</p>

      <h2>Вложенные правила</h2>
      <p>Они позволяют избавиться от дублирования одинаковых названий в коде и делают его более структурированным. Например, вот такой код:</p>
      <pre>{`.super-class-name {
  color: #ffffff;
}

.super-class-name a {
  text-decoration: none;
}

.super-class-name a span {
  font-size: 1em;
}`}
      </pre>
      <p>можно более кратко и без повторов написать, используя вложенность:</p>
      <pre>{`.super-class-name {
  color: #ffffff;

  a {
    text-decoration: none;
    span {
      font-size: 1em;
    }
  }
}`}
      </pre>
      <p>То есть вложенные правила просто пишутся внутри других правил. Из цепочек вложенных правил Less сам составляет итоговые селекторы.</p>
      <p>С помощью вложенных правил можно не только обращаться к дочерним элементам, но и составлять по частям комплексные названия классов. Например, следующий код:</p>
      <pre>{`.super-button-red {
  color: red;
}

.super-button-blue {
  color: blue;
}`}
      </pre>
      <p>можно записать проще c помощью вложенных правил:</p>
      <pre>{`.super-button {
  &-red { color: red; }

  &-blue { color: blue; }
}`}
      </pre>
      <p>То есть, если перед вложенным правилом поставить амперсанд &, то оно станет родственным родительскому, и Less подставит родительский селектор вместо амперсанда.</p>

      <h3>Псевдоклассы.link</h3>
      <pre>{`.link{
      color: tomato;
      &:hover,
      &:focus {
          color: plum;
      }
  }

  Преобразуется в:
  .link{
      color: tomato;
  }
  .link:hover,
  .link:focus {
      width: 500px;
  }`}
      </pre>
      <h3>Псевдоэлементы</h3>
      <pre>{`.item {
      color: tomato;
      &::before {
          content: "—";
      }
  }

  Преобразуется в:
  .item {
      color: tomato;
  }
  .item::before {
      content: "—";
  }`}
      </pre>
      <h3>Модификаторы</h3>
      <pre>{`.button{
      width: 100px;
      &--wide {
          width: 500px;
      }
  }

  Преобразуется в:
  .button{
      width: 100px;
      }
  .button--wide {
      width: 500px;
  }`}
      </pre>
      <p>Элементы - не использовать. Чтобы не разрушать структуру именования блока.</p>
      <pre>{`.button {
      color: tomato;
      &__icon {
          width: 16px;
      }
  }

  Преобразуется в:
  .button {
      color: tomato;
  }
  .button__icon {
      width: 16px;
  }`}
      </pre>
      <p className="hl-2">Нежелательно вкладывать больше двух и только со знаком &</p>
      <h3>Вложенность медиавыражений</h3>
      <pre>{`.block {
      color: tomato;
      @media (min-width: 768px) {
          color: wheat;
  }
  @media (min-width: 1200px) {
      color: plum;
      }
  }

  Преобразуется в:

  .block {
        color: tomato;
  }
  @media (min-width: 768px) {
  .block {
      color: wheat;
  }
  }
  @media (min-width: 1200px) {
  .block {
      color: plum;
      }
  }`}
      </pre>

      <h2>Математические операции в Less</h2>
      <p>Над любыми численными значениями в Less-коде можно произвести математические операции сложения, вычитания, умножения или деления:</p>
      <pre>{`padding-top: 10px + 20; // = 30px
padding-bottom: 100px - 50; // = 50px
font-size: 2em * 2; // = 4em
left: 50% / 2; // 25%

@body-font-size: 16px;
  body {
  margin-left: -10px * 2;
  font-size: @body-font-size * 1.25;
}`}
      </pre>
      <p>Less выполнит математическую операцию и вернёт в CSS уже вычисленное значение. Единицы измерения всегда берутся от первого параметра в выражении. Не нужна функция calc. Рассчитываются только один раз во время сборки. Ничего не знают про относительные единицы % , em , vw . Будьте осторожны при сложении разных единиц. Осторожней с гридами - Less считает координаты ячеек.</p>
      <p>Кстати, к значению цвета «целиком» тоже можно применять операции. В случае суммы числа и RGB-записи цвета слагаемое будет прибавляться к каждому цветовому каналу одновременно:</p>
      <pre>{`rgb(10, 10, 10) + 10

// то же самое, что

rgb(20, 20, 20)`}
      </pre>

      <h2>Миксины (примеси)</h2>
      <p>Мы можем «примешивать» содержимое одного CSS-правила в другое. Для этого нужно написать имя «примешиваемого» правила внутри другого правила. Рассмотрим пример:</p>
      <pre>{`Less.white { color: white; } /* объявление примеси */
.text { .white; }    /* применение примеси */
Этот Less-код скомпилируется в такой CSS:

CSS.white { color: white; }
.text { color: white; }`}
      </pre>
      <p>Как мы видим, в правиле, где была «вызвана» примесь .white, появилось её содержимое.</p>
      <p>Чтобы не выводить саму примесь в CSS, нужно после объявления примеси поставить скобки:</p>
      <pre>{`Less.white() { color: white; } /* объявление невыводимой примеси */
.text { .white; }      /* применение примеси */
CSS.text { color: white; }`}
      </pre>
      <p>При применении примеси скобки писать необязательно.</p>
      <pre>{`Less/* Эти выражения дают один и тот же результат: */
.mixin();
.mixin;`}
      </pre>
      <p>К одному правилу можно применить несколько примесей одновременно. В таком случае примеси просто «вызываются» по очереди. Например:</p>
      <pre>{`Less.big() {
  width: 100500px;
}

.white() {
  color: white;
}

.block {
  .big();
  .white();
}
CSS.block {
  width: 100500px;
  color: white;
}`}
      </pre>
      <pre>{`.heading() {
      margin-bottom: 16px;
      font-size: 32px;
  }
  или такая примесь:
  .clearfix() {
      &::after {
          display: table;
          clear: both;
          content: "";
      }
  }

  Используем в коде:

  .title {
  color: tomato;
  .heading();
  .clearfix();
  }`}
      </pre>
      <p>Свойства, прописанные в примесях применятся к title. Удобно записать туда какие-нибудь повторяющиеся свойства, а потом вызывать их по надобности(одинаковые отступы, цвет, позиционирование).</p>

      <h3>Примесь с параметром</h3>
      <p>В примесь можно передавать параметры. Они указываются внутри скобок объявления примесей. Названия параметров начинаются с символа @. Рассмотрим пример:</p>
      <pre>{`Less:
.margin(@value) {
  margin-top: @value;
  margin-bottom: @value;
}

.block {
  .margin(10px);
}
CSS:
.block {
  margin-top: 10px;
  margin-bottom: 10px;
}`}
      </pre>
      <p>Параметры позволяют сделать примеси более универсальными.</p>
      <p>Параметризованные примеси удобны, когда над разными элементами нужно провести однотипные действия с отличающимися результатами.</p>
      <pre>{`.size(@width: 50px, @height: 50px) {
      width: @width;
      height: @height;
  }
  .square {
      .size(100px, 100px);
  }`}
      </pre>
      <p>То есть в size можно передавать любые нужные значения. Расширения - лучше не использовать. Могут убить производительность сайта.</p>

      <h3>Значение параметра примеси по умолчанию</h3>
      <p>Параметризованные примеси можно сделать ещё универсальнее.</p>
      <p>Параметру примеси можно задать значение по умолчанию. Оно указывается через двоеточие после названия параметра. Если в примесь при применении параметр не передаётся, то используется значение по умолчанию.</p>
      <p>Рассмотрим пример, в котором значение параметра по умолчанию указано, но не задействуется, так как в примесь передаётся явный параметр.</p>
      <pre>{`Less.big(@size: 100500px) {
  width: @size;
}

.block {
  .big(10px);
}
CSS.block {
  width: 10px;
}`}
      </pre>
      <p>В следующем примере примесь применяется без параметров, поэтому используется значение по умолчанию:</p>
      <pre>{`Less.big(@size: 100500px) {
  width: @size;
}

.block {
  .big();
}
CSS.block {
  width: 100500px;
}`}
      </pre>

      <h3>Примесь с несколькими параметрами</h3>
      <p>В примесь можно передавать несколько параметров. Параметры перечисляются через запятую , или через точку с запятой ;. Рекомендуется использовать точку с запятой. Пример:</p>
      <pre>{`Less.offset(@padding; @margin) {
  padding: @padding;
  margin: @margin;
}

.block {
  .offset(5px; 10px);
}
CSS.block {
  padding: 5px;
  margin: 10px;
}`}
      </pre>
      <h3>Шаблоны примесей</h3>
      <p>Иногда бывает полезным изменить поведение примеси в зависимости от передаваемых параметров. Например, у нас есть примесь, задающая размер шрифта:</p>
      <pre>{`Less.set-font-size(@size) {
  font-size: @size;
}`}
      </pre>
      <p>Мы можем создать ещё одну примесь с таким же названием, но передать дополнительно первым параметром название шаблона этой примеси. Имя шаблона указывается первым перед параметрами самой примеси. Добавим примеси дополнительный первый параметр smaller и немного изменим принцип её работы:</p>
      <pre>{`Less.set-font-size(smaller; @size) {
  font-size: @size / 2;
}`}
      </pre>
      <p>Теперь можно вызывать эту примесь с названием шаблона и без него и, в зависимости от этого, получать соответствующие результаты:</p>
      <pre>{`Less.text {
  .set-font-size(100px);
}

.small-text {
  .set-font-size(smaller; 100px);
}
CSS.text {
  font-size: 100px;
}

.small-text {
  font-size: 50px;
}`}
      </pre>
      <p>Таким образом можно для схожих действий не создавать несколько примесей с разными названиями. Лучше делать шаблоны одной примеси и просто вызывать её с дополнительным параметром.</p>
      <p>Основное предназначение примесей — выделять повторяющийся код в отдельные блоки для последующего использования. Чем меньше дублируется код, тем его меньше. А чем меньше кода, тем ниже вероятность ошибок в нём.</p>
      <p>Если нужно задать общие свойства для нескольких шаблонов одной и той же примеси, можно создать универсальный шаблон:</p>
      <pre>{`Less.font-size(bigger; @size)  {
  font-size: @size * 2;
}

.font-size(smaller; @size) {
  font-size: @size / 2;
}

.font-size(@_; @size) {
  color: #000000;
} // универсальный шаблон

.content-bigger {
  .font-size(bigger; 20px);
}

.content-smaller {
  .font-size(smaller; 20px);
}`}
      </pre>
      <p>Универсальный шаблон применяется вместе с остальными шаблонами:</p>
      <pre>{`CSS.content-bigger {
  font-size: 40px;
  color: #000000;
}

.content-smaller {
  font-size: 10px;
  color: #000000;
}`}
      </pre>
      <p>В качестве имени в универсальный шаблон передаётся специальная переменная @_, за ней следуют параметры. Важно, чтобы универсальный шаблон принимал те же параметры, что и все остальные шаблоны.</p>
      <h3>Примесь с условием</h3>
      <p>В примесях можно использовать полноценные условия, которые могут изменять поведение примеси в зависимости от значений входных параметров.</p>
      <p>Чтобы создать условие, нужно после названия примеси поставить ключевое слово when, за которым в скобках написать условную конструкцию. Пример:</p>
      <pre>{`Less.mixin(@variable) when (@variable = 1) {
  // сделать что-то
}`}
      </pre>
      <p>Такая примесь применится, если «вызвать» её с параметром 1. В противном случае примесь не применится.</p>
      <pre>{`Less.some-class {
  .mixin(1);
}`}
      </pre>
      <p>В условной конструкции допускаются следующие операторы: &gt;, &gt;=, =, =&lt;, &lt;. Также допустимо использовать встроенные функции Less, которые возвращают конкретные значения.</p>
      <p>К примеру, в Less есть встроенная функция lightness, которая принимает в качестве параметра значение цвета и возвращает степень его светлоты. Чёрный цвет обладает 0% светлоты, а белый — 100%. Вот пример её использования:</p>
      <pre>{`Less.mixin(@color) when (lightness(@color) > 50%) {
  // сделать что-то, когда цвет светлее серого
}

.mixin(@color) when (lightness(@color) = 100%) {
  // сделать что-то, когда цвет полностью белый
}`}
      </pre>
      <p>Можно создать несколько примесей с одинаковыми названиями, но разными условиями. Тогда применяться будут только те примеси, условия которых выполняются.</p>

      <h2>Условия и внешние переменные</h2>
      <p>Условия в примесях могут работать не только с параметрами, с которыми «вызвана» примесь, но и с переменными, объявленными вне примесей. Например, если создать примесь с условием, но без параметров:</p>
      <pre>{`Less.text-color() when (@theme = light) {
  color: white;
}`}
      </pre>
      <p>А потом создать внешнюю переменную и вызвать где-то примесь:</p>
      <pre>{`Less@theme: light;

.content {
  .text-color();
}`}
      </pre>
      <p>То условие выполнится, созданная примесь отработает:</p>
      <pre>{`CSS.content {
  color: white;
}`}
      </pre>
      <p>То есть можно управлять условиями примесей с помощью внешних переменных.</p>

      <h3>Условия и типы параметров</h3>
      <p>В Less есть встроенные функции для проверки типа значения. Их можно применять в условиях примесей для проверки типа переданного параметра. Пример:</p>
      <pre>{`Less// проверка: значение — цвет
.mixin(@param) when (iscolor(@param)) { … }

// проверка: значение — число
.mixin(@param) when (isnumber(@param)) { … }

// проверка: значение — строка
.mixin(@param) when (isstring(@param)) { … }

// проверка: значение — ключевое слово
.mixin(@param) when (iskeyword(@param)) { … }

// проверка: значение — url
.mixin(@param) when (isurl(@param)) { … }`}
      </pre>
      <p>Все эти функции возвращают true, если переданный в них параметр соответствует проверяемому типу.</p>
      <p>Таким образом можно создать универсальную примесь, которая в зависимости от типа переданных параметров будет работать по-разному.</p>

      <h2>Переменные-вставки</h2>
      <p>Переменные можно использовать не только в значениях CSS-свойств, но и как составные части селекторов, названий свойств или как «кусочки» значений свойств. С помощью такой подстановки переменных, или Variable Interpolation, можно динамически формировать разные части CSS-правил.</p>
      <p>Чтобы сделать подстановку значения переменной, нужно использовать фигурные скобки вокруг её имени:</p>
      <pre>{`Less@state: success;
@property: color;
@icon: "question";
@pixels: 2;

.btn-@{state} {
  background-color: green;
}
.btn-error {
  background-@{property}: red;
}
.btn-help {
  background-image: url("/img/icons/@{icon}.png");
}
.btn-info {
  border: ~"@{pixels}px" solid blue;
}`}
      </pre>
      <p>Из примеров выше скомпилируется такой CSS:</p>
      <pre>{`CSS.btn-success {
  background-color: green;
}

.btn-error {
  background-color: red;
}
.btn-help {
  background-image: url("/img/icons/question.png");
}
.btn-info {
  border: 2px solid blue;
}`}
      </pre>
      <p>Кстати, тильда ~ в примере выше нужна для хитрого механизма экранирования Less. Без неё «склеивание» переменной и единицы измерения не сработает.</p>
      <p>С помощью «переменных-вставок» можно формировать имена селекторов динамически в зависимости от определённых условий или в цикле.</p>

      <h2>Цикл</h2>
      <p>В Less нет специального синтаксиса для циклов. Но есть возможность вызывать примеси внутри самих себя. Так с помощью рекурсии и реализуются циклы. Рассмотрим пример:</p>
      <pre>{`Less.mixin(@n) {
  .mixin(@n + 1);
}

.mixin(1);`}
      </pre>
      <p>В примере создаётся «бесконечный» цикл с увеличивающейся переменной-счётчиком, который никогда не закончится. Чтобы рекурсия всё-таки когда-нибудь прекращалась, к примеси добавляется условие выполнения:</p>
      <pre>{`Less.mixin(@n) when (@n > 0) {
   .mixin(@n - 1);
}

.mixin(2);`}
      </pre>
      <p>Теперь цикл выполнится два раза, сработает условие выполнения примеси и произойдёт выход из рекурсии.</p>
      <p>Для чего можно применять циклы? Например, для генерирования целых CSS-правил. Если в цикле в имени селектора использовать переменную-вставку из прошлого задания, то можно на выходе получить набор правил с разными селекторами. В примере ниже цикл исполняется три раза, в каждой итерации создастся правило с переменной-счётчиком @n в качестве суффикса селектора:</p>
      <pre>{`Less.mixin(@n) when (@n > 0) {
  .text-@{n} {
  }

  .mixin(@n - 1);
}

.mixin(3);
CSS.text-3 {}
.text-2 {}
.text-1 {}`}
      </pre>
      <p>Внутри «цикла» переменную-счётчик можно использовать не только в условиях или в селекторах, но и в значениях свойств.</p>
      <p><a href="examples/less/vertical-rhythm-text/index.html" target="_blank" rel="noopener noreferrer">Вертикальный ритм текста</a></p>
      <p><a href="examples/less/triangle-form/index.html" target="_blank" rel="noopener noreferrer">Примесь для треугольных форм</a></p>

      <h2>Компиляция с использованием системы сборки</h2>
      <p><strong>Система сборки</strong> — это инструмент для автоматической, гибкой и удобной сборки проектов из командной строки с использованием ранее обозначенных инструкций (задач).</p>
      <p>Это инструмент, который автоматически преобразует проект в соответствии с заранее написанными правилами.</p>
      <p>gulp - простой и популярный сборщик модулей(файлов)</p>

      <h3>Приложения для компиляции</h3>
      <p>Вот он, самый простой и удобный способ для проектов, использующих препроцессоры, причём не только CSS-препроцессоры, но и JS и HTML.</p>
      <p>Существуют такие приложения, которые позволяют управлять проектами без написания кода, использования командной строки и систем сборок. Они написаны для людей, желающих делать своё дело и не вникать в некоторые тонкости, хотя бы на начальном этапе своей карьеры.</p>
      <p>Такие приложения имеют довольно обширный функционал и, как правило, умеют:</p>
      <ul>
        <li>Компилировать файлы различных препроцессоров (Less, Stylus, Jade, CoffeeScript и т.д.);</li>
        <li>Проверять файлы на ошибки и соответствие правилам (общим или проекта);</li>
        <li>Обрабатывать файлы (минификация, расстановка префиксов в CSS и т.д.);</li>
        <li>Автоматизировать некоторые часто используемые действия;</li>
        <li>Локальный сервер для тестирования проектов на этапе разработки;</li>
      </ul>

      <h3>Карта кода (Source Maps)</h3>
      <p>Нужна для того, чтобы отладчик кода верно указывал строки кода css - в less-файле строк меньше.</p>

      <h2>Рекомендации</h2>
      <p className="hl-5">Для каждого блока — отдельный файл стилей</p>
      <p className="hl-4">Не создавайте вложенность больше двух уровней</p>
      <p className="hl-10">Не используйте цветовые функции для получения цветов из дизайна. Если нет прозрачности или другого эффекта в макете, а указан конкретный hex-цвет, то используем его.</p>
      <p className="hl-9">Не используйте расширения, совсем</p>
      <p className="hl-8">Не используйте сразу всё, пробуйте постепенно</p>

      <h3>Автоматизация</h3>
      <p>Так будут распологаться стилизационные блоки для сайта в папке source.</p>
      <pre>{`img/
  fonts/
  less/
    blocks/
      main-nav.less
      page-main.less
    style.less
    mixins.less
    variables.less`}
      </pre>
      <p className="hl-7"></p>
      <p className="hl-6"></p>
    </section>
  );
}
export default Less;
