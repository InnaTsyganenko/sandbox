import React from 'react';

function Text() {

  const IndentedText = {
    fontSize: '26px',
    textShadow:`
      1px 1px 1px #111111,
      2px 2px 2px #222222`,
  };

  const IndentedText2 = {
    fontSize: '26px',
    textShadow:`
      1px 1px 1px rgb(46, 46, 46),
      3px 2px 2px rgba(219, 193, 193, 0.726)`,
  };

  return (
    <section className="conspect">
      <h1>Work with text</h1>
      <h2>Свойство text-align</h2>
      <p>Выравнивает текст и другие инлайновые элементы (изображения, инлайн-блоки, инлайн-таблицы и другие) внутри блока по горизонтали.Свойство может принимать следующие значения:</p>
      <ul>
        <li>left — выравнивание по левому краю блока, это значение по умолчанию;</li>
        <li>right — по правому краю блока;</li>
        <li>center — по центру блока;</li>
        <li>justify — по ширине блока, при этом слова в строке будут размещаться так, чтобы занять равномерно всё пространство строки (пробелы между словами в таком случае становятся неравномерными, так как браузер «растягивает» слова в строке).</li>
      </ul>
      <p>Важно помнить, что свойство text-align применяется именно к самому блоку-контейнеру, внутри которого находится текстовый контент.</p>
      <p>существует ещё два значения text-align: это выравнивание к началу блока start и выравнивание к концу блока end. Если вы попробуете применить эти значения, то увидите, что эффект от значения start совпадает со значением left, а end делает то же самое, что и right.</p>
      <p>Но это не всегда так. Дело в том, что не во всех языках текст пишется слева направо. Например, в японском текст пишется сверху вниз, и в этом случае значения left и right уже не так логичны, как в «европейских» языках. Именно чтобы сделать CSS-код универсальным для любых направлений написания текста и появились такие значения text-align. Кстати, для управления направлением текста есть специальное свойство — writing-mode.</p>
      <p>Свойство text-align способно влиять не только на тексты, но и другие элементы. Эти элементы должны быть инлайновыми, то есть это изображения, инлайн-блоки, инлайн-таблицы и другие.</p>

      <h2>Свойство vertical-align</h2>
      <ul>
        <li>top — выравнивание по верхнему краю строки;</li>
        <li>middle — по середине строки;</li>
        <li>bottom — по нижнему краю строки;</li>
        <li>baseline — по базовой линии строки (значение по умолчанию).</li>
      </ul>
      <p>В отличие от text-align свойство vertical-align задаётся самому элементу, а не содержащему его контейнеру.</p>
      <p>Процентное значение (например, vertical-align: 100%) вычисляется относительно заданной высоты строки line-height. Значение 0% — это то же самое, что и baseline, а ещё оно может быть как положительным, так и отрицательным.</p>
      <p>Значение в пикселях (например, vertical-align: 10px) работает аналогично процентному, только отсчитывается в пикселях в большую или меньшую сторону. Значение 0px эквивалентно baseline.</p>

      <h2>Свойство color, цвет текста</h2>
      <h3>Контраст цвета текста и фона</h3>
      <p>Фоновое изображение и фоновый цвет блока всегда должен достаточно сильно контрастировать с цветом текста в этом блоке. Чем больше контраст, тем удобнее этот текст читать в разных условиях освещённости и на разных устройствах. Поэтому если вы задаёте блоку фоновое изображение, нужно обязательно дополнительно задавать подходящий фоновый цвет. В этом случае, пока изображение загружается, или в случае, если оно совсем не загрузится, текст всё равно можно будет прочитать.</p>

      <h2>Свойство white-space, управление пробелами</h2>
      <p>Браузер игнорирует множественные пробелы и переносы строк в HTML-коде.</p>
      <ul>
        <li>nowrap — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;</li>
        <li>pre — сохраняет пробелы и переносы как в исходном коде аналогично тегу <code>&lt;pre&gt;</code>;</li>
        <li>pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;</li>
        <li>normal — режим по умолчанию: лишние пробелы и переносы строк схлопываются, текст переносится, пробелы в конце строк удаляются.</li>
        <li>break-spaces — поведение идентично pre-wrap, но при схлопывании пробелов остаются нетронутыми зарезервированные пробелы, такие как пробелы в конце строки;</li>
        <li>pre-line — как normal, лишние пробелы схлопываются, но строки переносятся на символе переноса строки, на <code>&lt;br&gt;</code> и по мере заполнения строки.</li>
      </ul>

      <h2>Свойство text-decoration: text-decoration-line text-decoration-style text-decoration-color</h2>
      <ol>
        <li>underline — подчёркивание;</li>
        <li>line-through — зачёркивание;</li>
        <li>overline — надчёркивание;</li>
        <li>none — убирает вышеперечисленные эффекты.</li>
      </ol>
      <p>К тексту можно одновременно применить несколько эффектов, если перечислить значения через пробел.</p>

      <h2>Свойство text-transform, регистр символов</h2>
      <ol>
        <li>lowercase — все строчные;</li>
        <li>uppercase — все заглавные;</li>
        <li>capitalize — каждое слово начинается с большой буквы;</li>
        <li>none — отменяет изменение регистра.</li>
      </ol>

      <h2>Свойство text-shadow</h2>
      <ul>
        <li>форма тени повторяет форму текстовых символов;</li>
        <li>можно управлять смещением тени, её цветом, а также размытием;</li>
        <li>нельзя управлять растяжением текстовой тени;</li>
        <li>можно создавать множественные тени.</li>
      </ul>
      <p><code>text-shadow: 0px 0px 0px #333333;</code></p>
      <p className="hl-5">Не рекомендуется использовать слишком сложные стили при настройке text-shadow. Дело в том, что чрезмерное увлечение этим свойством приводит к проблемам с производительностью.</p>

      <h3>Эффект вдавленного текста</h3>
      <p>У текста может быть задано сразу несколько теней. Для этого определения теней нужно перечислить через запятую. При этом тени распределяются по правилу: первая тень в списке — самая верхняя, последняя в списке — самая нижняя.</p>
      <p style={IndentedText}>Ты где-то там, далеко-далеко от меня...</p>

      <h3>Декоративная ретро-тень</h3>
      <p>Ещё один текстовый эффект создаётся из двух резких теней. Тени смещены в одну сторону. Нижняя тень смещена чуть сильнее и её цвет отличается от цвета фона, а верхняя тень смещена слабее и цвет её совпадает с цветом фона. Получается интересный эффект обводки. Такой эффект хорошо подходит для заголовков с винтажным стилем.</p>
      <p style={IndentedText2}>This is some text...</p>

      <h2>Логотип: нестандартный шрифт</h2>
      <p>Помимо букв шрифт может содержать и другие графические символы. Существуют инструменты, позволяющие собрать свой собственный шрифт из SVG-объектов. Их довольно много: icomoon.io/app, fontastic.me, glyphter.com и другие.</p>
      <p>Преимуществом шрифтовых иконок перед растровыми картинками является то, что их легко смасштабировать или перекрасить в другой цвет с помощью CSS-свойств, применимых к тексту. Также на экранах с большой плотностью пикселей шрифт не «замыливается», как это происходит с обычными картинками.</p>

      <h2>letter-spacing, межсимвольное расстояние</h2>
      <p>Браузер по умолчанию устанавливает межсимвольное расстояние автоматически согласно определенному значению у каждого шрифта. Значение по умолчанию соответствует letter-spacing: 0.</p>

      <h2>word-wrap, перенос слова</h2>
      <p>принимает значения: normal и break-word. В случае normal слова переносятся на новую строку по обычным правилам (то есть по пробелам). А при значении break-word перенос производится браузером в тех местах, где слова перестают помещаться в контейнер.</p>
      <p>Также нужно заметить, что свойство word-wrap — изначально проприетарное расширение Microsoft, а в текущем черновике спецификации CSS переименовано в overflow-wrap. Название word-wrap сейчас обозначено как «альтернативное» именование.</p>

      <h2>Свойство text-indent</h2>
      <p>устанавливает отступ для первой строки блока текста. С помощью этого свойства удобно делать красную строку в абзацах.</p>
      <p>Значение свойства может принимать положительное или отрицательное значение, задаётся в px, em, pt или других единицах длины CSS. При задании значения в процентах, отступ первой строки вычисляется в зависимости от ширины блока.</p>

      <h2>Псевдоэлемент ::first-letter</h2>
      <p>позволяющие стилизовать первую букву в слове или первую строку в блоке текста.</p>
      <p>Крупная, отличная от прочих, первая буква блока текста называется буквицей. Исторически буквицей украшали главы и разделы печатных книг и рукописей.</p>

      <h2>Псевдоэлемент ::first-line</h2>
      <p>Первую строку блока текста можно стилизовать при помощи псевдоэлемента ::first-line.</p>

      <h2>Колоночная разметка: свойство column-count</h2>
      <p>Многоколоночная разметка CSS — замечательная возможность, позволяющая разбить блок с текстом на несколько колонок. Обычно очень длинные строки сложно читать: если приходится слишком долго перемещать взгляд с конца одной строки на начало другой, можно легко потерять нужную строку. Чтобы сэкономить место на экране, но при этом сделать текст читабельным, можно разбить один сплошной блок текста на несколько колонок, как это делается в газетах.</p>
      <p>column-count принимает в качестве параметра целое число и делит блок текста на заданное число колонок, равных друг другу по ширине.</p>
      <p>column-width задаёт минимальную желаемую ширину колонки. Если свойство column-count ещё не было задано, браузер автоматически поделит текст на такое количество колонок, чтобы они уместились во всю доступную ширину.</p>
      <p>Следует отметить, что если одиночная строка может включать от 45 до 75 символов, чтобы быть читабельной, то для колонок текста рекомендуется придерживаться ширины, включающей 40-50 символов.</p>
      <p>Между колонками есть промежуток. Рекомендованная ширина промежутка по умолчанию равна 1em. Но она может быть изменена при помощи свойства column-gap. Единицы измерения тоже px, em, pt и другие.</p>

      <h2>Направление текста</h2>
      <p>Ещё одной интересной, но малоиспользуемой возможностью работы с текстом в CSS является управление направлением текста. Обычно эта возможность применяется для корректного отображения арабского языка и иврита, в которых чтение происходит справа налево. В CSS за направление текста отвечает свойство direction, принимающее значения ltr (направление слева направо) и rtl (направление справа налево).</p>
      <p>Однако помимо направления текста свойство direction также влияет на позицию полосы прокрутки в блоке.</p>
      <p>Если попробовать задать для кириллицы или латиницы обратное направление текста (справа налево) direction: rtl;, мы увидим, что текст в блоке выровнялся наоборот, и полоса прокрутки блока сменила своё положение на противоположное. Но при этом сам текст не стал менять своё направление. Это произошло потому, что браузер автоматически задал тексту корректное направление, проанализировав используемые символы Unicode. Чтобы повлиять на это решение браузера существует свойство unicode-bidi, принимающее значения:</p>
      <ul>
        <li>normal — браузер самостоятельно определяет, как ему следует отображать текст на основе используемых символов Unicode;</li>
        <li>embed — переопределяет направление текста, располагая его согласно свойству direction (применяется, когда в блоке текст на двух разнонаправленных языках);</li>
        <li>bidi-override — переопределяет порядок символов в тексте согласно значению direction.</li>
      </ul>
      <p>Также свойство direction влияет на порядок колонок в таблице, меняя его на соответствующее значение.</p>

      <h2>Переполнение текста</h2>
      <p>Ещё одно интересное текстовое свойство — text-overflow. Оно позволяет определить, как будет выглядеть текст, если не поместится в контейнер. Оно принимает разные значения, но универсальными и работающими во всех современных браузерах являются clip и ellipsis.</p>
      <p>Значение clip задано по умолчанию, и при нём текст просто обрезается по размеру контейнера, а при ellipsis — обрезается и к концу строки добавляется многоточие. К сожалению, у этого свойства есть ограничения, которые делают его менее полезным: оно применимо только к однострочным текстам, а также к блокам, значение свойства overflow которых установлено в auto, scroll или hidden.</p>

      <h2>Интервал между словами</h2>
      <p>И, наконец, последнее свойство, которое мы рассмотрим в этой главе, — word-spacing. Оно задаёт расстояние между отдельными словами и строчными элементами. Значение может быть положительное или отрицательное и задаётся в px, em, pt или других единицах измерения CSS.</p>
      <p>Свойство word-spacing также можно использовать для задания отступов между блочно-строчными элементами, а также изображений, ведь изображения тоже являются строчными.</p>

      <h2>Свойство user-select</h2>
      <p>Свойство user-select даёт нам возможность задавать возможность выделения конкретного текста пользователем. Это свойство может оказаться полезным для отключения возможности выделения текста, что может пригодиться для ограничения возможностей пользователя по выделению материалов, расположенных рядом друг с другом. <a href="https://drafts.csswg.org/css-ui-4/#propdef-user-select" target="_blank" rel="noopener noreferrer">Вот стандарт</a>, описывающий user-select.</p>
      <p>Это свойство может принимать следующие значения: none, auto, text, contain, all.</p>

      <h3>Сценарии использования user-select</h3>
      <code>user-select: none;</code>
      <ul>
        <li>чтобы с текстом не выделялась иконка</li>
        <li>чтобы не выделялась label при клике на чекбокс</li>
        <li>Веб-приложения - не должен выделяться текст н кнопках.</li>
      </ul>
      <code>user-select: all;</code>
      <p>Если свойство с таким значением есть у родительского элемента, то весь текст, содержащийся в таком элементе, можно выделить одним щелчком мыши. Это может оказаться полезным для работы с текстовым содержимым, которое должно выделяться целиком.</p>
    </section>
  );
}
export default Text;
