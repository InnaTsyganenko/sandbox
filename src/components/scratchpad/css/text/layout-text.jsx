import React from 'react';

function LayoutText() {

  return (
    <section className="conspect">
      <h1>Layout of text content of pages</h1>
      <p>Если вы верстаете сайт, на котором предполагается много текстов, появляются не только секции и блоки, но и текстовые элементы — цитаты и врезки, подписи и выделенные ссылки. Обычно эти элементы применяются в посте — отдельной новости/публикации.</p>
      <p>В самой запущенной ситуации пост в текстовом плане может состоять из:</p>
      <ul>
        <li>Заголовка (обязательно);</li>
        <li>Подзаголовка;</li>
        <li>Лида (вводный элемент, содержит главную мысль, индексируется как описание материала);</li>
        <li>Собственно текста (обязательно);</li>
        <li>Акцентов внутри текста;</li>
        <li>Цитат и акцентных мыслей;</li>
        <li>Списков;</li>
        <li>Демонстрационных материалов (изображения, схемы, таблицы) с подписями;</li>
        <li>Дополнительной информации по теме (обычно выносится вбок или публикуется на блёклом фоне/более мелко/менее контрастным шрифтом);</li>
        <li>Метаданных (автор, дата, количество просмотров, теги, время чтения);</li>
        <li>Таблиц;</li>
        <li>Колонок;</li>
        <li>Ссылок на другие материалы (зачастую либо под материалом, либо сбоку) и сносок;</li>
        <li>А также формул.</li>
      </ul>
      <p>При этом у каждого элемента могут быть свои дизайнерские решения, например, каждый абзац может начинаться с красной строки (первая строка может иметь увеличенный отступ или наоборот), или у первого абзаца может быть буквица (первая буква значительно крупнее остальных и/или с особенным шрифтом), не говоря уже об остальных элементах.</p>
      <p>Вот основные техники, с помощью которых текст оформляется:</p>
      <ul>
        <li>особенные шрифты;</li>
        <li>изменение текстовых параметров (кегль, цвет, интерлиньяж, трекинг, насыщенность, трансформации…) одного символа или текстового элемента, типографика;</li>
        <li>изменённые отступы или выравнивание иногда могут служить декоративным элементом;</li>
        <li>обводки;</li>
        <li>фоны (и сопутствующее: градиенты, радиусы скругления…);</li>
        <li>графика (как часть контента или как фон);</li>
      </ul>

      <h2>Инлайн и инлайн-блок</h2>
      <p>Тег <code>&lt;p&gt;</code>, в который оборачиваются абзацы, согласно актуальной классификации относится к поточным элементам, ведёт себя как блочный: ему можно приписать отступы, эти отступы будут работать по всем осям, «расталкивая» соседние объекты, а отступы будут схлопываться. Содержимое параграфа — текстовое и строчное.</p>
      <p>Вложенные в параграф строчные элементы (например, <code>&lt;span&gt;</code>, <code>&lt;em&gt;</code> или <code>&lt;strong&gt;</code>) непривычным образом работают с отступами и границами. Отступы по горизонтали применяются обычным образом, а отступы по вертикали — неожиданным.</p>
      <img src="img/text/text-1.png" alt="У ссылки кроме отступов появился полупрозрачный фон, теперь видно, как ведёт себя инлайновый (или строчный) элемент" width="800" />
      <p>Таким образом, вертикальные отступы не должны быть больше интерлиньяжа.</p>
      <p>Способ, превращающий ссылку в блочно-строчный элемент, «расталкивающий» окружение и по вертикали тоже, существует, но он портит интерлиньяж, делает поток текста неравномерным и мешает чтению.</p>
      <pre>{`.post-link {
  display: inline-block;
  padding: 3px 4px;

  color: red;
  text-decoration: none;

  background-color: rgb(223, 223, 223, 0.7);
  border-radius: 6px;
  border: 1px solid #2c2c2c;
}`}
      </pre>
      <img src="img/text/text-2.png" alt="Теперь элемент блочно-строчный, он испортил интерлиньяж и текст плохо выглядит" width="800" />
      <p className="hl-6">Перенос с бордерным фоном на нескольких строках:</p>
      <img src="img/text/text-3.png" alt="Перенос фона с границей на другую строку выглядит ещё показательней" width="800" />
      <p>Сейчас уже есть свойство, позволяющее замыкать декор при каждом переносе. По умолчанию это box-decoration-break: slice;, и оно, как мы видим, «отрезает» декор в конце строки. А box-decoration-break: clone;, соответственно, клонирует для обрыва строки то, как строка открывается. Это свойство имеет свои особенности поддержки, нужно сверяться с CanIUse.</p>
      <img src="img/text/text-4.png" alt="Применили box-decoration-break: clone, выглядит красиво, но визуально разрывает фразу" width="800" />
      <p>Из-за того, что блочно-строчное отображение внутри текста портит интерлиньяж, то область применения довольно сильно ограничена: это однострочные элементы или элементы «типа блоков», которые вынесены отдельно от основного контента. Например, это могут быть кнопки, #теги, иконки или элементы, вынесенные на отдельные строки.</p>
      <img src="img/text/text-5.png" alt="Возможная ситуация удачного применения блочно-строчных элементов" width="800" />
      <p className="hl-7">Вёрстка элемента</p>
      <pre>{`<p class="store">Товары, отмеченные ярлыком <span class="delivery-badge">
      доставка со&nbsp;склада</span>, будут доставлены в день заказа.</p>
.store {
  height: 102px;

  font-family: "Arial", sans-serif;
  font-style: normal;
  font-weight: normal;
  font-size: 20px;
  line-height: 32px;
  text-align: center;
  color: #ffffff;

  background-color: #31384f;
}

.delivery-badge {
  position: relative;
  display: inline-block;
  width: 80px;
  height: 40px;
  margin: 30px 0;
  padding: 10px 0 0 50px;

  font-size: 12px;
  font-weight: bold;
  line-height: 13px;
  text-align: left;
  color: #ffffff;

  background-color: #ff5e62;
  border-radius: 4px;
}

.delivery-badge::before {
  content: url("auto.svg");
  position: absolute;
  width: 33px;
  height: 12px;
  top: 10px;
  left: 10px;

  font-size: 24px;
  line-height: 1em;
}`}
      </pre>
      <p className="hl-1">Не забывайте про display: inline-flex и display: inline-grid</p>
      <p>Преимущества этих типов отображения рассмотрим на примере ссылки-кнопки с иконкой. Иконку для кнопки добавим в разметку с помощью тега <code>&lt;svg&gt;</code>.</p>
      <pre>{`<a href="#" class="button">
  <svg> ... </svg>
  Копировать
</a>

.button svg {
  vertical-align: middle;
}

.button {
  display: inline-flex;
  align-items: center;
}`}
      </pre>
      <img src="img/text/text-6.png" alt="Вертикальное выравнивание в блочно-строчных элементах и строчных флексах" width="800" />

      <h2>Вёрстка для <abbr data-title="Content Management System">CMS</abbr></h2>
      <p>Content Management System, или система управления контентом, — это программное обеспечение, которое позволяет управлять наполнением сайта извне, обычно — совместно (многопользовательски) и в режиме реального времени. Основной функционал CMS — это упрощение процесса работы с содержимым и контроль версий и деятельности пользователей. Иногда CMS — это настолько масштабная программа, что она позволяет также управлять дизайном сайта, интегрировать сервисы сайта с другими системами (например, оплаты через сайт — с бухгалтерскими данными).</p>
      <p>Основная задача CMS — упростить работу с контентом. То есть подразумевается, что с сайтом работают разные люди, и все они публикуют информацию, и это не должно даваться им слишком сложно. Можно представить себе тех, кто будет публиковать контент, как пользователей «дневниковых сервисов»: правил и ограничений должно быть не слишком много, и кодить никто при этом не будет.</p>
      <p>Нужно учесть, что публикация в CMS почти всегда происходит через «визуальный редактор», который позволяет сразу видеть, что именно свёрстано и будет опубликовано, но не подразумевает, что пользователь будет писать код: классы, обёртки и прочее. Многие редакторы и CMS «чистят» код, который в них попадает, удаляя <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> и «лишние» символы. При этом некоторые CMS имеют встроенный инструмент просмотра, как будет выглядеть пост на сайте, а некоторые — нет. Некоторые CMS также позволяют редактировать или добавлять материалы «с лица» сайта, не заходя в админку.</p>
      <p>Как это всё влияет на вёрстку? А так, что те решения, которые мы зачастую используем для вёрстки, потому что они семантичные и прозрачные, здесь просто не будут работать. Пользователи скорее всего не будут вставлять «распорки» и «обёртки», каждый раз прописывать классы элементам и тем более править стили.</p>
      <p>Для CMS подход стилизации по классам практически не работает. Придётся стилизовать по тегам или учитывать возможности визуального редактора, а потом писать инструкцию о том, какая его возможность что означает на сайте.</p>
      <p>Порядок работы с CMS — это сначала настройка самой системы, как она будет работать, какие возможности у неё будут, какие плагины или расширения к системе будут подключены, потом — «натягивание дизайна», то есть собственно работа с тем, чтобы привести обычно очень неприглядный стандартный вид CMS в состояние, близкое к макету. А потом, когда всё готово, приходит человек (не разработчик) и постит текст. И, что важно, к этому тексту должны применяться те стили, которые для него предусмотрены. Раз вёрстка текстов на сайтах с CMS обычно происходит через визуальный редактор, то привязывать стили нужно к тем характеристикам, которые текстовые элементы получают через визуальный редактор. Обычно это теги, иногда в неожиданных сочетаниях.</p>
      <p>Итак, основные особенности, отличающие вёрстку для CMS от вёрстки вообще:</p>
      <ol>
        <li>Хедер и футер — неприкосновенны, идентичны для всех страниц сайта, классы для различения шапки одной страницы от шапки другой страницы не сработают. Классы на body тоже потеряются, стилизуйте без классов.</li>
        <li>Никаких классов для фотографий, форм и контентных элементов! Если без классов вообще никак — они должны быть простыми и утилитарными (про функционал, а не про смысл содержимого).</li>
        <li>Любой блок должен нормально заработать на любой другой странице. Например, если кто-то захочет взять с главной страницы слайдер и поместить его на любую другую страницу — это должно получиться без переписывания кода. Значит, стилизуем не от конкретной страницы, а от самого блока.</li>
        <li>Нельзя делать классы в зависимости от порядка/положения элемента. Например, порядок карточек должно быть можно менять как угодно, количество — тоже.</li>
      </ol>
      <p className="hl-2">Важное правило, которые обязательно нужно выполнять при публикации: Обязательно посмотреть на сайте, что у вас получилось после нажатия кнопки «Опубликовать». Даже если вы редактировали что-то и просто сохраняете изменения, не поленитесь посмотреть на результат. Это спасает от многих глупых ситуаций, вроде неправильной картинки, дважды повторённого абзаца и нелепых опечаток.</p>

      <h2>Основные элементы текста</h2>
      <h3>Заголовки</h3>
      <p>Так или иначе, заголовки длиной больше 100 знаков считаются слишком крупными для веба. Хороший тон — не выходить за 60 знаков. Также считается правильным выделять заголовки достаточно конкретно: заголовок должен контрастировать с основным текстом. Каждый заголовок любого уровня должен быть связан с тем текстом, который он озаглавливает, то есть отступ внизу не должен быть слишком велик. А вот отступ над заголовком стоит увеличить, чтобы отделить смысловые блоки текста и визуально подчеркнуть, что начался следующий участок.</p>
      <p>Бывают ситуации, в которых заголовок, его расшифровка, лид и дополнительная информация могут объединяться в отдельную группу, тогда было бы неплохо обернуть их в тег <code>&lt;header&gt;</code>.</p>
      <img src="img/text/text-14.png" alt="Дата, заголовок и лид могут выступить как семантическая группа" width="800" />
      <p className="hl-9">Вёрстка элемента</p>
      <pre>{`<article class="news">
  <img class="news-picture" src="/img/mariinsky-pic.jpg" alt="Мариинский театр, ярусы, овации">
  <div class="news-content">
    <header class="news-header">
      <time datetime="2013-07-12" class="news-date">12.07.2013</time>
      <h1 class="news-heading">
        230 лет Мариинскому театру в Санкт&#8209;Петербурге
      </h1>
      <p class="news-leading-paragraph">
        В 1783 году «для управления зрелищами и музыкой» утвердили комитет и труппу,
        ещё через полгода труппа получит сцену.
      </p>
    </header>
    <p>
      Название «Мариинский» театр получил в честь императрицы Марии Александровны,
      супруги Александра II. В советское время театр переименовали в честь товарища Кирова,
      который и в самом деле любил выступать.
    </p>
  </div>
</article>
body {
  font-family: "Roboto", "Arial", sans-serif;
  font-style: normal;
  font-weight: 300;
}

.news {
  width: 700px;
  margin: 0 auto;
}

.news-content {
  position: relative;
  padding: 97px 85px;
  margin-top: 50px;

  background-color: #ffffff;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
}

.news-date {
  font-size: 12px;
  line-height: 16px;
  color: #d8a727;
}

.news-heading {
  font-family: "Oranienbaum", "Arial", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 40px;
  line-height: 46px;
  color: #222222;
 }

.news p {
  font-size: 14px;
  line-height: 27px;
  color: #666666;
 }

.news-leading-paragraph {
  font-size: 24px;
  line-height: 36px;
  color: #444444;
}

.news-picture {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translate(-50%);
  max-width: 100%;
  height: auto;
}`}
      </pre>
      <p>Не стоит оформлять вторую, описательную, часть тегом заголовка следующего уровня. Группы <code>&lt;h1&gt;</code> + <code>&lt;h2&gt;</code> для двух частей одного заголовка в современной вёрстке не применяются, а заголовочные группы <code>&lt;hgroup&gt;</code> вовсе не поддерживаются.</p>
      <p>В зависимости от назначения и архитектуры страницы подзаголовок может быть размечен как <code>&lt;p&gt;</code>, и они с заголовком могут быть объединены как <code>&lt;header&gt;</code>.</p>

      <h3>Текст и контрастность</h3>
      <p>Весь текст должен быть «читабельным», а с декоративными текстами это не всегда работает.</p>
      <h4>Ширина текстового поля</h4>
      <p>Слишком широкое или слишком узкое текстовое поле равно мешает чтению (есть теория, что идеальная длина строки — размер шрифта умножить на 30).</p>
      <h4>Цветовая контрастность</h4>
      <p><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html" target="_blank" rel="noopener noreferrer">Рекомендации по оптимальной контрастности описаны в стандартах.</a></p>
      <p>В браузерах есть встроенные инструменты проверки. Чтобы раздел Contrast Ratio отображался в панели, нужно, чтобы в инструментах разработчика формат устройства был выставлен как десктопный (по умолчанию может стоять мобильная версия, тогда коэффициент контраста отображаться не будет).(на вкладке Lighthouse)</p>
      <p><a href="https://webaim.org/resources/contrastchecker/?fcolor=000000&bcolor=FFFFFF" target="_blank" rel="noopener noreferrer">можно использовать специальные инструменты проверки, например Contrast Checker.</a></p>
      <h4>Размер шрифта</h4>
      <p>Слишком мелкий шрифт скорее заставит уйти с сайта, чем сделать покрупнее (меньше 14 пикселей для десктопа — неуважительно, хорошо — от 16 пикселей).</p>
      <h4>Интерлиньяж</h4>
      <p>Делать интерлиньяж меньше автоматического тоже не следует (line-height: auto; — это 120% от размера шрифта, то есть для 16 пикселей автоматический интерлиньяж составит 19 пикселей). Красивый интерлиньяж — от 1.5em (на 50% больше размера шрифта), то есть line-height: 25px; для шрифта размером 16 пикселей. В блоге Академии сделано именно так. Маленький интерлиньяж мешает поиску начала строки.</p>
      <p>Интерлиньяж может быть задан в px, %, em и числом (множитель). Различия между перечисленными единицами изменения проявляются в полную силу, когда CSS-свойство line-height наследуется от родителя, то есть задано только родительскому элементу, а не каждому в отдельности. В первых трёх вариантах не играет роли, каковы размеры шрифта у самого элемента, и заданы ли эти размеры вообще. В этих случаях наследуется вычисленное или заданное в px значение высоты строки родителя. Вариант с множителем предлагает более гибкое, масштабируемое решение. Здесь наследуется только само число (коэффициент масштабирования), и у каждого элемента-потомка высота строки вычисляется с учётом его собственного размера шрифта.</p>

      <h4>Трекинг</h4>
      <p>Ещё не стоит заигрываться с трекингом: слишком плотно посаженные символы — неудобно, они могут перекрывать друг друга, но и разреженные больше нужного усложнят чтение.</p>
      <h4>Кернинг</h4>
      <p>Трекинг — это межсимвольное расстояние вообще. А кернинг — между двумя конкретными символами. Получается, кернинг — сугубо контекстуальный, а трекинг может быть и глобальным для сайта, страницы или типа контента. В глобальном типографском смысле кернинг — это прописанные в шрифте расстояния между символами в зависимости от их размера и формы. Если присмотреться, то между буквами в сочетании то расстояние меньше, чем между но. Это и есть кернинг в своём прямом смысле. Подробнее о том, как это работает, можно почитать, например, у Горбунова: <a href="https://bureau.ru/bb/soviet/20110612/" target="_blank" rel="noopener noreferrer">«Как кернить текст»</a>.</p>
      <p>Но бывает, что нас по каким-то причинам не устраивает заданное шрифтом расстояние между символами, например, на кнопке или в каком-то мелком элементе. Тогда можно управлять им с помощью свойства font-kerning со значениями auto, inherit или none. Автоматический ссылается на тот кернинг, который заложен в шрифте, inherit делает сами-знаете-что (наследует от родительского элемента), а none отключает тот кернинг, который прописан в шрифте, и все расстояния между символами становятся одинаковыми. Отключение кернинга у целого текста мешает чтению, потому что мы все привыкли читать с настроенными межсимвольными расстояниями.</p>
      <p>Если возникают сомнения в том, какие параметры для шрифта выставить, можно воспользоваться, например, <a href="https://grtcalculator.com/" target="_blank" rel="noopener noreferrer">калькулятором Криса Пирсона</a>, он выдаст усреднённые удобные значения.</p>

      <h3>Лид</h3>
      <p>Лиды как концепция пришли в веб из журналистики и получили на сайтах новую смысловую нагрузку. Lead paragraph в целом — «ведущий параграф», аннотация, резюме текста, вводная мысль. В интернете лид к тому же зачастую выводится на общую страницу новостей как вступительный абзац, так что лид может убедить пользователя, что ему необходимо прочитать весь материал. Обычно это 2–3 предложения, не больше 5 строк.</p>
      <img src="img/text/text-15.png" alt="Лид в этом примере выделен гораздо сильнее, чем это обычно происходит для лидов" width="800" />

      <h3>Цитаты</h3>
      <p>Семантическое значение цитаты — внешний контент, то есть <code>&lt;q&gt;</code> — это строчный элемент, содержащий материалы не уникальные, имеющие другой источник. А <code>&lt;blockquote&gt;</code>, соответственно, тег для выделенных, вынесенных в отдельную секцию цитат.</p>
      <p>Цитата внутри текста может верстаться тегом <code>&lt;q&gt;</code> и не выходит из абзаца. Такие цитаты могут быть выделены другим начертанием. До и после содержимого тега <code>&lt;q&gt;</code> браузер автоматически проставляет кавычки подходящего для языка документа вида. Для русского языка проставляются „лапки“ или «ёлочки». Переопределить кавычки можно с помощью CSS-свойства quotes:</p>
      <p>Вместо <code>&lt;q&gt;</code> можно просто использовать принятые на вашем сайте кавычки, спецификация разрешает это. Использовать <code>&lt;q&gt;</code> для контента, не являющегося цитатой (для сарказма или переводных слов, выделяющихся кавычками) — не семантично.</p>
      <pre>{`<p>Но, как писал <cite>Кастанеда в «Учении дона Хуана»</cite>, <>Страхи перед
      знанием — дело обычное; все мы им подвержены, и тут ничего не поделаешь. Однако каким бы
      устрашающим ни было учение, ещё страшней представить себе человека, у которого нет знания</
      q>, и с этим сложно поспорить.</p>
p {
  font-family: "Georgia", "Times New Roman", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 28px;
  line-height: 46px;
  color: #333333;
}

q {
  quotes: "«" "»";
  color: #744ce6;
}`}
      </pre>
      <p>Они оборачиваются в тег <code>&lt;blockquote&gt;</code>: это не только текстовый элемент, но и элемент для разметки секций (<a href="https://html.spec.whatwg.org/#the-blockquote-element" target="_blank" rel="noopener noreferrer">спецификация</a>). Это означает, что у цитаты могут быть свои заголовки, хедер и футер и текстовые элементы.</p>
      <p>У цитат есть своя специфика вёрстки. Например, есть атрибут cite, который также может выступать как тег <code>&lt;cite&gt;</code>, оба применяются для указания источника (не только для источника-сайта, но и для автора высказывания, для названия произведения, ссылки на первоисточник). Атрибут cite нужен для соблюдения авторского права, визуально он не отображается:</p>
      <img src="img/text/text-16.png" alt="Цитата сделана отдельным блоком, подпись обособлена, есть рамка слева" width="800" />
      <pre>{`<blockquote class="quote">
  <p>Всякий человек нуждается в том, чтобы над ним иногда посмеялись.
  Иначе мы начинаем относится к себе слишком серьезно.</p>
  <cite>«Игра престолов», Джордж Р. Мартин</cite>
</blockquote>
.quote {
  padding-left: 50px;
  border-left: 4px solid #e2e2e2;

  font-family: "Georgia", "Times New Roman", serif;
}

.quote p {
  font-style: normal;
  font-weight: normal;
  font-size: 28px;
  line-height: 46px;
  color: #333333;
}

.quote cite {
  font-style: italic;
  font-weight: normal;
  font-size: 28px;
  line-height: 46px;
  color: #aaaaaa;
}`}
      </pre>
      <p>В случае, если это не цитата в полном смысле слова, а акцентная мысль, более важное предложение в потоке текста, будет правильнее верстать такую мысль другими тегами, например, <code>&lt;p&gt;</code> и <code>&lt;strong&gt;</code> с классом, или ``.</p>
      <pre>{`<!-- Тег <strong> означает что-то срочное, важное -->
<p>Каждый раз, когда мы размышляем о том, какой тег будет корректнее с точки зрения семантики,
в Академии улыбается один наставник.</p>
<p><strong>Читайте спецификацию, о еноты!</strong></p>

<!-- Тег  означает некую автономную сущность внутри потока -->
<p>Иногда, встречаясь в спецификации с новым знанием, мы загораемся желанием
применить именно его, это новое обретённое знание.</p>

<figure>
  Сверяйтесь со спецификацией как можно чаще. Браузеры обрабатывают код по спеке,
  разработчики пишут код по спеке — и у нас всё вместе хорошо работает.
  <figcaption>Совет по работе со спецификациями</figcaption>
</figure>`}
      </pre>

      <h4>Цитата простая, незатейливая, без дополнительных элементов</h4>
      <p>Самый стандартный вариант оформления цитаты — «поиграть со шрифтами». Например, укрупнённый шрифт, изменённый цвет, другое начертание: курсив или полужирное. Возможно другое семейство шрифтов, увеличенное межстрочное расстояние, возможно, все буквы будут прописные. Обычно у подписи кегль меньше, а начертание контрастнее.</p>
      <img src="img/text/text-17.png" alt="" width="800" />
      <pre>{`<blockquote class="quote">
  <p>Не сдаваться! Не отступать! Таков спартанский закон. И по этому спартанскому закону
  мы будем стоять! Воевать! Умирать! Наступает новая эра. Эра свободы!
  И все будут помнить, что три сотни спартанцев до последнего вздоха её защищали!</p>
  <cite>Царь Леонид</cite>
</blockquote>
.quote {
  font-family: "Montserrat", "Arial", sans-serif;
  text-align: center;
}

.quote p {
  font-style: italic;
  font-weight: normal;
  font-size: 22px;
  line-height: 40px;
  color: #744ce6;
}

.quote cite {
  font-style: normal;
  font-weight: 500;
  font-size: 16px;
  line-height: 40px;
  color: #aaaaaa;
}`}
      </pre>
      <p>Второй по типичности — то же самое, но в дополнение появляется обводка или фон. Фон обычно неброский, просто заливка. Обводка может быть со всех сторон, только слева, или сверху и снизу.</p>
      <img src="img/text/text-18.png" alt="" width="800" />
      <pre>{`<blockquote class="quote">
  <p>Самые ошибочные умозаключения людей суть следующие: вещь существует, следовательно,
  она имеет право на это.</p>
  <cite>«Человеческое, слишком человеческое». Фридрих Ницше</cite>
</blockquote>
.quote {
  width: 740px;
  padding: 10px 50px;
  border-right: 8px solid #d5d5d5;
  border-left: 8px solid #d5d5d5;

  font-family: "Merriweather", "Times New Roman", serif;
  font-style: normal;
  font-weight: normal;
  color: #333333;
}

.quote p {
  margin-top: 0;

  font-size: 27px;
  line-height: 50px;
}

.quote cite {
  font-size: 16px;
  line-height: 30px;
  font-style: normal;
}`}
      </pre>

      <h4>Обратный отступ</h4>
      <p>Это вроде как цитата, но в данном контексте это акцентная мысль. Стоит подать именно так.</p>
      <img src="img/text/text-19.png" alt="" width="800" />
      <pre>{`<article>
  <p>Сначала — неприятные задачи. В любой работе есть неприятные задачи — их всегда хочется
  отложить на потом. Нередко это самое «потом» наступает слишком поздно. Если задачу в принципе 
  нельзя скипнуть, то лучше ей заняться в начале рабочего дня. Так вы не растеряете фокус и 
  преждевременно не отправите задачу в очередь.</p>
  <p class="accent">
    «Не имеет смысла нанимать толковых людей, а затем рассказать им, что делать; мы нанимаем 
    умных людей, чтобы они могли рассказать нам, что делать». Так говорил Стив Джобс.
  </p>
  <p>Если вдруг вы выполнили план на день буквально за несколько часов и у вас, по идее, куча 
  свободного времени — это не значит, что рабочий день закончился. В это время можно заняться 
  какими-то другими делами по работе, разобрать бэклог, или спросить у руководителя, что делать 
  дальше.</p>
</article>
p {
  padding-left: 50px;

  font-family: "Merriweather", "Times New Roman", serif;
  font-style: normal;
  font-weight: 300;
  font-size: 16px;
  line-height: 27px;
  color: #333333;
}

.accent {
  padding-left: 0;

  font-family: "Roboto", "Arial", sans-serif;
  font-style: normal;
  font-weight: normal;
  font-size: 32px;
  line-height: 44px;
  color: #333333;
}`}
      </pre>

      <h4>Цитата затейливая, с кавычками</h4>
      <p>Зачастую цитата оформляется с помощью акцентных кавычек, они могут быть вставлены как символы шрифта или юникода, а могут — как графика.</p>
      <img src="img/text/text-20.png" alt="" width="800" />
      <pre>{`<blockquote class="quote">
  <p>Свежесть бывает только одна — первая, она же и последняя.
  А если осетрина второй свежести, то это значит, что она тухлая!</p>
  <cite>Воланд. Михаил Булгаков. «Мастер и Маргарита»</cite>
</blockquote>
.quote {
  position: relative;

  font-family: "Muller", "Open Sans", sans-serif;
  font-style: normal;
  font-weight: normal;
  font-size: 24px;
  line-height: 36px;
  color: #333333;
  padding-left: 40px;
}

.quote::before {
  content: ""; /* кавычку встроим фоном для удобства управления */
  position: absolute;
  left: 0;
  top: 0;
  width: 34px;
  height: 37px;

  background: url("quote.svg") no-repeat 0 0;
  /* Это краткая запись, которая означает, что фоновое изображение в формате svg,
  не повторяется, стартует из левого верхнего угла (нули означают координаты по осям x и y) */
}

.quote cite {
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
}`}
      </pre>]
      <img src="img/text/text-21.png" alt="" width="800" />
      <pre>{`<blockquote class="quote">
  <p>Вовсе ты не плохой человек, ты очень хороший человек, с которым случилось много плохого,
  понимаешь? К тому же мир не разделён на плохих и хороших. В каждом есть и светлая и тёмная
  сторона. Главное то, какую выбрал ты. Это определяет всё.</p>
  <cite>
    <span class="character">Сириус Блэк</span><br>
    <span class="author">«Гарри Поттер», Джоан Роулинг</span>
  </cite>
</blockquote>
.quote {
  position: relative;
  margin: 50px 100px;

  font-family: "Vollkorn", "Times New Roman", serif;
  color: #333333;
}

.quote::before {
  content: "";
  position: absolute;
  left: -46px;
  top: -13px;

  width: 136px;
  height: 106px;

  background: url("quote-big.svg") no-repeat 0 0;
}

.quote p {
  position: relative;

  font-size: 25px;
  line-height: 34px;
}

.quote p::before {
  content: "";
  position: absolute;
  width: 22px;
  height: 17px;
  top: 10px;
  left: -30px;

  background: url("quote-small.svg") no-repeat 0 0;
}

.quote cite {
  position: relative;

  font-style: italic;
  font-size: 16px;
  line-height: 24px;
}

.quote .character {
  color: #333333;
}

.quote .author {
    color: #888888;
}`}
      </pre>
      <img src="img/text/text-22.png" alt="" width="800" />
      <pre>{`<blockquote class="quote">
  <p>Люди избавились бы от половины своих неприятностей,
  если бы договорились о значении слов.</p>
  <cite>Рене Декарт</cite>
</blockquote>
.quote {
  position: relative;
  margin: 45px auto 25px;
  padding: 30px 0 40px;
  border-top: 2px solid #f0522c;
  border-bottom: 2px solid #f0522c;
  width: 650px;
}

.quote::before {
  position: absolute;
  content: "“";
  top: -10px;
  left: 50%;
  padding: 0 15px;
  transform: translateX(-50%);
  margin: 0 auto;
  font-weight: normal;
  font-size: 140px;
  line-height: 70px;
  color: #f0522c;
  background-color: #ffffff;
}

.quote p {
  position: relative;
  margin: 20px 0 35px 0;
  font-size: 2em;
  text-align: center;
  z-index: 1;
}

.quote cite {
  display: block;
  font-style: normal;
  font-weight: 600;
  font-size: 1em;
  line-height: 1.5;
  text-align: center;
}`}
      </pre>
      <img src="img/text/text-23.png" alt="" width="800" />
      <pre>{`<article>
  <blockquote class="quote">
    <div class="quote-inner">
      <p>У меня нет заниженной самооценки. Это ошибка.
      У меня заниженная оценка всех остальных.</p>
      <cite>Дарья. Сериал для MTV</span>
    </div>
  </blockquote>
</article>
article {
  background-color: #f0c52e;
}

.quote {
  position: relative;
  padding: 100px 0;

  font-family: "Exo 2", "Arial", sans-serif;
  text-align: center;
  color: #333333;

  background: url("back.png") no-repeat 50% 50%;  /* это фон,
  который выглядит как мазок кистью */
}

.quote-inner {
  max-width: 460px;
  margin: 0 auto;
}

.quote::before,
.quote::after {
  content: "";
  position: absolute;
  width: 486px;
  height: 43px;
  left: 0;
  right: 0;
  margin-left: auto;
  margin-right: auto;

  background: url("quote-border.svg") no-repeat 0 0; /* мы выгрузили кавычку
  с границей вместе в векторе; элементы идентичны, но с разным поворотом */
  background-size: 486px;
}

.quote::before {
  top: 40px;
  transform: rotate(180deg); /* поворачивает кавычку с границей */
}

.quote::after {
  bottom: 40px;
}

.quote p {
  margin: 0 0 17px;

  font-weight: 400;
  font-size: 32px;
  line-height: 36px;
}

.quote cite {
  font-weight: 300;
  font-style: normal;
}`}
      </pre>

      <h3>Врезки, обтекания</h3>
      <p>Дополнительная информация, относящаяся к основному контенту, но не включённая в сам материал, зачастую выносится сбоку от основного потока текста. Там может появиться расшифровка термина, или уточнение, или наш любимый «режим зануды», или список ссылок на другие материалы по теме — в общем, тот контент, который частью материала является, но из потока текста выпадает и не кажется авторам строго обязательным.</p>
      <p>С семантической точки зрения это может быть <code>&lt;aside&gt;</code>, если содержание врезки напрямую не относится к посту и к тому же выпадает из потока. Но также это может быть размечено либо как <code>&lt;div&gt;</code>, либо тегом, лучше всего подходящим по смыслу: <code>&lt;dl&gt;</code>, если выносится определение термина, <code>&lt;blockquote&gt;</code>, если сбоку выносится дополнительная цитата… Нужно только понять, что именно будет врезаться на конкретном сайте и привязывать стили к классу, а не к тегу.</p>
      <p>Для выноса врезки вбок обычно используются два метода: «обтекание» и «вынос из потока».</p>

      <h4>Обтекание</h4>
      <img src="img/text/text-24.png" alt="" width="800" />
      <pre>{`<div class="text">
  <p>Филогенез, так или иначе, представляет собой механизм эвокации, что-то подобное можно
  встретить в работах Ауэрбаха и Тандлера. Художественная контаминация продолжает постмодернизм.
  Цвет, так или иначе, сложен. Воображение трансформирует стиль, именно об этом комплексе
  движущих сил писал З. Фрейд в теории сублимации.</p>
  <div class="bonus">
    <p>Кстати, текст совершенно не обязательно должен быть бессмысленным, это приятный бонус.</p>
  </div>
  <p>Возрождение образует элитарный фарс. Фабульный каркас изменяем. Аксиология образует
  онтологический статус искусства, таким образом, все перечисленные признаки архетипа и мифа
  подтверждают, что действие механизмов мифотворчества сродни механизмам
  художественно-продуктивного мышления. Нередуцируемость содержания, в том числе, возможна.
  Теория наивного и сентиментального искусства, так или иначе, заканчивает фактографический
  горизонт ожидания, именно об этом комплексе движущих сил писал З. Фрейд в теории сублимации.
  Эти слова совершенно справедливы, однако ирония продолжает механизм эвокации.</p>
</div>

.text {
  max-width: 770px;

  font-family: "Roboto", "Arial", sans-serif;
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  line-height: 30px;
}

.bonus {
  float: right;
  margin-left: 64px;
  width: 160px;

  font-size: 12px;
  line-height: 20px;
  color: #744ce6;
}`}
      </pre>
      <img src="img/text/text-25.png" alt="" width="800" />
      <pre>{`<div class="text">
  <p>Реконструктивный подход начинает резкий канон. Дискредитация теории катарсиса даёт резкий
  хтонический миф. Феномер «психической мутации» вызывает элитарный художественный талант.</p>

  <div class="clearfix">
    <blockquote class="quote">«Это то, что действительно радует в работе с компьютерами. Они не
    спорят, они всё помнят, и они никогда не выпьют всё ваше пиво.» <cite>Пол Лери</cite></blockquote>

    <p>Теоретическая социология, следовательно, трансформирует персональный анимус. Либидо
    постоянно. Одиночество готично заканчивает композиционный биографический метод. Манерничанье,
    следовательно, использует комплекс априорной бисексуальности.</p>
  </div>

  <p>Иными словами, аксиология выстраивает первоначальный комплекс априорной бисексуальности.
  Иносказательность образа просветляет комплекс априорной бисексуальности, что-то подобное можно
  встретить в работах Ауэрбаха и Тандлера. Эти слова совершенно справедливы, однако метафора
  аккумулирует психологический параллелизм. Фарс изящно представляет собой принцип артистизма.</p>
</div>
.text {
  max-width: 770px;
  font-family: "Merriweather", "Arial", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  line-height: 30px;
}

.quote {
  float: right;
  position: relative;
  margin-left: 64px;
  width: 390px;

  font-family: "Helvetica", "Arial", serif;
  font-style: normal;
  font-weight: 300;
  font-size: 18px;
  line-height: 30px;
  color: #333333;
  text-indent: -0.55em; /* красная строка, об этом есть в дополнительной теории */
}

.quote::before {
  content: "";
  position: absolute;
  left: -0.7em;
  top: -16px;
  width: 80px;

  border-top: 9px solid #333333;

  line-height: 42px;
}

.quote cite {
  font-style: normal;
  font-weight: 800;
}

.clearfix::after {
  content: "";
  display: block;
  clear: both;
}`}
      </pre>

      <h4>Вынос из потока</h4>
      <p>Обычно это делается следующим образом: выносимому блоку задаётся абсолютное позиционирование, а блоку контейнеру, в котором выносимый блок находится, — относительное. Затем вынесенному из потока блоку задаются две обязательные координаты, например, top и left, по которым блок «привяжется» к определённому краю контейнера. После этого абсолютно спозиционированному блоку задаётся явная ширина. А координате стороны, в которую текст выносится, задаётся отрицательное значение больше или равно ширине блока. Например, блок шириной width: 100px выносится влево с небольшим запасом для отступа — left: -120px.</p>
      <img src="img/text/text-26.png" alt="" width="800" />
      <pre>{`<section class="container">
  <p>Суждение выводит из ряда вон выходящий дедуктивный метод. Представляется логичным, что
  искусство дискредитирует естественный гедонизм, tertium nоn datur. Адаптация осмысляет типичный
  интеллект.</p>

  …

  <aside class="sidebar">
    <p>Читайте также:</p>
    <p>[Данный структурализм: предпосылки и развитие](#)</p>
  </aside>
</section>
.container {
  position: relative;
  with: 560px;
  margin: 0 auto;
}

.sidebar {
  position: absolute;
  left: -250px;
  top: 0;
  width: 230px;
}`}
      </pre>

      <h3>Списки</h3>
      <h4>Стилизация списков</h4>
      <p>Нужно не забывать отделять список от основного текста, чтобы они не сливались и не «наезжали» друг на друга. Списки, перед которыми стоит разъясняющая фраза, связаны с текстом сильнее, чем списки, которые самостоятельны. Идеально, если у первых отступ после немного больше, чем отступ до.</p>
      <p>Как можно изменить списки? Во-первых, можно изменить вид маркера. Во-вторых, можно заменить маркер на изображение. В-третьих, можно оформить сам список, и его маркеры.</p>
      <pre>{`.content-list {
  list-style-image: url("../img/rocket.svg");
}`}
      </pre>
      <p>Чтобы сделать особенные буллиты, не предусмотренные свойствами CSS, можно использовать псевдоклассы ::before&sol;::after и свойство content. Например, символы юникода в CSS вставляются не как U+01FA, а как &bsol;01FA, хотя можно встроить уже готовым символом, например, Ǻ.</p>
      <p>Непосредственно ссылку на изображение в content вставлять не стоит, хотя технически так можно сделать — content: url(&apos;img.jpg&apos;). Изображению в content-е нельзя выставить размер, так как свойство content подразумевает текст и к нему применяются только текстовые свойства. Если вид списка требует изображения, лучше сделать его фоном.</p>
      <img src="img/text/text-27.png" alt="" width="800" />
      <pre>{`<ul class="toxic">
  <li>Яды</li>
  <li>Продукты распада</li>
  <li>Отходы химического производства</li>
  <li>Бывшие друзья</li>
</ul>
.toxic {
  list-style: none; /* отключили стандартные буллиты */
}

.toxic li {
  position: relative;
  width: 600px;
  height: 80px;
  padding-left: 100px;
  margin-bottom: 20px;

  font-family: "Montserrat", "Arial", sans-serif;
  font-style: normal;
  font-weight: normal;
  font-size: 24px;
  line-height: 80px;
  color: #333333;

  background-color: #e8e8e8;
}

.toxic li::before {
  content: "&bsol;2623"; /* подключили буллиты в юникоде */
  position: absolute;
  top: -30px;
  left: -50px;
  display: inline-block;      /* их нужно стилизовать; про инлайн есть в основной теории */
  width: 85px;
  height: 85px;
  margin: 27px;

  font-size: 55px;
  font-weight: 800;
  line-height: 80px;
  text-align: center;
  color: white;

  background: url("list-back.svg") no-repeat #333333;
  border-radius: 50%;
}`}
      </pre>
      <p>Стандартные числовые или буквенные маркеры сложно стилизовать. Часто стандартные маркеры скрывают (с помощью свойства list-style: none;) и затем воссоздают с помощью CSS-счётчиков. Как это работает:</p>
      <ul>
        <li>свойство counter-reset: li сбрасывает (инициализирует) значение счётчика и даёт ему имя li;</li>
        <li>свойство counter-increment: li — инкрементирует счётчик;</li>
        <li>свойство content: counter(li); — отображает текущее значение счётчика.</li>
      </ul>
      <p>Значение счётчика можно вывести с помощью псевдоклассов ::before/::after и свойства content. Содержимое content может собираться из нескольких частей, например, так: content: &quot;#&quot; counter(li); (получится — #1, #2 и так далее).</p>
      <img src="img/text/text-28.png" alt="" width="800" />
      <pre>{`<h1>Игры для компании</h1>
<ul class="games">
  <li>
    <h2>Мафия</h2>
    <p>Цель мафиози – убивать игроков ночью и казнить днём, выдавая себя за положительных 
    героев. Цель Граждан – найти и казнить Мафию.</p>
  </li>
  <li>
    <h2>Шпион</h2>
    <p>Цель игры - игрокам необходимо выявить шпиона, шпиону необходимо определить локацию.</p>
  </li>
  <li>
    <h2>Твистер</h2>
    <p>Побеждает тот игрок, которому удастся устоять на поле, выполнив все приказы ведущего.</p>
  </li>
</ul>
h1 {
  font-size: 36px;
  line-height: 1.4;
}

h2 {
  margin: 10px 0;
  padding-left: 56px;

  font-size: 24px;
  line-height: 1.5;
}

p {
  margin: 0;
}

.games {
  max-width: 600px;
  padding: 0;
  margin: 0;

  counter-reset: list-counter;

  list-style: none;
}

.games li {
  position: relative;

  counter-increment: list-counter;

  margin-bottom: 32px;
}

.games li::before {
  position: absolute;
  width: 40px;
  height: 40px;
  left: 0;
  top: 0;

  content: "0" counter(list-counter);

  font-weight: bold;
  font-size: 24px;
  line-height: 1.2;
  text-align: center;
  color: #ffffff;

  background-color: #ffad0f;
  border-radius: 4px;
}`}
      </pre>
      <img src="img/text/text-29.png" alt="" width="800" />
      <pre>{`<ol class="code-list">
  <li>Верстаешь чуть-чуть</li>
  <li>Верстаешь хорошо</li>
  <li>Учишь JS</li>
  <li>Работаешь фронтенд-разработчиком</li>
</ol>
.code-list {
  margin: 0;
  padding: 30px;

  counter-reset: li;

  list-style: none;
  font-family: "Montserrat", "Arial", sans-serif;
  font-style: normal;
  font-weight: normal;
}

.code-list li {
  position: relative;
  margin: 0 0 40px 2em;
  padding: 8px 16px;
  width: 522px;

  counter-increment: li;

  font-size: 24px;
  line-height: 32px;
  color: #333333;
  border-bottom: 2px solid #39b54a;
}

.code-list li:last-child {
  margin-bottom: 0;
}

.code-list li::before {
  position: absolute;
  top: -10px;
  left: -1.5em;
  width: 60px;
  height: 60px;

  content: counter(li);

  font-weight: bold;
  font-size: 40px;
  line-height: 60px;
  text-align: center;
  color: #ffffff;

  background-color: #39b54a;
}`}
      </pre>

      <h4>Добавление на страницу прерванного списка</h4>
      <p>В спецификации языка HTML указано, что список может включать в себя только элементы - , но как быть, если необходимо добавить на страницу список с комментарием или параграфом в середине? Для решения этой задачи можно разбить список на два и между списками поместить параграф. Второй список начать не с первого номера, а с номера 4. Для этого у тега <code>&lt;ol&gt;</code> есть атрибут start.</p>
      <img src="img/text/text-30.png" alt="" width="800" />
      <pre>{`<ol>
  <li>Проснуться</li>
  <li>Позавтракать</li>
  <li>Начать писать статью</li>
</ol>

<div class="note">... уснуть часов на 5 ...</div>

<ol start="4">
  <li>Закончить писать статью</li>
  <li>Ложиться спать</li>
</ol>`}
      </pre>

      <h4>Вложенные списки и сложная стилизация</h4>
      <p>С помощью механизма CSS-счётчиков можно не только стилизовать обычные списки, но и легко создавать сложную нумерацию для вложенных списков.</p>
      <p>Для добавления нумерации воспользуемся функцией counters(). Функция counters() принимает два параметра: имя счётчика, значение которого нужно вывести и строку-разделитель между значениями вложенных счётчиков (counters(outline, &quot;.&quot;)), в нашем случае — это точка. Вторым параметром также можно указывать любое из возможных значений атрибута list-style-type: none, disc, circle и square. В случаях использования disc, circle и square список станет выглядеть так же, как обычный ненумерованный список с маркерами соответствующего типа.</p>
      <img src="img/text/text-31.png" alt="" width="800" />
      <pre>{`<ol>
  <li><a href="#">Раздел 1</a></li>
  <li><a href="#">Раздел 2</a></li>
  <li><a href="#">Раздел 3</a>
    <ol>
      <li><a href="#">Раздел 3.1</a></li>
      <li><a href="#">Раздел 3.2</a>
        <ol>
          <li><a href="#">Раздел 3.2.1</a></li>
          <li><a href="#">Раздел 3.2.2</a></li>
          <li><a href="#">Раздел 3.2.3</a></li>
        </ol>
      </li>
      <li><a href="#">Раздел 3.3</a></li>
    </ol>
  </li>
  <li><a href="#">Раздел 4</a></li>
  <li><a href="#">Раздел 5</a>
    <ol>
      <li><a href="#">Раздел 5.1</a></li>
      <li><a href="#">Раздел 5.2</a></li>
      <li><a href="#">Раздел 5.3</a></li>
    </ol>
  </li>
  <li><a href="#">Раздел 6</a></li>
  <li><a href="#">Раздел 7</a></li>
</ol>

Добавим стили:

ol {
  list-style: none;
  counter-reset: outline;
  padding-left: 32px;
}

ol li {
  counter-increment: outline;
}

ol li::before {
  content: counters(outline, ".", disc);  /* Добавляем значения всех уровней
                                          вложенности, используя разделитель '.' */
}`}
      </pre>
      <p>Схема добавления нумерации для вложенных списков схожа с тем, что мы уже проделывали для обычных списков, то есть:</p>
      <ul>
        <li>свойство counter-reset: outline; сбрасывает (инициализирует) значение счётчика и даёт ему имя outline;</li>
        <li>свойство counter-increment: outline; — инкрементирует (увеличивает) счётчики (включая счётчики для вложенных списков);</li>
        <li>свойство content: counters(outline, &quot;.&quot;) &quot;. &quot;; — добавляет с помощью counters(outline, &quot;.&quot;) значения списков всех уровней вложенности, используя разделитель .. Строка с полученным номером «склеивается» со строкой &quot;. &quot; (точка и пробел), тем самым получаем номер вида: 3.2.1. Раздел 3.2.1.</li>
      </ul>

      <h3>Метаданные, дата, автор</h3>
      <p>Зачастую оформление тегов, информации об авторе, технические данные о новости важны для правильного восприятия материала, например, если автор известен, или у материала есть «срок годности». Обычно метаданные получают из базы данных и из системы управления контентом сайта, и вопрос их получения мы рассматривать не будем. Наша задача — сверстать их красиво и правильно.</p>
      <p>Какие данные могут попасть в «мета»? Информация об авторе, а именно имя и ссылка на профиль или все материалы автора; информация о дате создания, публикации и/или дате изменения материала; количество просмотров; количество комментариев; теги; категория материала. Из редко встречающегося — время прочтения; ключевые слова…</p>
      <p>Если таких данных довольно много и их нужно сгруппировать, можно объединить их в <code>&lt;footer&gt;</code>. Тег <code>&lt;footer&gt;</code> семантически означает побочную информацию о контенте, а не только буквально «подвал».</p>
      <img src="img/text/text-32.png" alt="" width="800" />
      <pre>{`<article>
  <div class="post-head" style="background-image: url('bg-image.jpg');">
    <h1>Туториал. Интерактивная SVG-диаграмма</h1>
  </div>
  <footer class="meta">
    <ul class="post-info">
      <li class="post-info-item">
        <time class="post-info-value post-info-value-datetime" datetime="2020-03-27"> 27 марта 2020</time>
      </li>
      <li class="post-info-item">
        <span class="post-info-value post-info-value-readtime">17 мин</span>
      </li>
      <li class="post-info-item">
        <span class="post-info-value post-info-value-visits">4 275</span>
      </li>
    </ul>
    <p class="post-tags">
      <a href="#">Фронтенд</a>
    </p>
    <div class="post-author">
      <p class="author-text">Автор <a href="#">Саша Смыгина</a></p>
      <a class="author-pic" href="#"><img src="author-pic.jpg" width="50" height="50"
      alt="Портрет Саши Смыгиной"></a>
    </div>
  </footer>
  <p>Сейчас все активно обсуждают радости и гадости удалённой работы, и мы даже выпустили статью
  на эту тему. А ещё провели небольшой опрос и попросили наших пользователей рассказать, с
  какими трудностями они сталкиваются во время работы дома (спойлер — все ленятся). Статистику
  нужно как-то красиво оформить, так почему бы не сделать SVG-график? Заодно научимся
  чему-нибудь новому. Поехали!</p>
</article>
article {
  font-family: "Muller", "Arial", sans-serif;
  font-size: 16px;
  line-height: 1.5em;
  color: #333333;
}

h1 {
  max-width: 600px;

  font-size: 42px;
  line-height: 48px;
  color: #ffffff;
}

.post-head {
   min-height: 320px;
   padding: 25px;
}

.meta {
  display: flex;  /* смотри навык про флексы */
  justify-content: space-between;
  align-items: center;
  padding: 20px 25px;

  background-color: #f6f6f6;
}

.meta a {
  color: #302683;
  text-decoration: none;
}

.meta a:hover,
.meta a:focus {
  text-decoration: underline;
}

.post-info {
  display: flex;
  justify-content: space-between;
  margin: 0;
  padding: 0;

  list-style: none;
}

.post-info-item {
  margin-right: 15px;
}

.post-info-value::before {
  content: "";
  display: inline-block;

  width: 20px;
  height: 20px;
  margin-right: 5px;

  vertical-align: middle;

  background-position: center;
  background-repeat: no-repeat;
}

.post-info-value-datetime::before {
  background-image: url("datetime.svg");
}

.post-info-value-readtime::before {
  background-image: url("readtime.svg");
}

.post-info-value-visits::before {
  background-image: url("visits.svg");
}

.post-tags {
  margin-right: auto;
  margin-left: 30px;
}

.post-author {
  display: flex;
  align-items: center;
}

.author-pic {
  margin-left: 15px;
}

.author-pic img {
  border-radius: 50%;
}`}
      </pre>
      <p>Если метаданные состоят из ключа и значения, уместно верстать их как список определений: dl &gt; dt + dd</p>
      <img src="img/text/text-33.png" alt="" width="800" />
      <pre>{`<h1 class="heading">Здание «Доминион» потрясающего архитектора Захи Хадид</h1>
<dl class="meta">
  <div class="meta-item meta-item-author">
    <dt>Автор</dt>
    <dd>Админ</dd>
  </div>
  <div class="meta-item meta-item-reading-time">
    <dt>Время на прочтение</dt>
    <dd>3 мин</dd>
  </div>
  <div class="meta-item meta-item-publish-date">
    <dt>Опубликовано</dt>
    <dd><time datetime="2019-11-12">2019-11-12</time></dd>
  </div>
</dl>
.heading {
  font-family: "Montserrat", "Arial", sans-serif;
  font-style: normal;
  font-weight: bold;
  font-size: 16px;
  line-height: 20px;
  letter-spacing: 0.13em;
  text-transform: uppercase;
  color: #000000;
}

.meta {
  display: flex;
  justify-content: space-between;
  padding-bottom: 10px;
  border-bottom: 2px solid #e5e5e5;

  font-family: "Montserrat", "Arial", sans-serif;
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 20px;

  color: rgba(0, 0, 0, 0.5);
}

.meta-item {
  position: relative;
  padding-left: 50px;
}

.meta-item::before {
  content: "";

  position: absolute;
  left: 0;
  top: 0;
  width: 36px;
  height: 36px;

  background-position: center;
  background-repeat: no-repeat;
}

.meta-item-author::before {
  background-image: url("author.svg");
}

.meta-item-reading-time::before {
  background-image: url("reading-time.svg");
}

.meta-item-publish-date::before {
  background-image: url("publish-date.svg");
}

.meta dt {
  color: rgba(0, 0, 0, 0.5);
}

.meta dd {
  margin: 0;
  color: #d90000;
}`}
      </pre>
      <p>Также допустимо объединить метаинформацию с заголовком в начале статьи в теге <code>&lt;header&gt;</code>. Рассмотрим ещё один пример с объединением заголовка, контентной картинки и метаинформации.</p>
      <img src="img/text/text-34.png" alt="" width="800" />
      <pre>{`<article class="main-article">
  <header class="main-article-header">
    <img class="main-article-header-img" src="photo.jpg" width="960" height="309"
      alt="Вид на горную деревню в Грузии">
    <div class="container main-article-header-content">
      <p class="tag"><a href="#">Путешествия</a></p>
      <h1 class="heading">Путеводитель по Грузии: что стоит посмотреть в первую очередь</h1>
      <div class="meta-row">
        <div class="meta-col">
          <span class="meta meta-views">1 479</span>
        </div>
        <div class="meta-col">
          <span class="meta meta-comments">72</span>
        </div>
        <div class="meta-col">
          <span class="meta meta-likes">938</span>
        </div>
      </div>
    </div>
  </header>
  <div class="container">
    <p>Итак, это произошло. Вы купили билеты, собрали чемоданы, возможно уже прилетели в страну
    и поняли, что не знаете куда сходить и что посмотреть. Не переживайте, сейчас во всём
    разберёмся.</p>
  </div>
</article>
.container {
  width: 430px;
  margin: 0 auto;
  padding-left: 15px;
  padding-right: 15px;
}

.main-article {
  font-family: "Georgia", "Times New Roman", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 13px;
  line-height: 20px;

  color: #333333;
}

.main-article-header {
  position: relative;
  margin-bottom: 53px;
  border-top: 1px solid transparent;

  text-align: center;
  font-family: "Montserrat", "Arial", sans-serif;
  color: #ffffff;
}

.main-article-header-content {
  position: relative;
  padding-top: 22px;
  padding-bottom: 22px;
  margin-top: 32px;

  background-color: rgba(0, 0, 0, 0.5);
  box-shadow: 0px 4px 16px rgba(0, 0, 0, 0.15);
}

.main-article-header-img {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  margin: 0 auto;
}

.heading {
  margin: 0;
  font-family: "Georgia", "Times New Roman", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 32px;
  line-height: 36px;
}

.tag {
  font-weight: 300;
  font-size: 10px;
  line-height: 12px;
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.tag a {
  color: inherit;
  text-decoration: none;
}

.tag a:hover,
.tag a:focus {
  text-decoration: underline;
}

.meta-row {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 32px 0 18px;
}

.meta-col {
  margin-left: 10px;
  margin-right: 10px;
}

.meta {
  display: flex;
  align-items: center;
  margin: 0;

  font-weight: 500;
  font-size: 10px;
  line-height: 11px;
}

.meta::before {
  content: "";
  width: 10px;
  height: 7px;
  margin-right: 4px;

  background-position: center;
  background-repeat: no-repeat;
}

.meta-date::before {
  background-image: url("../img/calendar.svg");
}

.meta-read-time::before {
  background-image: url("../img/watch.svg");
}

.meta-views::before {
  background-image: url("../img/eye.svg");
}`}
      </pre>

      <h3>Подписи к демонстрационному материалу</h3>
      <p>Текст может служить вспомогательным элементом, например, быть подписью к отдельно стоящему изображению. В таком случае картинку уместно обернуть в тег <code>&lt;figure&gt;</code>, а подпись к ней заключить в тег <code>&lt;figcaption&gt;</code>.</p>

      <h4>Подпись к видеоролику</h4>
      <img src="img/text/text-35.png" alt="" width="800" />
      <pre>{`<figure>
  <video src="kitten.mov"></video>
  <figcaption>Смешное видео с котиками</figcaption>
</figure>
figure {
  padding: 20px;

  background-color: #ffffff;
}

video {
  width: 100%;
}

figcaption {
  position: relative;
  margin: 8px 0;

  font-family: "Georgia", "Times New Roman", serif;
  font-style: italic;
  font-weight: normal;
  font-size: 16px;
  line-height: 20px;
  text-align: center;
  color: #ad9d85;
}

figcaption::after {
  content: "";
  position: absolute;
  bottom: -8px;
  left: 0;
  right: 0;
  margin-left: auto;
  margin-right: auto;
  width: 50px;
  height: 1px;

  background-color: #d6cec2;
}`}
      </pre>

      <h4>Подпись к диаграмме или схеме</h4>
      <img src="img/text/text-36.png" alt="" width="800" />
      <pre>{`<figure>
  <figcaption>Диаграмма распределения трудностей работы из дома</figcaption>
  <div class="diagram">
    …
  </div>
</figure>
figure {
  background-color: #ebddf1;
}

figcaption {
  padding: 15px;

  font-family: "Arial", sans-serif;
  font-style: italic;
  font-weight: normal;
  font-size: 22px;
  line-height: 20px;
  text-align: center;
  letter-spacing: 0.01em;
  color: #ffffff;

  background-color: #dec1e0;
}`}
      </pre>

      <h4>Подпись к листингу кода</h4>
      <img src="img/text/text-37.png" alt="" width="800" />
      <pre>{`<figure>
  <figcaption>Пример разметки заголовков</figcaption>
  <pre><code>
    <span class="color">&lt;h1&gt;</span>Навык «Вёрстка текстового содержания страниц»<span class="color">&lt;/h1&gt;</span>
    …
  </code></pre>
</figure>
figure {
  padding: 10px 22px;

  background-color: #31384f;
  border-left: 2px solid #ab5bdb;

  font-family: "Courier New", monospace;
  font-style: normal;
  font-weight: normal;
  font-size: 18px;
  line-height: 30px;
}

figcaption {
  padding: 5px;
  border-bottom: 2px solid #292F42;

  font-size: 22px;
  line-height: 30px;
  color: #f2f2f2;
  opacity: 0.3;
}

pre {
  margin: 5px 0;

  color: #f2f2f2;
}

.color {
  color: #ff6b00;
}`}
      </pre>

      <h3>Ссылки, подчёркивания</h3>
      <p>Самое важное в работе со ссылками — не испортить дизайном юзабильность (удобство в использовании). А именно: с первого взгляда на сайт должно быть ясно, где именно у него активные элементы. И это должно подтверждаться при изменении состояния, то есть должны быть продуманы и внятно воплощены стили для псевдоклассов :hover, :active, :visited и :focus. У :focus, например, есть стили по умолчанию, они несколько отличаются от браузера к браузеру.</p>
      <ul>
        <li>:hover — наведение мыши;</li>
        <li>:active — клик (мышью или с клавиатуры);</li>
        <li>:visited — посещённая ссылка;</li>
        <li>:focus — ссылка выбрана при переключении с клавиатуры.</li>
      </ul>
      <p>В работе со ссылками используются селекторы атрибутов, которые позволяют выбрать типы селекторов. Это позволяет декорировать ссылки не по классам, а по их содержанию, отделить ссылки для скачивания от ссылок на страницы внутри сайта и на внешние ресурсы.</p>
      <pre>{`a[href*="css"]       /* Применится к ссылкам, в URL которых есть сочетание букв css */
a[href^="https://"]  /* Применится к ссылкам, которые начинаются с https:// */
a[href$=".jpeg"]     /* Применится к ссылкам, которые заканчиваются на .jpeg */
a[type="image/jpeg"] /* Применится к ссылкам, которые помечены атрибутом type как jpeg или jpg */`}
      </pre>

      <h3>Акценты внутри текста</h3>
      <ul>
        <li><code>&lt;i&gt;</code> - (от «italic», курсив), используется для отличающихся от окружающего текста элементов, например, иностранных слов или названий</li>
        <li><code>&lt;em&gt;</code> - (от «emphasis», акцент или ударение) используется, если смысл меняется, как в случае сарказма</li>
        <li><code>&lt;b&gt;</code> - (от «bold», жирный в вёрстке) используется для привлечения внимания, например, для выделения ключевых слов на странице</li>
        <li><code>&lt;strong&gt;</code> - означает повышенную важность</li>
        <li><code>&lt;s&gt;</code> - информация, которая важна, которая является частью контента, но больше не актуальна</li>
        <li><code>&lt;mark&gt;</code> - выделить то, что важно не вообще, а контекстуально: например, мы хотим в уже существующей цитате подчеркнуть какой-то кусок, который в оригинале не был выделен, но мы-то хотим обратить внимание читателей именно на него.</li>
      </ul>
      <p>Все они могут быть стилизованы по классу, или, раз уж это строчные элементы, которые не используются вне текстов, их стили можно переопределить по тегу.</p>
      <p>У обоих зачёркивающих тегов стиль по умолчанию — полоска в цвет шрифта, перечёркивающая символы в середине. Но стилизовать можно всё. Свойство, которое управляет этой полоской — text-decoration, у него есть расширения. Так, text-decoration-color: red; — и стандартное зачёркивание становится красным.</p>
      <p>Значения text-decoration</p>
      <ul>
        <li>line-through — зачёркивание посередине текста;</li>
        <li>overline — надчёркивание, над текстом;</li>
        <li>underline — подчёркивание, под текстом;</li>
        <li>none — не используется декор;</li>
        <li>inherit — наследуется.</li>
      </ul>
      <p>Или можно отключить стандартное зачёркивание (text-decoration: none;) и сделать любое другое с помощью псевдоклассов, или изменить цвет шрифта, сделав его блёклым. Или, например, сделать зачёркивание как в школе красной ручкой.</p>
      <img src="img/text/text-40.png" alt="" width="800" />
      <pre>{`<p>С тех пор, как мы перестали <s class="nope">пролезать</s> <s class="nope">влезать</s> лазить в окна любимых женщин...</p>
.nope {
  position: relative;
  text-decoration: none;
}

.nope::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 50%;
  border-bottom: 2px solid red;
  transform: rotate(-7deg);
}`}
      </pre>
      <p>Или крест накрест, чтобы наверняка!</p>
      <img src="img/text/text-41.png" alt="" width="800" />
      <pre>{`.nope {
  position: relative;
  text-decoration: none;
}

.nope::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 50%;
  border-bottom: 2px solid red;
  transform: rotate(-7deg);
}

.nope::after {
  position: absolute;
  top: 0;

  left: 0;

  content: "";
  left: 0;
  width: 100%;
  height: 50%;
  border-bottom: 2px solid red;
  transform: rotate(7deg);
}`}
      </pre>
      <p><code>&lt;mark&gt;</code>: По умолчанию это самое настоящее маркирование, как будто мы выделили что-то текстовыделителем, и значение примерно такое же. Стили по умолчанию можно сбросить: background-color: transparent; — и фон снова прозрачный, а не жёлтый, а можно переопределить, например, background-color: tomato;. Тег <code>&lt;mark&gt;</code> — строчный, и задавать ему фоны другого типа можно только переопределив его блочные характеристики.</p>

      <h4>Уточняет, что мы имели в виду</h4>
      <p><code>&lt;dfn&gt;</code>определяет термины, при этом непосредственный родитель этого тега (например, параграф кже должен относиться к термину и расшифровывать его значение. Обычно используется в сочетании с <code>&lt;abbr&gt;</code> — тегом для аббревиатур. Для этих тегов атрибут title выступает в значении «расшифровка», а id может связывать со ссылкой-якорем с расшифровкой внутри материала.</p>
      <p>Иногда можно встретить тег <code>&lt;acronym&gt;</code> с тем же значением, но он устарел и в современную спецификацию не вошёл.</p>

      <h4>Намекает на клавиатуру</h4>
      <p>Иногда нужно подчеркнуть, что указанный элемент — клавиша или комбинация клавиш на клавиатуре, для этого используется тег <code>&lt;kbd&gt;</code>. В спецификации указывается, что это может быть любой ввод, не только с клавиатуры, а и голосовые команды. Иногда входит в комплекс тегов, описывающих код, встроенный для объяснений или демонстрации работы программ, но это редкость и нужно для специализированных ресурсов.</p>
      <p>Стиль <code>&lt;kbd&gt;</code> по умолчанию — font-family: monospace;. Мы его переопределили так:</p>
      <pre>{`kbd {
  padding: 0 0.4em;
  font-weight: 700;                                  /* увеличивает насыщенность */
  box-shadow: inset -1px -1px 0 rgba(0, 0, 0, 0.25); /* создаёт вид клавиши */
  background-color: #f8f8f8;                         /* такой цвет, как у блоков с кодом */
}`}
      </pre>

      <h3>Направление текста и трансформация</h3>
      <p>Иногда нужно изменить направление текста, например, писать снизу вверх (скажем, это кнопка, автоматически прокручивающая страницу обратно в начало), или это может быть отражение текста в декоративных целях.</p>
      <p>Чаще всего это связано со вставкой отдельных слов или фраз на арабском, иврите или персидском. Для этих случаев используются комплексом два CSS-свойства: unicode-bidi: bidi-override;, которое сдвигает текст к другому краю, и direction: rtl;, которое изменяет направление текста (rtl — right to left, ltr — left to right).</p>
      <img src="img/text/text-42.png" alt="" width="800" />
      <pre>{`.palindrom {
  unicode-bidi: bidi-override;
  direction: rtl;
}`}
      </pre>
      <p>Если же речь идёт о декоративном изменении направления, то вступает свойство writing-mode. В спецификациях разного времени есть информация о разных значениях, мы приведём те, которые действуют сейчас.</p>
      <ul>
        <li>horizontal-tb — по умолчанию, как в русском языке. Сверху вниз, слева направо.</li>
        <li>vertical-rl — текст повёрнут на 90 градусов направо, читается справа налево.</li>
        <li>vertical-lr — текст повёрнут на 90 градусов направо, читается слева направо.</li>
      </ul>
      <img src="img/text/text-43.png" alt="" width="800" />
      <pre>{`.unsinn {
  max-height: 100px;
  writing-mode: vertical-rl;
}`}
      </pre>
      <p>С помощью трансформаций можно двигать, поворачивать и масштабировать элементы. Трансформация позволяет изменять отдельные элементы, не затрагивая все остальные. В нашем случае трансформацию можно применить для поворота текста. Но при этом свойство transform: rotate(90deg); повернёт не направление вывода текста, а контейнер.</p>
      <p>Метод поворота следует выбирать в зависимости от обстоятельств: блоки лучше трансформировать, а для текста — менять направление. Однако направление текста работает не во все стороны, и если нужно повернуть текст не направо, а налево, то придётся применить трансформацию, чтобы он выглядел так, как нам нужно.</p>
      <img src="img/text/text-44.png" alt="" width="800" />
      <pre>{`<button type="button" class="totop">Наверх</button>

.totop {
  position: absolute;
  top: 0;
  right: 0;
  padding: 10px 20px 10px 20px;

  font-family: "Montserrat", "Arial", sans-serif;
  font-weight: 500;
  font-size: 12px;
  line-height: 14px;
  color: #ffffff;

  border: none;
  background-image: linear-gradient(195.96deg, #ff5e62 0%, #ff9966 100%);
  border-radius: 8px 8px 0px 0px;

  transform: rotate(270deg);
  transform-origin: 100% 100%; /* устанавливает координаты точки, относительно которой будет поворот, по осям x и y */
}

.totop::after {
  content: " &bsol;2192"; /* встраивает стрелку в юникоде */
  font-size: 14px;
}`}
      </pre>
      <p></p>
      <img src="img/text/text-45.png" alt="" width="800" />
      <pre>{`<article>
  <h1 class="text-heading">Интеллект в XXI веке</h1>
</article>

.text-heading {
  position: relative;

  width: 60px;
  padding: 20px 0;

  writing-mode: vertical-rl;

  font-family: "Montserrat", "Arial", sans-serif;
  font-style: normal;
  font-weight: 300;
  font-size: 30px;
  line-height: 60px;
  letter-spacing: 0.02em;
  text-transform: uppercase;
  color: #ffffff;

  background-image: linear-gradient(7deg, #a7bfe8 0%, #6190e8 100%);
}

.text-heading::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: -25px;
  border-left: 30px solid #a7bfe8;
  border-right: 30px solid #a7bfe8;
  border-bottom: 25px solid transparent;
}`}
      </pre>

      <h3>Использование верхнего и нижнего индекса для формул и не только</h3>
      <p>В спецификации рекомендуют использовать <code>&lt;sup&gt;</code> (верхний индекс) и <code>&lt;sub&gt;</code> (нижний индекс) только по типографским причинам. Для добавления тексту эффекта «прыгающих» букв лучше использовать другие способы.</p>
      <p>В большой статье не обойтись без сносок, на этот случай идеально подходит тег sup.</p>
      <pre>{`<div class="container">
  <p>HTML5 (англ. HyperText Markup Language, version 5) — язык для структурирования и представления содержимого всемирной паутины. Это пятая версия HTML. Хотя стандарт был завершён (рекомендованная версия к использованию) только в 2014 году<sup><a href="#">[1]</a></sup><sup><a href="#">[2]</a></sup> (предыдущая, четвёртая, версия опубликована в 1999 году<sup><a href="#">[3]</a></sup>), уже с 2013 года<sup><a href="#">[4]</a></sup> браузерами оперативно осуществлялась поддержка, а разработчиками — использование рабочего стандарта (англ. HTML Living Standard).
  </p>
</div>

.container {
  width: 800px;
  margin: 0 auto;
}

.container p {
  line-height: 1.7;
}`}
      </pre>
      <p>Верхние и нижние индексы активно применяются в математике, физике, химии, для обозначения единиц измерения</p>
      <p>В спецификации рекомендуется переменные и параметры функции оборачивать тегом <code>&lt;var&gt;</code>, используем и его в разметке. Теги регистров можно вкладывать друг в друга, иногда это пригождается для формул.</p>
      <pre>{`<p>Полиномиальное уравнение степени <em>n</em>:</p>
<p class="formula">
  f(<var>x</var>) = <var>a<sub>0</sub></var> + <var>a<sub>1</sub></var> <var>x</var> + ... +
   <var>a<sub>n-1</sub></var> <var>x<sup>n-1</sup></var> +
   <var>a<sub>n</sub></var> <var>x<sup>n</sup></var>
</p>

body {
  padding: 2em;
  font: 1em/1.5 "Open Sans", sans-serif;
  color: #333;
}

.formula {
  font-size: 1.6em; /* Размер текста */
  font-style: italic; /* Курсивное начертание */
}

.formula sup {
  font-style: normal; /* Нормальное начертание */
  font-size: 0.6em; /* Размер индекса */
  color: red; /* Цвет верхнего индекса */
  vertical-align: 0.8em; /* Сдвигаем текст вверх */
}

.formula sub {
  font-style: normal; /* Нормальное начертание */
  font-size: 0.6em; /* Размер индекса */
  color: blue; /* Цвет нижнего индекса */
  vertical-align: -0.5em; /* Сдвигаем текст вниз */
}`}
      </pre>
      <p>Далеко не все формулы можно добавить на страницу с помощью тегов. Формулы, содержащие квадратные корни, интегралы, дроби получится добавить на сайт лишь используя специализированные инструменты (MathML, TeX и подобные) или с помощью изображения.</p>

      <h3>Таблицы</h3>
      <p>Таблицы используются для того, чтобы отображать связанные данные. Для связанных данных типа «ключ + значение» зачастую используются списки определений (тег <code>&lt;dl&gt;</code>), а если данных больше (например, типы товаров, количества и цены, или любые другие) — таблицы будут самым правильным выбором.</p>
      <p>Часто в таблицах добавляют заголовочные ячейки и используют для этого тег <code>&lt;th&gt;</code> (table header cell). Также у таблицы может появиться подпись, тогда она вставляется внутри тега caption. Подпись размещается как вне тега <code>&lt;table&gt;</code>, так и внутри него. Во втором случае это значительно облегчает его понимание. Управлять положением подписи можно с помощью CSS-свойства caption-side. caption-side принимает одно их двух значений: top и bottom.</p>
      <img src="img/text/text-46.png" alt="" width="800" />
      <pre>{`<table>
  <caption>Товары в чеке</caption>
  <tr>
    <th>№ п/п</th>
    <th>Наименование товара</th>
    <th>Ед. изм.</th>
    <th>Количество</th>
    <th>Цена за ед. изм., руб.</th>
    <th>Стоимость, руб.</th>
  </tr>
  <tr>
    <td>1.</td>
    <td>Картофель (свежий урожай)</td><td>кг</td><td>3,20</td><td>69,00</td><td>220,80</td>
  </tr>
  <tr>
    <td>2.</td>
    <td>Капуста</td><td>кг</td><td>1,50</td><td>32,00</td><td>48,00</td>
  </tr>
  <tr>
    <td>3.</td>
    <td>Морковь</td><td>кг</td><td>0,50</td><td>48,00</td><td>24,00</td>
  </tr>
  <tr>
    <td colspan="5">Итого:</td><td>292,80</td>
  </tr>
</table>`}
      </pre>
      <img src="img/text/text-47.png" alt="" width="800" />
      <pre>{`<figure>
  <figcaption>Победители забега на 20 км</figcaption>
  <p>Данные от 20 июля 2018 года, Ленинградская область, Сестрорецк</p>
  <table>
    <thead>
      <tr>
        <th>Место</th>
        <th>Женщины</th>
        <th>Мужчины</th>
        <th>Общий взрослый зачёт</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1 место</td>
        <td>Ирина М.</td>
        <td>Владимир П.</td>
        <td>Инга А.</td>
      </tr>
      <tr>
        <td>2 место</td>
        <td>Марина Л.</td>
        <td>Олег Д.</td>
        <td>Василий К.</td>
      </tr>
    </tbody>
  </table>
</figure>`}
      </pre>
      <p>Обычно таблицы стилизуют по строкам (таблицы-зебры), при этом используется псевдокласс :nth-child и значения even и odd.</p>
      <pre>{`tr:nth-child(even) {
  background-color: #cccccc;
}

tr:nth-child(odd) {
  background-color: #ffffff;
}`}
      </pre>
      <p>Но можно стилизовать и по столбцам, для этого после описания вставляется группа <code>&lt;colgroup&gt;</code>, которая содержит элементы <code>&lt;col&gt;</code>. К <code>&lt;col&gt;</code> могут применяться атрибуты span с числовым значением, равным количеству столбцов, которые захватывает колонка. Добавить стили для столбцов можно традиционными способами — через добавление класса и стилизацию по классу (атрибут class) или через встроенные стили (атрибут style).</p>
      <img src="img/text/text-48.png" alt="" width="800" />
      <pre>{`<table>
  <caption>Супергерои и их питомцы</caption>
  <colgroup>
    <col>
    <col span="2" class="superman">
    <col span="2" class="falcon">
  </colgroup>
  <tr>
    <td></td>
    <th>Супермен</th>
    <th>Крипто</th>
    <th>Сокол</th>
    <th>Редвинг</th>
  </tr>
  <tr>
    <th>Суперспособности</th>
    <td>Суперслух, суперобоняние и суперзрение</td>
    <td>Обладает теми же способностями, что и Супермен</td>
    <td>Способен общаться с Редвингом на расстоянии многих метров, а также видеть его глазами</td>
    <td>Телепатическая связь с Соколом, способен видеть глазами Сокола, и отлично понимает его команды</td>
  </tr>
</table>
Стили:

table {
  border-collapse: collapse;
  border: 2px solid rgb(100, 100, 100);
}

td,
th {
  border: 1px solid rgb(100, 100, 100);
  padding: 10px 10px;
}

td {
  vertical-align: top;
  text-align: center;
}

.superman {
  background-color: #d7d9f2;
  width: 200px;
}

.falcon {
  background-color: #ffe8d4;
  width: 220px;
}`}
      </pre>
      <p><code>&lt;colgroup&gt;</code> предназначен для задания ширины и стиля одной или нескольких колонок таблицы. Этот элемент позволяет уменьшить код таблицы за счёт сокращения повторяющихся атрибутов. Но не все CSS-свойства можно настроить. Для <code>&lt;colgroup&gt;</code> допустимо использовать следующие CSS-свойства: border, background, width, visibility. Остальные свойства не оказывают никакого эффекта на элемент.</p>
      <p>В таблицах можно управлять границами. Для этого используйте свойство border, с которым вы уже хорошо знакомы. Для таблиц есть свойство border-collapse, которое отвечает за слияние рамок между собой. Если задать рамку всей таблице, а потом задать рамки ячейкам, то у каждой ячейки будет как бы своя рамка. Значение по умолчанию — separate, а значение collapse заставляет рамки слиться, и никаких промежутков между ними не будет.</p>
      <pre>{`table {
  border-collapse: collapse; /* убирает промежутки между ячейками */
  border: 2px dotted red;    /* настраивает вид границ */
  border-radius: 10px;       /* скругляет внешнюю границу */
}`}
      </pre>

      <h3>Колонки на странице</h3>
      <p>При всём ажиотаже вокруг технологий CSS Grid и Flexbox, часто упускается из виду другой шаблон вёрстки — многоколоночный макет (Multicol или CSS Columns). Основная идея мультиколонок заключается в том, что вы можете взять фрагмент содержимого и поместить его в несколько колонок, как в газете.</p>
      <p>Для добавления мультиколонок достаточно определить одно из CSS-свойств: column-count и column-width. column-width указывает минимальную ширину, которую должен занимать каждый столбец. column-count описывает количество колонок (ширина колонок будет рассчитываться, исходя из ширины доступного пространства). Если одновременно задаются column-count и column-width, то значение column-count будет считаться максимальным числом колонок.</p>
      <pre>{`.article {
  column-width: auto;  /* автоматически рассчитается от количества колонок */
  column-width: 100px; /* фиксированный размер */
}`}
      </pre>
      <p>Ширина колонок задаётся в любых единицах длины, кроме %. Фактическая ширина столбца может быть больше (для заполнения доступного пространства) или уже (только если доступное пространство меньше указанной ширины столбца). Отрицательные значения не допускаются. Используемые значения будут ограничены минимум 1px.</p>
      <p>Также используется сокращённое CSS-свойство columns для установки column-width и column-count одновременно (если одно из значений не установлено — берутся их начальные значения).</p>
      <pre>{`.article {
  columns: 12em;      /* column-width: 12em; column-count: auto */
  columns: auto 12em; /* column-width: 12em; column-count: auto */
  columns: 2;         /* column-width: auto; column-count: 2 */
  columns: 2 auto;    /* column-width: auto; column-count: 2 */
}`}
      </pre>

      <h4>Стилизация колонок</h4>
      <p>Блоки колонок, созданные с помощью свойств CSS Columns, не могут быть выбраны для стилизации. Поэтому не получится стилизовать отдельный блок и задать ему цвет фона или настроить padding или margin. Все блоки колонок будут одинакового размера. Единственное, что можно сделать — это добавить разделительную линию между колонками, используя CSS-свойство column-rule (свойство является сокращённой записью свойств column-rule-width, column-rule-style и column-rule-color).</p>
      <p>Ещё можно настроить отступ между колонками с помощью CSS-свойства column-gap.</p>

      <h4>Охват колонок</h4>
      <p>Порой вам может потребоваться разбить некоторый контент на колонки, но затем один элемент разместить поперёк, охватив блоки всех колонок. Достигнуть этого можно, применив CSS-свойство column-span к потомку колоночного контейнера. Свойство может принимать лишь два значения: none (содержимое элемента отображается в одной колонке, это поведение по умолчанию) и all (элемент охватывает все колонки).</p>
      <img src="img/text/text-49.png" alt="" width="800" />
      <pre>{`blockquote {
  margin: 20px 0 20px 0;
  column-span: all;
  text-align: center;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  column-width: 14em;
  column-gap: 2em;
  column-rule: 1px solid #ccc;
}`}
      </pre>
      <p>Заметьте, когда вы делаете это, содержимое разбивается на набор полей выше этого элемента, затем начинает новый набор колонок ниже него. Содержимое не перепрыгивает через охватывающий элемент.</p>

      <h4>Управление переносом в колонках</h4>
      <p>Для решения этого вопроса было введено три новых свойства для управления разрывом столбцов: break-before (перед элементом), break-after (после элемента) и break-inside (внутри элемента). Эти свойства схожи по поведению с набором свойств page-break-*. В примере ниже CSS-свойство break-inside: avoid для элемента <code>&lt;figure&gt;</code> предотвращает отделение подписи от самой картинки.</p>
      <img src="img/text/text-50.png" alt="" width="800" />
      <pre>{`<div class="container">
  <p>Мы рождаемся и живём, даже не замечая, как в нашу жизнь входят новые технологии, впоследствии изменяя саму жизнь! Но какие же технологии дали толчок в глобальной сфере?</p>

  <h2>Смартфоны</h2>

  <figure>
    <img src="https://source.unsplash.com/300x400" alt="Изображение 1">
    <figcaption>Смартфоны</figcaption>
  </figure>

  <p>Практически у каждого уже есть смартфон. Это настолько удивительная вещь, вы просто задумайтесь, в вашем аппарате есть доступ к всемирной библиотеке , вы можете общаться с людьми в другой части света и многое другое! Часто люди не замечают, насколько они счастливы!</p>

  <h2>Социальные сети и мессенджеры</h2>

  <figure>
    <img src="https://source.unsplash.com/300x402" alt="Изображение 2">
    <figcaption>Социальные сети и мессенджеры</figcaption>
  </figure>

  <p>Не пройдёт ни одного дня, чтобы ни один человек не зашёл в мессенджер или социальную сеть. Эти технологии позволяют общаться с людьми на далёких расстояниях, найти друзей, повеселиться. Многие даже не представляют свою жизнь без них.</p>
</div>
Стили:

figure {
  margin: 0;
  break-inside: avoid;
}

figcaption {
  text-align: center;
}

img {
  max-width: 100%;
}

h2 {
  break-after: avoid;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  column-width: 14em;
}`}
      </pre>
      <p>Часто колонки используют в текстовых абзацах и, как правило, безразлично, разбивается какой-либо из абзацев на несколько столбцов или нет. Но иногда это бывает неудобно. Скажем, у блоков есть свои фоны и отступы и переносы выглядят довольно странно. Помимо, разобранного выше, свойства break-inside: avoid;, можно воспользоваться CSS-трюком, в котором для абзаца CSS-свойство display устанавливают в значение inline-block. Пример ниже демонстрирует этот эффект.</p>
      <img src="img/text/text-51.png" alt="" width="800" />
      <pre>{`<div class="columns">
  <p>Нет сомнений в том, что правильное питание идёт на пользу организму. Ведь мы – это то, что мы едим. О здоровом питании нам твердят со страниц журналов и экранов телевизоров. Что означает «питаться правильно»? Как сделать так, чтобы еда пошла на пользу и извлечь максимум ценных веществ из продуктов?</p>
  <p>Здоровое питание – что это?</p>
  <p>Все знают, что нужно питаться правильно. Но что на самом деле кроется за этим понятием? Здоровым считается такое питание, при котором человеку обеспечивается полноценное развитие, рост, жизненная энергия и отличное самочувствие. Наукой доказано его положительное влияние на организм, особенно в сочетании с физическими упражнениями.</p>
  <p>Многие учёные сошлись во мнении, что здоровая пища способствует долголетию и предупреждает ожирение, развитие сахарного диабета, проблемы с сердцем и сосудами, гипертонию.</p>
  <p><mark>Питаться правильно – значит не только следить за калорийностью пищи, кратностью приёмов, но и разнообразить ее.</mark></p>
  <p>Необходимо, чтобы в рацион входили продукты из разных групп:</p>
  <ul>
    <li>овощи</li>
    <li>фрукты</li>
    <li>злаки</li>
    <li>молочные и кисломолочные продукты</li>
    <li>мясо и рыба</li>
  </ul>
  <p>Монодиеты (состоящие из одного продукта) в значительной мере лишают организм большого количества питательных веществ. Оставаться в нормальном весе можно и употребляя все вышеперечисленное.</p>
</div>
.columns {
  columns: 200px auto;
  column-gap: 20px;
  column-rule: 1px solid #cccccc;
  max-width: 800px;
  margin: 0 auto;
}

.columns p {
  background-color: #a2e5fc;
  padding: 1em;
  margin: 0 0 1em 0;
}

.columns mark {
  background-color: #fcb9a2;
}`}
      </pre>

      <h4>Где лучше применять мультиколонки</h4>
      <p>Первое — это небольшой список элементов, который должен занимать меньше пространства. Например, простой список чекбоксов или список имен.</p>
      <p>Колонки удобно использовать для небольшого введения в статьях блога/тематических статьей.</p>
      <p>Также колонки хорошо подходят для подборки анонсов статей в подвале сайта.</p>
      <p>Другой пример, когда колоночный макет отлично работает — в ситуациях, когда вы хотите отобразить содержимое в стиле Masonry. Этот вид раскладки используется на сайтах pinterest.ru, veerle.duoh.com. Колонки в данный момент — это единственный метод стилизации, который создаст нужный тип сетки с элементами разной высоты без дополнительных хаков. Единственный нюанс, который портит картину, связан с доступностью: фокусировка на элементах при навигации с клавиатуры будет идти сначала сверху вниз и только потом слева направо, в то время как доступный интерфейс должен фокусироваться по рядам, а потом по колонкам.</p>

      <h3>Переполнение текстом, однострочное и многострочное</h3>
      <p>Если контейнер, содержащий текст, имеет конкретные размеры, то судьба того, что за эти размеры вылезает, решается свойством overflow. По умолчанию у свойства значение visible, и контент выходит за границы контейнера и может находить на соседние блоки. Со значением overflow: hidden всё, что не поместилось, просто обрежется. Значение auto в случаях переполнения контейнера выводит полосу прокрутки. Если полоса прокрутки нужна всегда, выбирается overflow: scroll. Свойство overflow обрабатывает действия при переполнении контентом по горизонтали и вертикали. Если нужно управлять одним из направлений, используется overflow-x для горизонтальной оси и overflow-y для вертикальной.</p>

      <h4>Однострочный длинный текст</h4>
      <p>CSS-свойство text-overflow применяется для управления переполнением текста. У свойства есть два основных значения: clip для обрезания содержимого, которое не поместилось, и ellipsis для подстановки многоточия вместо невошедшей части. Значение text-overflow: ellipsis обычно и применяется в таких ситуациях, и многоточие возникает в самом лучшем случае после случайного слова. То есть смысл фразы может быть безвозвратно испорчен.</p>
      <p>Для удобства пользователя элементу можно добавить атрибут title с полным текстом. В таком случае на компьютерах при наведении курсора на «сокращённый» текст будет появляться подсказка с полным текстом.</p>

      <h4>Многострочный длинный текст</h4>
      <p>Для случая, если необходимо поместить в ограниченную область не одну строку, а несколько, не всё так просто. CSS-свойство text-overflow: ellipsis для таких элементов не работает. И тут приходиться использовать все возможные «костыли» и «хаки».</p>

      <h5>Обрезание после определённой строки</h5>
      <p>Для этого существует CSS-свойство -webkit-line-clamp. Свойство отрезает строки после указанного их числа. свойство работает только в паре с другим устаревшим проприетарным свойством display: -webkit-box. И ещё такой метод может оборвать строку в неудачном месте, и смысл высказывания может поменяться.</p>
      <p>В старых версиях браузера Opera также работает проприетарное значение text-overflow: -o-ellipsis-lastline. Свойство отрезает часть строки снизу.</p>
      <img src="img/text/text-52.png" alt="" width="800" />
      <pre>{`<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Modi ullam amet eaque reiciendis libero possimus et aperiam consequuntur numquam atque sequi fugit aut voluptatum ad, id dignissimos nisi porro veritatis, accusantium neque obcaecati ut repudiandae, quisquam. Similique, quam dolores voluptatibus enim architecto recusandae molestiae soluta. Explicabo ex, reiciendis delectus quisquam, fugiat iusto tempore maiores alias voluptates ratione ipsum ad cupiditate, libero vero cumque dolorum quaerat.</p>
p {
  width: 780px;
  overflow: hidden;
  padding: 0.5em;

  display: -webkit-box;

  text-overflow: ellipsis;
  line-height: 1.5em;

  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}`}
      </pre>

      <h5>Скрытие лишнего текста за декоративными элементами</h5>
      <p>В этом методе с помощью псевдоэлемета ::after добавляется полупрозрачный слой с градиентной заливкой и часть символов последней поместившейся строки уходит в непрозрачную область.</p>
      <img src="img/text/text-4.png" alt="" width="800" />
      <pre>{`<div class="module fade">
  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Modi ullam amet eaque reiciendis libero possimus et aperiam consequuntur numquam atque sequi fugit aut voluptatum ad, id dignissimos nisi porro veritatis, accusantium</p>
</div>
.module {
  width: 780px;
  margin: 0 0 1em 0;
  overflow: hidden;

  font-family: "Merriweather", "Georgia", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 20px;
  line-height: 32px;
  color: #333333;
}

.fade {
  position: relative;
  height: 5.9em; /* высота в три строки */
}

.fade::after {
  content: "";
  position: absolute;
  bottom: 0;
  right: 0;
  width: 70%;
  height: 1.2em;

  text-align: right;

  background: linear-gradient(to right, rgba(255, 255, 255, 0),
rgba(255, 255, 255, 1) 50%);
}`}
      </pre>
      <p>Полупрозрачный декоративный элемент может размещаться по всей ширине нижней границы</p>
      <pre>{`.module {
  width: 780px;
  margin: 0 0 1em 0;
  overflow: hidden;

  font-family: "Merriweather", "Georgia", serif;
  font-style: normal;
  font-weight: normal;
  font-size: 20px;
  line-height: 32px;
  color: #333333;
}

.fade {
  position: relative;
  height: 5.9em; /* высота в три строки */
}

.fade::after {
  content: "";
  position: absolute;
  bottom: 0;
  right: 0;
  left: 0;
  width: 100%;
  height: 1.2em;

  text-align: right;

  background: linear-gradient(to bottom, rgba(255, 255, 255, 0),
rgba(255, 255, 255, 1) 70%);
}`}
      </pre>

      <h4>Использование JavaScript</h4>
      <p>В этом способе предполагается, что контейнер для длинного текста имеет известную фиксированную высоту, и в ходе выполнения JavaScript рассчитывается, какой текст помещается в необходимую область, а всё что не поместилось — отбрасывается и добавляется символ ….</p>
      <p>Но JS не выполняется сразу при показе страницы и может произойти «мигание», когда вёрстка уже отобразилась, а затем в течение некоторого времени отрабатывает скрипт, подрезающий текст. Подрезки в принципе не произойдёт, если JS отключён или не догрузился. К тому же расчёт, который выполняется в скрипте, увеличивает нагрузку и может привести к подвисанию сайта.</p>

      <h4>Обрезка текста на веб-сервере</h4>
      <p>В этом случае с сервера отдаётся уже готовая вёрстка с отрезанной частью текста, сам расчёт длины строки и места отреза производится в бэкенд-коде. Расчёт обычно проводится по количеству символов, а это значит, что слово может быть обрезано в середине. Сделать «умный расчёт» возможно, но это, конечно, усложнит задачу.</p>
      <p>Способ не универсальный, так как интерфейс может измениться, а в этом случае придётся менять и серверную часть сайта.</p>

      <h3>Перенос строк и слов</h3>
      <h4>Перенос слов</h4>
      <p>Очень рекомендуется на пробу в элементы вставлять тексты «любого размера», то есть большие по объёму (в разы больше, чем предполагается на первый взгляд). Это позволит оценить последствия переполнений, вид фона, общую типографику.</p>
      <p>Не рекомендуем разрешать перенос слов в ситуации переполнения текстом: нанесёт непоправимый вред смыслу.</p>
      <p>Решение о переносе слов в ситуации большого объёма текста (новость, пост, статья…) стоит принимать, исходя из того, выравнивается текст по ширине или нет. Если выравнивается — стоит включить перенос слов, иначе пробелы между словами могут увеличиваться до некомфортного для чтения размера. Но обычно читать текст без выравнивания приятнее и удобнее, и в ситуации «рваного» правого края перенос слов не нужен.</p>
      <p>Для узких колонок, где некоторые слова наверняка не поместятся, было бы идеально использовать CSS-свойство hyphens. Со значением auto оно использует браузерный словарь переносов и не калечит слова. Но работает свойство, если посмотреть, только в Firefox</p>
      <p>Тег <code>&lt;wbr&gt;</code> несовершенен: он переносит слово в выбранном вами месте, но дефис (показатель переноса) не проставляет.</p>
      <p>Свойство word-break можно применить хоть ко всему сайту, но оно не учитывает грамматику, так что слова будут переноситься ровно в том месте, где слово упёрлось в границу контейнера.</p>
      <p>Существуют и другие свойства: overflow-wrap: break-word переносит части слова, только если они не помещаются в контейнер. То есть в примере про человеконенавистничество слово начнётся с новой строки, а потом уже то, что вообще в строку не поместилось, перенесётся ещё раз. К сожалению, перенесётся без дефиса и учёта грамматики.</p>
      <p>Остаётся специальный символ-мнемоника ­&amp;shy;: он проставляет дефис, но годится этот символ только для единичных случаев, ведь его нужно проставлять вручную.</p>
      <p>К сожалению, раз в CSS нет универсального инструмента, то и выяснить заранее, где нужно подставить «костыль» (не самое корректное, но работающее решение) — почти невозможно. Мы предпочитаем ограничивать количество мест, где перенос вообще нужен, например, в боковых врезках.</p>
      <p>Наш вывод: нужно либо использовать уже существующий типограф, либо писать свой инструмент, который в словах длиннее, например, пятнадцати символов, будет проставлять грамматически правильные &amp;shy;. Ещё можно вспоминать правила переносов (вот статья на Грамоте), сверяться с сайтами, которые уже сделали это для вас (по запросу «словарь переносов слов» выпадает довольно много словарей).</p>
      <p>Если вы делаете переносы вручную — постарайтесь не переносить по две буквы, лучше членить слово, учитывая семантику.</p>
      <pre>{`<!-- Не обязательно делать это так. Но так — можно, достаточно грамотно и не слишком мелко «нарезано» -->

<!-- Одиннадцатиклассница получила неудовлетворительно и отправилась на водогрязеторфопарафинолечение от стресса. -->

<p>Один&shy;надцати&shy;класс&shy;ница получила неудов&shy;ле&shy;тво&shy;ри&shy;тельно и отпра&shy;вилась на водо&shy;грязе&shy;торфо&shy;парафино&shy;лечение от стресса.</p>`}
      </pre>
      <p>Для того, чтобы понять, как на самом деле будет выглядеть дизайн, нужны правдоподобные тексты: состоящие из слов разной длины, со знаками препинания. В такой ситуации зачастую пишется текст-плейсхолдер, и такие тексты называются «рыбами». Многие используют классический текст-рыбу «Lorem ipsum dolor sit amet, consectetur adipiscing elit,.», но он не подходит, когда сайт русскоязычный, потому что в русском языке по-другому работают правила типографики, другая пунктуация, кавычки, в конце концов, в русском языке больше средняя длина слов.</p>

      <h3>Буквицы и красная строка</h3>
      <h4>Буквицы</h4>
      <p>Буквица — первая буква абзаца, выделяется в исключительно декоративных целях. Не рекомендуется начинать с буквицы каждый абзац: это дурной тон. Не для каждого дизайна концепция буквицы подходит. Нельзя сказать, будто буквица — это что-то из ряда вон для веба, но и не на каждом сайте встречается. Мы нашли немало вариантов в сети, но в основном это не слишком интересные буквицы: они просто увеличенного кегля.</p>
      <p>Базовая линия буквицы обычно находится ниже (иногда — существенно) базовой линии первой строки текста. Тогда ей обычно приписывают float и отступы.</p>
      <p>Не стоит делать буквицы картинками, по крайней мере напрямую. Это делается за счёт написания первого слова без первой буквы, что ведёт к целой куче проблем: нельзя изменить начертание для мобильных устройств, индексация, ридеры и «версии для слабовидящих» будут воспринимать текст неверно и так далее.</p>
      <p>Самый понятный, специально придуманный инструмент для работы с буквицей в CSS — псевдоэлемент ::first-letter. Он позволяет сделать буквицей каждую первую букву каждого абзаца. Как вы понимаете, это может смотреться гротескно. Особенно, если сделать буквы ещё крупнее и, возможно, применить какой-нибудь изощрённый шрифт.</p>
      <p>Кроме того, псевдоэлемент ::first-letter может примениться к тем объектам, которые вы не учли: изображениям, встроенным перед текстом, или к другим строчным объектам, или к контенту, внедрённому с помощью псевдоэлемента ::before.</p>
      <p>Другой подход — заворачивать в <code>&lt;span&gt;</code> с классом те буквы, которые будут крупнее. Или делать буквицы только у лидов.</p>
      <img src="img/text/text-54.png" alt="" width="800" />
      <pre>{`article {
  max-width: 800px;
  padding: 30px;

  font-family: "Montserrat", "Arial", sans-serif;
  font-size: 16px;
  line-height: 28px;
}

.leading-paragraph {
  font-size: 24px;
  line-height: 32px;
  font-style: italic;
}

.leading-paragraph::first-letter {
  float: left;
  margin-right: 4px;

  font-size: 54px;
  line-height: 0.3em;
  font-weight: 600;
  color: #ff6b00;
}`}
      </pre>
      <p>Или можно использовать в селекторах «фильтрующие» псевдоклассы, например, :first-of-type.</p>
      <pre>{`p:first-of-type::first-letter {
  float: left;
  margin-right: 4px;

  font-family: "Kelly Slab", "Arial", cursive;
  font-size: 54px;
  line-height: 56px;
  color: #ff6b00;
}`}
      </pre>

      <h4>Красная строка</h4>
      <p>С «красной строки» пишут сочинения, эссе для ЕГЭ и параграфы в актах. Насколько этот элемент актуален и нужен для веба — предмет дискуссий. Концепция, что «красная» строка значит «красивая», критики не выдерживает, сейчас отступ первой строки каждого абзаца выглядит скорее бюрократическим элементом.</p>
      <p>Скорее всего, в советской типографике красная строка должна была помочь найти первую строку абзаца в условиях экономии места: отступы между абзацами не увеличивали, чтобы сэкономить на бумаге. Но в вебе нет проблемы нехватки места, и красная строка может быть нужна исключительно как декоративный элемент, например, для стилизации под советскую печать или под формальный документ.</p>
      <p>Красная строка задаётся свойством text-indent, значения могут быть положительные или отрицательные, абсолютные и относительные. Лучше всего выглядит при выравнивании текста по ширине.</p>
      <pre>{`article {
  padding: 0 50px;
  text-align: justify;
}

p:first-of-type {
  text-indent: -2em;
}`}
      </pre>
      <p>Красная строка, как и буквица, применяется редко, подразумевается как претензия на оригинальность, не применяется вместе с другими декоративными элементами.</p>
      <p>Для стилизации первой строки можно использовать псевдоэлемент ::first-line:</p>
      <img src="img/text/text-55.png" alt="" width="800" />
      <pre>{`article {
  color: #000000;
}

p::first-line {
  background-color: #ff7931;
  color: #ffffff;
}`}
      </pre>
      <p>К сожалению, стилизация псевдоэлемента ::first-line ограничена: можно менять только параметры шрифта, фона и цвет теста.</p>

      <h3>Сложные обтекания</h3>
      <p>Нестандартное обтекание (по кругу, по диагонали и даже зигзагами) можно создавать с помощью CSS-свойств clip-path и shape-outside. Для этого нужно создать форму, которую будет обтекать текст, а иногда ещё — вырезать ту же форму из иллюстрации, которую мы обтекаем.</p>

      <h4>Вырезание формы из объекта</h4>
      <p>Свойство clip-path позволяет «отсечь» лишнее, как бы вырезать. <a href="https://www.w3.org/TR/css-masking-1/" target="_blank" rel="noopener noreferrer">Спецификация</a> достаточно подробно и наглядно поясняет, в чём разница между маскированием и вырезанием. Процесс вырезания позволяет задать замкнутый контур для вырезания. Он может быть вычисляемым, или может описываться стандартными свойствами.</p>
      <p>Теоретически существует три способа обрезки изображений: с помощью встроенных вариантов фигур (polygon, circle, ellipse и inset), с помощью инлайнового SVG и со вставкой SVG или PNG как формы для обтекания. На практике хорошо работает обрезка фигуры многоугольником (polygon) и кругом (circle). Реже используется, но хорошо работает обрезка эллипсом (ellipse).</p>

      <h4>Много (много-много)угольник</h4>
      <p>Это фигура, позволяющая задать точки, которые потом будут соединены линиями контура для обрезки. Синтаксис такой:</p>
      <pre>{`{
  clip-path: polygon(x1 y1, x2 y2, x3 y3, …);
}`}
      </pre>
      <p>Оси x и y чаще описываются в процентах, но, теоретически, можно использовать любые доступные единицы измерения. Например, clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%).</p>
      <img src="img/text/text-56.png" alt="" width="800" />
      <p>Соответственно, линии протягиваются в том порядке, в котором идут точки. Точек может быть любое количество, что позволяет сделать довольно плавные скругления.</p>
      <p>Вот типичный пример на чистом CSS. Обратите внимание, что фон, из которого мы будем вырезать, оформлен как отдельный блочный элемент. Семантически это не совсем правильно, потому что картинка, которая иллюстрирует текст, должна быть контентной — встроенной в вёрстку. Но, к сожалению, иногда «эффекты» требуют жертв.</p>
      <img src="img/text/text-57.png" alt="" width="800" />
      <pre>{`<div class="container">
  <!-- да, это пустой блок для стилизации -->
  <div class="shaped"></div>
  <div class="content">
    <h1>Почему мгновенно восприятие?</h1>
    <p>...</p>
  </div>
</div>
.shaped {
  /* встроили изображение */
  background-image: url("/img/pic.jpg");
  background-repeat: no-repeat;
  background-position: center top;
  background-size: cover;

  height: 250px;
  width: 350px;

  float: right; /* обтекает по левому краю картинки */
  clip-path: polygon(0 50%, 50% 0, 100% 0, 100% 100%); /* параметры формы для вырезания */
}`}
      </pre>

      <h4>Обтекание вырезанной формы текстом: как это работает</h4>
      <p>А теперь нужно получившуюся форму обтечь. Для этого обычно используется свойство shape-outside. У него есть все те же значения, что и у clip-path, и это делает их совместное использование весьма удобным. Например:</p>
      <pre>{`{
  clip-path: polygon(0 50%, 50% 0, 100% 0, 100% 100%);     /* параметры формы для вырезания */
  shape-outside: polygon(0 50%, 50% 0, 100% 0, 100% 100%); /* параметры формы для обтекания */
}`}
      </pre>
      <p>А теперь мы хотим, чтобы между ними был отступ. Для этого существует специальное свойство shape-margin, но работает оно не слишком очевидно. shape-margin создаёт новые точки, которые находятся на указанном расстоянии от точек обтекания, и потом обводит получившиеся точки. Применение этого свойства на реальных кейсах иногда даёт странные результаты. Для добавления отступа между формой и текстом вполне подойдёт обычный внешний отступ справа или слева, CSS-свойства margin-right: 20px; и margin-left: 20px; соответственно.</p>
      <p>Код, который может получиться в этой ситуации:</p>
      <pre>{`.shaped {
  float: left;                 /* с какой стороны будет обтекание */
  /* конкретные параметры элемента позволят задавать параметры фигуры и обтекания */
  height: 606px;
  width: 180px;
  clip-path: polygon(...);     /* значения границ вырезанной фигуры */
  shape-outside: polygon(...); /* значения границ обтекания */
  margin-right: 20px;          /* отступ от границы обтекания */
}`}
      </pre>
      <p>А теперь мы хотим, чтобы текст «струился» между границами двух вырезанных фигур.</p>
      <img src="img/text/text-58.png" alt="" width="800" />
      <pre>{`<div class="double-shaped">
  <h2 class="shaped-left">Персональный предмет искусства</h2>
  <figure class="shaped-right">
    <img src="img/pic-1.jpg" width="370" height="385" alt="pic-1">

  <p>...</p>
</div>
.shaped-left {
  width: 170px;
  height: 385px;
  float: left;                                           /* обтекаем слева */
  shape-outside: polygon(0 0, 100% 0, 68% 100%, 0 100%); /* обтекаем по заданной форме */
  clip-path: polygon(0 0, 100% 0, 68% 100%, 0 100%);     /* вырезаем объект нужной формы */
  margin-right: 10px;
}

.shaped-right {
  width: 370px;
  height: 385px;
  float: right;                                             /* обтекаем справа */
  shape-outside: polygon(0 0, 100% 0, 100% 100%, 32% 100%); /* обтекаем по заданной форме */
  clip-path: polygon(0 0, 100% 0, 100% 100%, 32% 100%);     /* вырезаем объект нужной формы */
  margin-left: 10px;
}`}
      </pre>
      <p>Что может быть проще? Одна фигура обтекается справа, другая слева.</p>

      <h4>Другие формы для вырезания и обтекания</h4>
      <h5>Круг</h5>
      <p>Вырезание по кругу в CSS выглядит, например, так: clip-path: circle();, clip-path: circle(25%); или так: clip-path: circle(50% at 25% 25%);. Значения — это не обязательно, но они позволяют настраивать вид обрезных элементов точнее. Формула значения такая:</p>
      <pre>{'circle() = circle( [<радиус формы>]? [at <позиция>]? )'}
      </pre>
      <p>Радиус формы может быть задан как в пикселях так и в процентах. Позиция может быть также задана в процентах, пикселях или с помощью ключевых слов: center, top, right, bottom, и left (по поведению напоминает CSS-свойство background-position). Позиция используется для смещения центра объекта вырезания. Например clip-path: circle(100px at 20% 35%); получится, что круг с радиусом 100 пикселей будет расположен так, что его центр вырезания будет смещён и находится левее и выше центральной точки объекта. Для сравнения значение 50% 50% — это центральная точка объекта.</p>
      <img src="img/text/text-59.png" alt="" width="800" />
      <pre>{`{
  clip-path: circle(100px at 70% 25%);
  shape-outside: circle(100px at 70% 25%);
  float: right;
  margin-left: 20px;
}`}
      </pre>
      <p>ellipse работает так же, но имеет два значения радиуса.</p>
      <p>inset работает с прямоугольными формами и делает это немного неожиданно. Он показывает отступы, а не границы. Формулу clip-path: inset(10px 20px 30px 40px); нужно понимать так: 10 пикселей до границы объекта сверху; 20 пикселей до границы объекта справа, 30 пикселей снизу и 40 пикселей слева.</p>

      <h4>Неправильные формы</h4>
      <p>Иногда хочется обтечь какую-то форму со скруглениями. Кажется, что это многоугольник со скруглённым углом, и там должно быть что-нибудь про radius… но эта технология пока не работает достаточно, чтобы использовать её на «настоящих» сайтах.</p>
      <p>Придётся сделать многоугольник, полигон с большим количеством точек. Как это сделать? Найти онлайн-генератор CSS-полигонов и набросать полигон по форме своей картинки. Например, по запросу CSS Clip-Path Generator можно найти ресурс, который позволит загрузить собственные размеры объекта и расставить точки, ограничивающие вырезание. Можно также воспользоваться <a href="https://betravis.github.io/shape-tools/" target="_blank" rel="noopener noreferrer">коллекцией инструментов</a> для обтекания и <a href="https://betravis.github.io/shape-tools/polygon-drawing/" target="_blank" rel="noopener noreferrer">генератором кода для полигонов</a> от сотрудника Adobe Bear Travis. С помощью встроенных инструментов браузеров можно будет подправить форму, если она будет недостаточно точной. Или нарисовать на бумаге оси, поставить точки и посчитать их примерное расположение, а потом поправить в браузерных инструментах.</p>
      <p>Не нужно пугаться того, что в макете объект для обтекания имеет гладкий округлый бок, а полигон, даже если наставить много точек, таким гладким не будет. И ставить множество точек тоже нет необходимости. Для скругления угла может быть достаточно нескольких точек, а у изображений работают радиусы скругления.</p>

      <h3>Инструменты для работы с формами для обтекания</h3>
      <p>Инструмент Firefox, The Shape Path Editor, несколько проще и удобнее, так как встроен в базовые инструменты разработчика и не требует дополнительных настроек.</p>
      <p>Нужно «исследовать объект» с обтеканием, найти в инспекторе свойство, которое управляет обтеканием. Рядом с этим свойством будет значок формы. Нажать на него — и можно попробовать подправить многоугольник в онлайн-режиме.</p>
      <img src="img/text/text-60.png" alt="" width="800" />
      <p>При этом можно двойным кликом по пунктирной линии, соединяющей точки, создать новую точку для большей точности обтекания.</p>
      <p>Расширение _CSS Shapes Editor для Google Chrome предварительно придётся установить (для работы с расширением, возможно, понадобиться перезагрузить браузер).</p>
      <img src="img/text/text-61.png" alt="" width="800" />
      <p>Выделив нужный объект можно нажать плюс, чтобы добавить новое свойство, или курсор, чтобы отредактировать существующее свойство. Режимы редактирования формы — добавление/перемещение узлов формы и перетаскивание.</p>
      <p>Подробная статья про работу расширения _CSS Shapes Editor для Google Chrome от разработчика: <a href="http://razvancaliman.com/writing/css-shapes-editor-chrome/" target="_blank" rel="noopener noreferrer">CSS Shapes Editor for Chrome</a>.</p>

      <h4>Пошаговый разбор на примере обтекания текста внутри круга</h4>
      <p>Пошагово будем создавать обтекание текста изнутри круга. Это непросто, и большинство решений такого рода основаны на свойстве shape-inside или с SVG-формах, которые могут не поддерживаться в Google Chrome или вовсе не работать вне Safari. Мы сделаем это на чистом CSS, применив двойное обтекание многоугольников.</p>
      <img src="img/text/text-62.png" alt="" width="800" />
      <pre>{`<blockquote class="quote">
  <div class="quote-content">
    <p>Всё равно истины нет на свете или, быть может, она и была в каком-нибудь растении или
    героической твари, но шёл дорожный нищий и съел то растение или растоптал гнетущуюся низом
    тварь, а сам умер затем в осеннем овраге, и тело его выдул ветер в ничто.</p>
    <cite>Андрей Платонов. Котлован</cite>
  </div>
</blockquote>

.quote {
  width: 410px;
  height: 410px;

  border-radius: 50%;
  box-sizing: border-box;
  background-image: url("../img/blockquote-texture.png");
  background-repeat: no-repeat;
  background-size: cover;
  overflow: hidden; /* защита от переполнения, иначе структура сломается. Рекомендуем ограничить
  количество текста и посмотреть результат в разных браузерах и на разных устройствах */
}

.quote-content {
  position: relative;
  width: 100%;
  height: 100%;
  background-color: #272727;
  border-radius: 50%;
}`}
      </pre>
      <p>Теперь, когда мы определили размеры элемента, мы сможем выстраивать параметры дочерних элементов. Оба должны в потоке документа оказаться перед тем объектом, который должен их обтечь, тогда сработает свойство float. Один псевдоэлемент мы прикрепим к классу контента, другой — к классу обёртки.</p>
      <pre>{`.quote::before {
  content: ""; /* собственно, мы встраиваем не объект, а свойство обтекания, оно ниже */
  width: 50%;  /* мы будем оперировать половиной ширины всего объекта. Ширину задали выше */
  height: 100%;
  float: right;
  shape-outside: polygon(); /* заготовка для многоугольника, который мы будем обтекать */
}

.quote-content::before {
  content: "";
  width: 50%;
  height: 100%;
  float: left;
  shape-outside: polygon();
}`}
      </pre>
      <p>Заметьте, что мы делаем многоугольник, а не круг. Дело в том, что работающее свойство обтекания — shape-outside, обратите внимание на outside, оно означает, что контент обтечёт форму со внешнего бока. То есть использовать круг не выйдет. Прикинем сколько точек нам понадобится, чтобы нарисовать такую форму, которая будет как прямоугольник с одной вдавленной шариком стороной. Нарисуем эти точки на осях, пронумеруем. Сейчас всё довольно приблизительно, но мы же сможем потом выровнять объект в браузере.</p>
      <p>А теперь напишем примерные координаты этих точек через запятую, в процентах. Например, получилось так: (0 0, 100% 0, 60% 10%, 30% 30%, 0 50%, 10% 60%, 40% 80%, 100% 100%, 0 100%); Но обтекает оно не идеально. Что сделать, чтобы стало лучше? Например, подвинуть существующие точки и добавить ещё парочку: мы погорячились и точек маловато. В Firefox это можно сделать двойным кликом на пунктирную линию между точками. Вот что у нас получилось после подстройки в браузере:</p>
      <pre>{`.quote::before {
  content: "";
  width: 50%;
  height: 100%;
  float: right;
  shape-outside: polygon(2% 0%, 100% 0%, 100% 100%, 2% 100%, 78.21% 83.5%, 93.53% 72.45%, 97.59%
    62.27%, 96.92% 50%, 89.9% 32.6%, 73.52% 18.33%, 46.92% 7.28%);
  shape-margin: 10px;
}

.quote-content::before {
  content: "";
  width: 50%;
  height: 100%;
  float: left;
  shape-outside: polygon(0 0, 98% 0, 50% 6%, 24.94% 18.33%, 5.49% 32.6%, -1px 48.97%, 3.95% 65.
    6%, 9.55% 78.6%, 29.49% 85.54%, 98% 100%, 0 100%);
  shape-margin: 10px;
}`}
      </pre>
      <p>Всё вперемешку, проценты и пиксели, сотые доли, отрицательные значения… При этом сами браузерные инструменты работы с такими вырезаниями меняют 0 на 0px. Почистим, округлим, проверим на макете.</p>
      <pre>{`{
  ...
  float: right;
  shape-outside: polygon(2% 0, 100% 0, 100% 100%, 2% 100%, 78% 83%, 93% 73%, 98% 62%, 97% 50%,
    90% 33%, 74% 18%, 47% 7%);
}

{
  ...
  float: left;
  shape-outside: polygon(0 0, 98% 0, 50% 6%, 25% 18%, 5% 32%, 0 49%, 4% 66%, 10% 79%, 30% 85%,
    98% 100%, 0 100%);
}`}
      </pre>
      <p>В общем, в несколько итераций сверка-редактирование мы пришли к такому коду, который, конечно, несовершенен, но прост, прозрачен и выполняет свои функции:</p>
      <pre>{`{
  ...
  float: right;
  shape-outside: polygon(0 0, 100% 0, 100% 100%, 0 100%, 57% 92%, 89% 78%, 100% 52%, 90% 25%,
    56% 8%, 0 0);
    shape-margin: 10px;
}

{
  ...
  float: left;
  shape-outside: polygon(0 0, 100% 0, 50% 7%, 25% 18%, 5% 33%, 0 50%, 2% 65%, 12% 80%, 35% 90%,
    100% 100%, 0 100%);
    shape-margin: 10px;
}`}
      </pre>

      <h3>Прозрачные буквы</h3>
      <p>Для этого есть свойство со значением, которое работает, но его нет в спецификации и в CanIUse. Это background-clip: text. Кроме вариантов заполнения картинкой или фоном пространства внутри границ элемента и под ними, свойство имеет значение text, которое означает, что фон будет виден внутри букв. Код этого выглядит примерно так:</p>
      <img src="img/text/text-63.png" alt="" width="800" />
      <pre>{`.clip-text {
  color: transparent;
  background-image: url("../image.jpg");
  background-repeat: no-repeat;
  background-position: center;
  -webkit-background-clip: text;
  background-clip: text;
}`}
      </pre>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip" target="_blank" rel="noopener noreferrer">Про background-clip,подробно и с примерами</a></p>
      <p>Обратите внимание, что свойство используется с браузерным префиксом -webkit и без. Дело в том, что это свойство, создание которого инициировали разработчики движка, а не спецификации. Но сейчас практически все современные браузеры используют движок WebKit или основанный на нём Blink, Mozilla свойство «подхватила», так что работает оно хорошо. «Запасное» базовое свойство без браузерного префикса прописывается потому, что свойство уже плотно вошло в обиход и вероятно, в некоторых браузерах может быть зафиксировано без префикса.</p>
      <p>Дальше можно уже «играться» с наложением слоёв, использовать z-index. Например, так:</p>
      <img src="img/text/text-64.png" alt="" width="800" />
      <pre>{`<div class="wrapper">
  <p class="clip-text">Surfing</p>
</div>
.wrapper {
  max-width: 800px;
}

.clip-text {
  position: relative;
  display: inline-block;
  margin: 20px;
  padding: 60px;

  font-size: 200px;
  font-weight: 900;
  line-height: 150%;
  color: transparent;
  text-align: center;

  background-image: url("../img/background.jpg");
  background-repeat: no-repeat;
  background-size: 50% 50%;
  -webkit-background-clip: text;
  background-clip: text;
}

.clip-text:before,
.clip-text:after {
  content: "";
  position: absolute;
}

.clip-text:before {
  z-index: -2;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: inherit;
}

.clip-text:after {
  z-index: -1;
  top: 20px;
  right: 20px;
  bottom: 20px;
  left: 20px;
  background-color: #052c50;
}`}
      </pre>
    </section>
  );
}
export default LayoutText;
