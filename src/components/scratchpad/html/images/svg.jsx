import React from 'react';

function SVG() {

  return (
    <section className="conspect">
      <h1>SVG</h1>
      <p>SVG (Scalable Vector Graphics) — язык разметки векторной графики, созданный W3C, подмножество языка XML. Предназначен для описания векторной и смешанной (векторно-растровой) двухмерной графики, поддерживает анимацию и интерактивность. В 2001 году вышла версия 1.0, в 2011 — версия 1.1, актуальная ныне.</p>
      <p>SVG может растягиваться и сжиматься <span className="hl-3">без потери качества</span>, поэтому для экранов с повышенной плотностью пикселей достаточно одного изображения(в случае с растровой графикой на данный момент (весна 2015 г.) нужно, минимум, три (!) версии картинки: 100% макетного размера, 200% и 300%). SVG можно отредактировать без использования графического редактора, можно самому написать простую картинку. SVG-элементы можно оформить с помощью CSS и добавить им интерактивности с помощью JavaScript.</p>
      <p><span className="hl-10">SVG быстро загружается.</span>Да-да, ведь чем больше времени проходит от отправки запроса до показа страницы, тем ниже конверсия проекта. Во-первых, SVG-файлы, как правило, имеют меньший размер файла, чем их растровые версии (исключения составляют изображения малого пиксельного размера и сложные векторные изображения со множеством форм). Во-вторых, в один SVG-файл можно добавить несколько версий изображения и показывать их по определённым условиям (уменьшение количества запросов к серверу). В-третьих, в SVG можно использовать «клонирование» — единожды прописать форму (градиент, текстуру) и многократно использовать её, ссылаясь на оригинал. Есть, правда, и минус: отрисовка SVG в браузере чуть медленнее, чем показ растрового изображения, но чтобы заметить эту разницу, нужно сравнивать большие и сложные изображения.</p>
      <p><span className="hl-9">SVG легко сделать адаптивным.</span>В том случае, когда необходимо на узких вьюпортах показывать логотип сайта в <a href="https://tympanus.net/Tutorials/ResponsiveSVGs/index6.html" target="_blank" rel="noopener noreferrer">упрощённом варианте</a>, SVG позволяет добиться этого всего за один запрос к серверу.</p>
      <p><span className="hl-8">SVG может быть интерактивным.</span>Внутри изображения могут быть ссылки, скрипты, интерактивные части могут реагировать на наведение и другие действия пользователя, <a href="https://www.polygon.com/a/ps4-review" target="_blank" rel="noopener noreferrer">можно добавить анимацию</a>.</p>
      <p><span className="hl-7">Свободно распространяемое ПО.</span>Для работы с SVG не обязательно использовать Adobe Illustrator (как стандарт в мире векторной графики), достаточно свободно распространяемого Inkscape. Есть и ряд других инструментов.</p>
      <p><span className="hl-6"></span></p>
      <p><span className="hl-5"></span></p>
      <p><span className="hl-4"></span></p>
      <p>SVG-элемент вставляется с помощью тега svg, внутри которого уже находится остальное содержимое: фигуры, картинки или текст:</p>
      <pre>{`<svg>
<circle r="50" cx="50%" cy="50%" fill="yellowgreen"/>
</svg>`}
      </pre>

      <h2>как делать SVG</h2>
      <p>Лучше стараться обходиться как можно меньшим числом точек. Чем меньше точек, тем, как правило, проще редактировать файл и тем меньших он будет размеров. Если используются формы, нарисованные другими специалистами, имеет смысл их упростить — уменьшить количество как опорных, так и управляющих точек.</p>
      <p>Следует использовать пиксельную сетку и стараться располагать контуры так, чтобы их края были ровно на границе пикселей или на 1/2 пикселя. Если планируется изменения размеров элементов (например, иконки), то нужно проверить, как изменённый размер ляжет на пиксельную сетку. При этом важно помнить о том, что экран — это среда с серьёзными ограничениями, на любом размере попасть в пиксели невозможно, однако для наиболее частых размеров — нужно постараться.</p>
      <p>Стоит создавать и сохранять SVG в том виде, в котором планируется дальнейшее использование этих элементов в дизайне. Иногда встречается ситуация, при которой к PSD-макету приложены использованные SVG, но в самом макете использована векторная форма с какими-то добавлениями (текстовой слой, что-то дорисовано растром, наложен какой-либо эффект). Подобный подход может исключить возможность использовать векторную графику для такого элемента дизайна.</p>
      <p>Нужно использовать как можно меньше фигур, группировать только необходимое. Следует удалять фигуры, которые не являются составными частями картинки или невидимы (прикрыты другими фигурами).</p>
      <p>Все символы, текстуры и рисунки кистью лучше преобразовывать в обычные векторные участки, не применяя растровые эффекты (Adobe Illustrator) и режимы наложения.</p>

      <h2>Как вставить svg</h2>
      <p>Если смотреть на SVG как на отдельную страницу — становится понятнее, какой способ вставки вам нужен. Есть четыре основных и у каждого — особенности.</p>
      <ol>
        <li>
          <p>Элемент img прямо в HTML-коде. Это в принципе самый эффективный способ загрузить любую картинку — браузеры заранее знают по HTML-коду, что она есть и начинают её подгружать.</p>
          <p>Минус в том, что в таком SVG не будут работать скрипты и любые попытки взаимодействия с элементами внутри обречены. Файл будет как за стеклом: смотреть можно, а трогать нельзя. Хотя внутри всё остальное прекрасно работает, включая CSS-анимации.</p>
          <p>Такой способ лучше всего подходит контентным изображениям, которым не нужно взаимодействие: логотипы, графики, схемы.</p>
          <pre>{`<img
  src="picture.svg"
  alt="За стеклом">`}
          </pre>
        </li>
        <li>
          <p>Фоновая картинка в CSS. Причём неважно, зададите вы его элементу, псевдоэлементу или контентом вставите — результат будет таким же, как с img: за стеклом, но внутри что-то работает.</p>
          <p>Этот способ подходит для оформительской графики, которой не нужно взаимодействие: фоны, иконки и другая мелочь.</p>
          <pre>{`.picture {
  background-image:
    url(picture.svg);
}`}
          </pre>
          <a href="https://codepen.io/noahblon/post/coloring-svgs-in-css-background-images" target="_blank" rel="noopener noreferrer">Coloring SVGs in CSS Background Images</a>
        </li>
        <li>
          <p>Через object, наконец-то выбивает стекло между страницей и внутренностями SVG-файла. Работают скрипты, взаимодействие, анимация — если они описаны внутри SVG. Между тегами object можно вставить фолбэк, который покажется, если браузер не говорит на SVG.</p>
          <pre>{`<object
  type="image/svg+xml"
  data="picture.svg">
  <img
    src="picture.png">
</object>`}
          </pre>
          <p>Вместо object можно даже использовать iframe, как если бы вы подключили другую страницу. Но object работает лучше и подстраивается под размеры картинки.</p>
          <p>За гибкость приходится платить: из-за того, что это уже не просто графика и там можно скриптовать, к такому способу предъявляются другие требования безопасности. Например, картинку с другого домена просто так уже не вставить.</p>
          <p>Этот способ подходит, когда вам нужно вставить какую-то интерактивную графику: игрушки, графики и всякое сложное. Достаточно вспомнить, что когда-то через object вставлялись Flash-ролики.</p>
        </li>
        <li>
          <p>Четвёртый способ заработал, когда браузеры переписали свои HTML-парсеры по новому стандарту и содержимое SVG-файлов стало можно вставлять прямо на страницу, как любые другие теги.</p>
          <pre>{`<h1>Квадрат</h1>
<svg
  width="20"
  height="20">
    <rect fill="#fc0"
      width="20"
      height="20"/>
</svg>`}
          </pre>
          <p>С таким SVG можно делать то же, что и с обычными HTML-элементами: стили, скрипты. Можно, например, менять цвет заливки при наведении и описывать всё в общих стилях.</p>
          <pre>{`<style>
  rect:hover {
    fill: #090;
  }
</style>
<svg>
  <rect fill="#fc0"/>
</svg>`}
          </pre>
        </li>
      </ol>
      <p>Минус в том, что такие картинки не кэшируются отдельно от страницы — хотя это можно обойти через символы и юзы</p>

      <h2>Рисуем прямоугольник</h2>
      <pre>{'<rect width="50%" height="100" x="20" y="50" rx="50" ry="20" />'}</pre>
      <p>Координаты x и y определяют положение верхнего левого угла фигуры.</p>
      <p>Скруглением углов прямоугольника управляют параметры rx и ry. Атрибут rx задаёт скругление по горизонтали, а ry — по вертикали. Если атрибут ry не задан, он будет равен rx.</p>
      <p><span className="hl-6">Обратите внимание: все теги в SVG должны быть закрыты, то есть должно быть так: <code>&lt;rect .../&gt;</code> или так: <code>&lt;rect ...&gt;&lt;/rect&gt;</code>.</span></p>
      <p>Атрибуты width и height можно задавать и в пикселях, и в процентах.</p>
      <p>Для значений в пикселях после значения не нужно писать px, потому что пиксели — единица измерения, используемая в SVG по умолчанию. Проценты рассчитываются относительно размеров всего SVG-изображения: горизонтальные значения относительно ширины, вертикальные — относительно высоты.</p>
      <p>В современных браузерах размерами и положением фигур нельзя управлять через CSS, но эта возможность появится в будущем.</p>

      <h2>Многоугольники</h2>
      <pre>{'<polygon points="70,5 90,41 136,48 103,80 111,126 70,105 29,126 36,80 5,48 48,41"/>'}</pre>
      <p>В атрибуте points задаются координаты вершин фигуры. Каждая координата задаётся по x и y. Координаты в points нельзя задавать в процентах.</p>

      <h2>Рисуем окружность</h2>
      <pre>{'<circle r="50"  cx="100" cy="50%" />'}</pre>
      <p>Атрибут r — радиус окружности</p>
      <p>Координаты центра фигуры: атрибут cx задаёт положение по горизонтальной оси, cy — по вертикальной. По умолчанию координаты центра окружности равны 0,0, поэтому она находится в верхнем левом углу.</p>
      <p>Значения можно задавать как в пикселях, так и в процентах. Процентные значения рассчитываются относительно размеров SVG-элемента.</p>
      <p>Радиус и координаты можно задавать только атрибутами, с помощью CSS это сделать нельзя.</p>

      <h2>Рисуем эллипс</h2>
      <p>Эллипс имеет два радиуса: по горизонтальной оси — rx, и по вертикальной — ry.</p>
      <pre>{'<ellipse rx="30" ry="40%" cx="50%" cy="50%" />'}</pre>

      <h2>Рисуем линии</h2>
      <p>Линии рисуются с помощью тега line. Координаты начала линии задаются атрибутами x1 и y1, координаты конца — атрибутами x2 и y2. Координаты можно задавать в процентах.</p>
      <pre>{'<line x1="220" y1="20" x2="20" y2="90" stroke="violet" stroke-width="5" />'}</pre>
      <p>Атрибут stroke задаёт цвет обводки, stroke-width — толщину линии. Можно задать только цвет линии, тогда толщина обводки по умолчанию будет равна одному пикселю.</p>

      <h2>Рисуем ломаные линии</h2>
      <p>Ломаные линии рисуются с помощью тега polyline. Координаты точек на линии задаются в атрибуте points, как для polygon.</p>
      <pre>{'<polyline points="10,135 100,10 55,135 10,10 105,135"/>'}</pre>
      <p>Разница между polygon и polyline заключается в поведении обводки: у многоугольника обводка замыкается сама по себе, а у ломаной линии — остаётся незамкнутой.</p>
      <p>Можно управлять видом пунктирной обводки и сделать обводку точками, пунктиром или морзянкой, а ещё обводку можно сделать не только цветом, но также градиентом или картинкой.</p>

      <h2>Заливки</h2>
      <p>SVG-фигуры имеют богатые возможности оформления: им, как и HTML-элементам, можно задавать заливку цветом, градиентом или картинкой, но помимо этого также можно управлять отдельно прозрачностью заливки и обводки, а в качестве заливки можно использовать, например, текст.</p>
      <p>Если заливка не задана, по умолчанию фигура заполняется чёрным цветом. Цвет заливки задаётся атрибутом fill:</p>
      <pre>{`<circle r="60" cx="150" cy="50%" fill="gold"></circle>
либо аналогичным свойством в CSS:

circle {
  fill: gold;
}`}
      </pre>
      <p>Управлять прозрачностью заливки можно с помощью свойства fill-opacity. Значение задаётся числом от 0 до 1, например:</p>
      <pre>{`<rect width="150" height="100" fill="gold" fill-opacity="0.5"></rect>
rect {
  fill: gold;
  fill-opacity: 0.5;
}`}
      </pre>
      <p>Прозрачность работает для всех видов заливок, в том числе для градиентов и паттернов.</p>
      <p>Иногда бывает нужно полностью убрать заливку, например, если вам нужен только контур фигуры. Это можно сделать ключевым словом none, результатом будет полная прозрачность фигуры.</p>

      <h2>Обводки</h2>
      <p>Обводки задаются с помощью нескольких атрибутов, причём цвет и толщина обводки задаются отдельно. Цвет задаётся атрибутом stroke:</p>
      <pre>{`<circle r="60" cx="150" cy="50%" fill="none" stroke="orange"></circle>
либо через CSS:

circle {
  stroke: orange;
}`}
      </pre>
      <p>Для однопиксельной обводки достаточно задать только цвет в stroke. Если же нужно управлять толщиной обводки, это делается с помощью свойства stroke-width, также атрибутом или через CSS:</p>
      <pre>{`<circle r="60" cx="150" cy="50%" fill="none" stroke="orange"
stroke-width="5"></circle>

или:

circle {
  stroke: orange;
  stroke-width: 5;
}`}
      </pre>
      <p>Короткой записи нет. Если задавать значение в процентах, они будут рассчитываться не от размеров фигуры, а относительно размеров всего SVG, что может давать непредсказуемый результат.</p>
      <p>Если обводке задана толщина, но не задан цвет, обводка не отобразится.</p>
      <p>Прозрачность задаётся свойством stroke-opacity со значениями от 0 до 1, например: <code>stroke-opacity=&quot;0.5&quot;</code>.</p>
      <p>Либо через CSS:</p>
      <pre>{`<code>rect {
  stroke-opacity: 0.5;
}`}
      </pre>

      <h2>Концы линий</h2>
      <p>В SVG можно указывать, как ведёт себя обводка на концах линий, это делается с помощью атрибута stroke-linecap.</p>
      <ul>
        <li>butt — значение по умолчанию. С этим значением обводка просто заканчивается на концах линии.</li>
        <li>round, с этим значением обводка равномерно закругляется вокруг концов линии.</li>
        <li>square, с этим значением вокруг концов линии добавляется дополнительная обводка с прямоугольными краями.</li>
      </ul>
      <h3>Вид сгибов</h3>
      <p>Атрибут stroke-linejoin позволяет управлять видом обводки на сгибах линий.</p>
      <ul>
        <li>miter — значение по умолчанию. Обводка в месте сгиба линии никак не видоизменяется.</li>
        <li>round, обводка в месте сгиба линии равномерно закругляется.</li>
        <li>bevel, обводка в месте сгиба линии складывается как лента.</li>
      </ul>
      <p>В CSS внешним видом обводки на сгибах линий можно управлять с помощью аналогичного свойства stroke-linejoin.</p>
      <h3>Пунктирные линии</h3>
      <p>В SVG можно управлять видом пунктирных линий, это делается с помощью атрибута stroke-dasharray. В качестве значения задаётся длина отрезков и пробелов между ними. Можно задать одно число, в этом случае получится пунктирная линия, состоящая из отрезков и пробелов одинаковой длины:</p>
      <p>Если задать два числа stroke-dasharray=&quot;50 10&quot;, первое будет управлять длиной отрезков, второе — длиной пробелов.</p>
      <p>Последовательность можно продолжить stroke-dasharray=&quot;1 2 3 5 8 13 21&quot;, в этом случае получится пунктирная линия со сложным ритмом.</p>
      <p>Аналогично работает CSS-свойство stroke-dasharray.</p>
      <p>Видом обводки круглой фигуры тоже можно управлять. В отличие от прямоугольных форм сегменты пунктирной обводки круглой формы могут иметь неравномерную форму в зависимости от толщины обводки.</p>

      <h2>Сдвиг обводки</h2>
      <p>Пунктирной обводке с помощью атрибута stroke-dashoffset можно задать сдвиг.</p>
      <pre>{'stroke-dashoffset: stroke-dasharray="50" stroke-dashoffset="25"'}</pre>
      <p>Значение stroke-dashoffset может быть отрицательным, и тогда обводка будет смещаться по часовой стрелке.</p>
      <p>Аналогично работает CSS-свойство stroke-dashoffset.</p>

      <h2>Ширина и высота SVG</h2>
      <p>SVG ведёт себя иначе, чем привычные HTML-элементы: его содержимое отрисовывается на бесконечном холсте, и его размеры не зависят от содержимого. Видимая часть холста соответствует размерам SVG-элемента, эта область отрисовки называется вьюпорт.</p>
      <p>При этом можно управлять как размерами SVG-элемента, так и поведением его содержимого: оно может отображаться целиком, обрезаться или сжиматься не сохраняя пропорции.</p>
      <p>Если SVG просто вставить на страницу не указывая размеры, он отобразится размером 300×150 пикселей:</p>
      <pre>{`<svg>
  …
</svg>`}
      </pre>
      <p>Поменять ширину и высоту можно с помощью width и height:</p>
      <pre>{`<svg width="350" height="200">
  …
</svg>`}
      </pre>
      <p>Задавать размеры можно как атрибутами, так и в CSS:</p>
      <pre>{`<code>svg {
  width: 350px;
  height: 200px;
}`}
      </pre>

      <h2>Атрибут viewBox</h2>
      <p>Изменение размеров SVG-элемента не влияет на его содержимое — потому что содержимое отрисовывается на бесконечном холсте, и непонятно какого размера область нужно растягивать или сжимать. Это поведение можно изменить, задав размер области, которая будет тянуться, с помощью свойства viewBox (его можно задать только атрибутом):</p>
      <pre>{`<svg viewBox="0 0 237 300" width="350" height="200">
  …
</svg>`}
      </pre>
      <p>Первые два числа — координаты X и Y верхнего левого угла масштабируемой области, два других — её ширина и высота. Значения задаются в пикселях, единицы измерения указывать не нужно.</p>
      <p>С вьюбоксом содержимое масштабируется, чтобы поместиться целиком в контейнер, и выравнивается по центру.</p>
      <h3>viewBox и размеры</h3>
      <p>SVG без размеров, но с viewBox, пытается занять всё доступное пространство. Это означает, что если на странице есть инлайновые иконки, размеры которым задаются в CSS, без CSS могут растянуться на весь экран. Чтобы этого избежать, достаточно всем инлайновым иконкам в атрибутах явно задавать размеры по умолчанию, они потом легко переопределяются в CSS.</p>

      <h2>Атрибут preserveAspectRatio</h2>
      <p>По умолчанию содержимое SVG с viewBox масштабируется сохраняя пропорции, и если соотношения сторон вьюпорта и вьюбокса не совпадают, вокруг содержимого появляются поляю</p>
      <p>С помощью свойства preserveAspectRatio это поведение можно изменять: например, значение none указывает, что сохранять пропорции не нужно:</p>
      <pre>{`<svg viewBox="0 0 237 300" preserveAspectRatio="none">
  …
</svg>`}
      </pre>
      <p>В этом случае область, размеры которой заданы вьюбоксом, растягивается на всё доступное пространство вьюпорта.</p>
      <p>preserveAspectRatio задаётся только атрибутом.</p>
      <h3>Резиновый фон с preserveAspectRatio</h3>
      <p><span className="hl-5">SVG, заданный в качестве фона, ведёт себя так же, как инлайновый SVG, поэтому, чтобы получить резиновый фон, используйте SVG с viewBox, но без размеров: в этом случае изображение подгонится под размер элемента, которому задан фон, и будет тянуться вместе с ним, сохраняя пропорции:</span></p>
      <p>Это очень удобно для иконок: задайте размеры родительскому элементу, и иконка, заданная фоном, сама под него растянется.</p>
      <p>Если же нужно, чтобы пропорции не сохранялись, добавьте preserveAspectRatio=&quot;none&quot;. Это пригодится для резиновых фонов.</p>
      <h3>Выравнивание в preserveAspectRatio</h3>
      <p>Содержимое SVG можно не только растягивать, но и сдвигать вправо-влево или вверх-вниз. Для этого нужно указать положение содержимого относительно осей X и Y, например xMinYMid:</p>
      <pre>{`<svg viewBox="0 0 237 300" preserveAspectRatio="xMinYMid">
  …
</svg>`}
      </pre>
      <p>Возможные значения для каждой оси:</p>
      <ul>
        <li>xMin</li>
        <li>xMid</li>
        <li>xMax</li>
        <li>YMin</li>
        <li>YMid</li>
        <li>YMax</li>
      </ul>
      <p>Положение задаётся двумя параметрами: первым всегда указывается положение по X, вторым по Y. Положение по оси Y всегда пишется с большой буквы. Оба параметра обязательны.</p>
      <p>Значение по умолчанию — xMidYMid (содержимое выравнивается по середине большей стороны).</p>

      <h2>preserveAspectRatio и viewBox</h2>
      <p><span className="hl-7">Нужно помнить, что preserveAspectRatio не работает без viewBox. viewBox определяет масштабируемую область, preserveAspectRatio — как эта область выравнивается и как заполняет собой вьюпорт.</span></p>
      <p>Также preserveAspectRatio не работает, если содержимое отрисовывается без полей (то есть соотношения сторон вьюпорта и вьюбокса совпадают), тогда в нём просто нет необходимости.</p>

      <h2>Заполнение пространства</h2>
      <p>Второй параметр в свойстве preserveAspectRatio задаёт поведение содержимого относительно вьюпорта, определяет как именно содержимое заполняет пространство:</p>
      <pre>{`<svg viewBox="0 0 237 300" preserveAspectRatio="xMinYMin meet">
  …
</svg>`}
      </pre>
      <ul>
        <li>meet — содержимое умещается целиком, оставляя пустые поля (как при background-size: contain). Значение по умолчанию.</li>
        <li>slice — содержимое заполняет собой всё пространство, при этом часть содержимого может быть обрезана (похоже на background-size: cover). Пропорции сохраняются в обоих случаях.</li>
      </ul>

      <h2>Единицы измерения</h2>
      <p>В SVG можно использовать разные единицы измерения, например: px, em, ex, pt, pc, cm, mm, in и проценты.</p>
      <p>Также есть единицы системы координат — user space units, которые по умолчанию соответствуют пикселям, поэтому для размеров и координат в пикселях единицы измерения можно не указывать.</p>

      <h2>Системы координат</h2>
      <p>В SVG существует две системы координат:</p>
      <ul>
        <li>Система координат вьюпорта — viewport space.</li>
        <li>Система координат содержимого — user space.</li>
      </ul>
      <p>Изначально системы и их единицы измерения соответствуют друг другу.</p>
      <p>Сейчас видно только систему координат содержимого (она показана красным), потому что системы совпадают и одна скрыта под другой.</p>
      <p>Если добавить вьюбокс или трансформацию, содержимое и его система координат начинают смещаться и масштабироваться:</p>
      <pre>{`<svg width="350" height="200" viewBox="0 0 237 300">
  …
</svg>`}
      </pre>
      <p>Отсчёт координат содержимого начинается из левого верхнего угла (в точке 0,0). Без вьюбокса это левый верхний угол вьюпорта, с вьюбоксом — левый верхний край вьюбокса.</p>
      <p>То есть теперь расположение содержимого будет отсчитываться относительно новой системы координат, а не от вьюпорта, из-за чего фигура оказывается не слева, а ближе к центру, а системы координат больше не совпадают.</p>
      <h3>Системы координат и трансформации</h3>
      <p>Трансформации тоже создают свою систему координат. Чтобы применить трансформацию ко всему содержимому, обернём его в группу (элемент &lt;g&gt;) и добавим трансформацию:</p>
      <pre>{`<svg width="350" height="200">
  <g transform="translate(50, 50)">
    …
  </g>
</svg>`}
      </pre>
      <p>Всё содержимое сместилось на 50 пикселей по вертикали и по горизонтали вместе с системой координат, и если теперь добавить ещё одну трансформацию, она уже рассчитывается от новой системы координат:</p>
      <pre>{`<svg width="350" height="200">
<g transform="translate(50, 50) rotate(15)">
  …
</g>
</svg>`}
      </pre>
      <p>В SVG центр вращения по умолчанию находится в точке 0,0. До первой трансформации это был левый верхний угол вьюпорта, после трансформации — левый верхний угол трансформируемого содержимого. Вторая трансформация снова изменит систему координат группы.</p>

      <h2>Как вставлять на сайт</h2>
      <p>Хак для элемента с фоном:</p>
      <pre>{`DIV {
  background-image: url(your.png); /* PNG для IE6-8 */
  background-image: url(your.svg), none;
}`}
      </pre>
      <p>Вторая строка сработает в браузерах с поддержкой CSS3, старые её проигнорируют и покажут PNG из первой строки.</p>
      <h3>Способ с image</h3>
      <p>Современные браузеры выберут атрибут xlink:href и покажут SVG, старые выберут src и покажут растровую версию:</p>
      <pre>{`<svg width="200px" height="200px">
  <image xlink:href="your.svg"
    src="your.png"
    width="200px" height="200px"/>
</svg>`}
      </pre>
      <p>Элементы, содержащие SVG-графику, заворачиваются в div.svg (например). Затем определяем поддержку SVG с помощью Modernizr, браузеры без SVG определяем по классу .no-svg, дальше немного CSS:</p>
      <pre>{`/* Задаем обертке размеры и фон в PNG: */
.no-svg .svg {
  width: 200px;
  height: 200px;
  background: url(your.png); /* PNG-заглушка */
}

/* Скрываем содержимое обертки (иначе будут отображаться
иконки незагрузившихся картинок) */
.no-svg .svg IFRAME,
.no-svg .svg OBJECT,
.no-svg .svg EMBED,
.no-svg .svg IMG {
  display: none;
}`}
      </pre>
      <p>Стили сработают только в браузерах, не поддерживающих SVG.</p>
      <p>Хорошее решение для IE8 и старше, но может возникнуть проблема с Opera Mini. Она имеет частичную поддержку SVG, поэтому не будет селектора .no-svg, и при этом она не поддерживает SVG в CSS-фонах и Inline Svg, так что они не отобразятся.</p>
      <h3>:root</h3>
      <p>Селектор :root сработает только в браузерах с поддержкой CSS3, следовательно с его помощью также можно отфильтровать стили для старых и для новых браузеров.</p>
      <pre>{`/* По умолчанию показываем PNG: */
.svg {
  width: 200px;
  height: 200px;
  background: url(your.png);
}

/* Контейнеры с SVG скрыты. */
.svg IFRAME,
.svg OBJECT,
.svg EMBED,
.svg IMG {
  display: none;
}

/* Включаем содержимое для браузеров с поддержкой CSS3 */
:root IFRAME,
:root OBJECT,
:root EMBED,
:root IMG {
  display: inline-block;
}`}
      </pre>
      <p>Как и предыдущее решение, подойдет для IE8 и старше, но не поможет в Opera Mini, потому что она поддерживаeт CSS3, поэтому не будет заглушек для элементов с SVG-фоном и инлайновым SVG.</p>
      <h3>Решение для Opera на Presto (например, 12 и Mini)</h3>
      <p>В Opera 12 SVG-фоны могут вести себя странно, местами до сильного. Совершенно невинный CSS может привести к проблемам отрисовки векторых фонов при прокрутке страницы.</p>
      <p>На этот случай можно использовать хак, который сработает только в Опере:</p>
      <pre>{`doesnotexist:-o-prefocus, .selector {
  background-image: url(your.png);
}
</p>`}
      </pre>
    </section>
  );
}
export default SVG;
