import React from 'react';
import {Link} from 'react-scroll';

function SPAAndMVP() {

  return (
    <section className="conspect">
      <h1>Single-Page Application and Model-View-Presenter</h1>
      <div className="contents-container">
        <p className="contents-paragraph">Contents:</p>
        <ul className="contents-list">
          <li>
            <Link
              to="spa"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >SPA (Single-Page-Application)
            </Link>
          </li>
          <li>
            <Link
              to="mvp"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >MVP (Model-View-Presenter)
            </Link>
            <ul>
              <li>
                <Link
                  to="databinding"
                  className="contents-link"
                  smooth
                  offset={-20}
                  duration={500}
                >Датабиндинг
                </Link>
              </li>
              <li>
                <Link
                  to="object-assign"
                  className="contents-link"
                  smooth
                  offset={-20}
                  duration={500}
                >Object.assign
                </Link>
              </li>
              <li>
                <Link
                  to="immutability"
                  className="contents-link"
                  smooth
                  offset={-20}
                  duration={500}
                >Иммутабельность
                </Link>
              </li>
            </ul>
          </li>
          <li>
            <Link
              to="mock"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >Моки
            </Link>
          </li>
          <li>
            <Link
              to="circular-dependency-plugin"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >Circular Dependency Plugin
            </Link>
          </li>
          <li>
            <Link
              to="structural-design"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >Проектирование структуры
            </Link>
          </li>
          <li>
            <Link
              to="interaction-between-structures"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >Взаимодействие между структурами
            </Link>
          </li>
          <li>
            <Link
              to="adapter-pattern"
              className="contents-link"
              smooth
              offset={-20}
              duration={500}
            >Паттерн «Адаптер»
            </Link>
          </li>
        </ul>
      </div>
      <h2 id={'spa'}>SPA (Single-Page-Application)</h2>
      <p>Одностраничное приложение (SPA) — это веб-приложение, которое использует один HTML-документ. Страницы формируются динамически, прямо на клиенте.</p>
      <p>Абстрактное мышление - мышление при помощи обобщенных терминов</p>
      <p>SPA необходим для веб-приложений.</p>

      <h3>SPA — забота фронтендера</h3>
      <p>Бизнес-логика, взаимодействие внутри приложения, инфраструктура… об этом всём в SPA думает фронтендер</p>
      <img src="img/spa-1.png" width="600" height="400" alt="" />
      <img src="img/spa-2.png" width="600" height="400" alt="" />
      <img src="img/spa-3.png" width="600" height="400" alt="" />
      <img src="img/spa-4.png" width="600" height="400" alt="" />

      <h2 id={'mvp'}>MVP (Model-View-Presenter)</h2>
      <p>Модель. Представление. Презентер. Архитектурный паттерн проектирования. Хорошо подходит для проектирования UI</p>
      <p>Архитектура - совокупность важнейших решений об организации программы</p>
      <p>Model (Модель). Данные для отображения, бизнес-логика. Например, код для обработки данных или текст в карточках</p>
      <p>View (Представление). Непосредственное отображение данных (компоненты, шаблоны или модули блоков проекта - markup). Например, функции(getElement) для получения и обработки template или карточки для текста.</p>
      <p>Presenter (Презентер). «Дирижёр», посредник между View и Model. </p>
      <p>Зачем отделять данные от шаблона - данные абстрактны и подходят под разные способы отображения: информация не изменится, если её показывать по-разному. Например, чтобы отображать новости и в виде списка и в виде плитки - не надо верстать 2 отдельных шаблона, можно переключать шаблоны, а данные будут подстраиваться.</p>
      <p>Интерполяция - прокидывание переменных в шаблоны <code>(&dollar;&lcub;description.join(&apos; &apos;)&rcub;)</code></p>
      <ul>
        <li>view - это шаблоны и логика шаблона</li>
        <li>mock - функции по генерации данных в шаблонах</li>
        <li>main - логика отрисовки и сама отрисовка</li>
      </ul>

      <h3 id={'databinding'}>Датабиндинг. Манипуляции</h3>
      <p>Датабиндинг или связывание данных — это связь между пользовательским интерфейсом приложения и бизнес-логикой. Ценность датабиндинга не в том, чтобы на основе данных получить разметку. Датабиндинг прекрасен тем, что при правильной настройке связей мы можем изменить данные, а разметка изменится самостоятельно следом за ними.</p>
      <p>Рассмотрим классический пример. Пусть у нас на странице отображается список товаров. За этим отображением стоит модель — массив с объектами. Каждый объект содержит данные о товаре, а массив содержит данные обо всех товарах, показанных на экране.</p>
      <p>Мы можем захотеть изменить один из товаров в этом списке. Допустим, дать ему другое название</p>
      <p>При настроенном датабиндинге как только изменятся данные, перерисуется страница. И здесь интересный момент — как это работает? Зависит от конкретной реализации.</p>
      <p>Как обычно, есть два пути — перерисовывать всё или дорисовывать только новый элемент. Если идти сложным путём, вероятность ошибки особенно высока. При появлении нового элемента важно не забыть сделать с ним всё то, что происходило с другими элементами при инициализации списка — например, повесить на них обработчики. Если добавление производится в середину списка, а не в конец, появляется ещё несколько интересных сценариев для ошибки.</p>
      <p>Однако если мы оказываемся в ситуации, когда элементы в списке нужно переставлять часто и помногу, стоит задуматься над возможностью оптимизации. Допустим, если у нас список с несколькими возможными вариантами сортировки, то может быть разумно в данных нашей модели отдельно хранить объекты в изначальном порядке, а отдельно — критерий сортировки. Несмотря на видимое усложнение модели, это может упростить код отрисовки. Кроме того, появляется бонус: возможность сбросить сортировку и восстановить начальный порядок элементов.</p>
      <p>Датабиндинг — мощная абстракция, позволяющая разработчику сэкономить много интеллектуальных ресурсов. Однако это не волшебство, работающее само по себе, а сложный механизм, требующий правильной эксплуатации. Как добиться того, чтобы данные и их представление всегда оставались синхронизированными? Не может ли возникнуть ситуация, когда данные изменились, но механизм датабиндинга на это не отреагировал? Если такая ситуация возможна, как её избежать? На все эти вопросы разработчик должен отвечать самостоятельно.</p>

      <h3 id={'object-assign'}>Object.assign</h3>
      <p>Object.assign берёт один объект и копирует в него свойства другого объекта (или объектов). Рассмотрим на примере:</p>
      <pre>{`let x = {a: 1};
const y = x;

x = Object.assign({}, x); // Копируем все свойства объекта x в новый пустой объект,
иначе говоря — создаём копию
x.a = 2; // Изменяем значение свойства у копии, это не затрагивает оригинал

x; // {a: 2}
y; // {a: 1}`}
      </pre>
      <p>Впрочем, в этом примере всё равно присутствует изменение существующего объекта — «скопированного x». Более правильно будет сделать так:</p>
      <pre>{`let x = {a: 1};
const y = x;

x = Object.assign({}, x, {a: 2});

x; // {a: 2}
y; // {a: 1}`}
      </pre>
      <p>В данном случае мы передали в Object.assign три аргумента. Первый — пустой объект, потому что мы не хотим изменять ни один из существующих объектов. Второй — наш старый объект x, чтобы скопировать все его свойства в пустой объект и получить объект-копию. Третий — объект с изменениями. Свойства этого объекта запишутся «поверх» свойств объекта x. Таким образом, в итоге получится именно то, чего мы хотели: новый объект, отличающийся от старого только значением указанного свойства.</p>
      <p className="hl-9">Важно помнить, что Object.assign производит неглубокое копирование (shallow copy). Что это значит, проще опять же показать на примере.</p>
      <pre>{`let x = {a: {b: 1}};
const y = x;

x = Object.assign({}, x);
x.a.b = 2;

y; // {a: {b: 2}};`}
      </pre>
      <p>Как видите, если свойства копируемого объекта сами являются объектами, они копируются по ссылке, а не по значению. Если свойства этих вложенных объектов будут изменены в оригинале, это отразится в копии, и наоборот. Для таких случаев требуются более сложные конструкции, сейчас мы не будем их рассматривать.</p>

      <h3 id={'immutability'}>Иммутабельность</h3>
      <p>Иммутабельность — это, попросту говоря, неизменяемость. Когда какие-то данные нельзя изменить, можно только записать на их место другие.</p>
      <pre>{`let x = 3;
const y = x;

x = 5;

y; // 3`}
      </pre>
      <p>Число 3, записанное в переменную x и переданное потом в y, иммутабельно, как любое примитивное значение в JavaScript. Поэтому последующее изменение значения переменной x никак не повлияет на значение переменной y.</p>
      <pre>{`const x = {a: 1};
const y = x;

x.a = 2;

y; // {a: 2}`}
      </pre>
      <p>Мы изменили значение в переменной y, не перезаписывая её, и даже вообще к ней не обращаясь. Так получилось, потому что значение обеих переменных — один и тот же объект (присвоение y = x произойдёт по ссылке), а объекты в JavaScript мутабельны. Поэтому при работе с объектами, чтобы избежать побочных эффектов вроде случайного изменения по ссылке, важно сделать так, чтобы объекты вели себя, как иммутабельные.</p>

      <h4>Преимущества иммутабельности</h4>
      <p>Датабиндинг — отличный пример, чтобы показать важность иммутабельности. Мы хотим, чтобы данные внутри модели менялись «правильно» — с помощью специальных методов, которые не только изменят данные, но и вызовут перерисовку. Однако если данные мутабельны, то стоит передать куда угодно ссылку на них, как возникнет риск «неправильного» изменения. Как в примере выше мы смогли изменить значение переменной y через переменную x, так и в нашем проекте с датабиндингом кто-то сможет изменить данные модели, не используя методы, предоставляемые моделью. В самом лучшем случае это приведёт к пропуску перерисовки.</p>
      <p>Иначе говоря, иммутабельность — это механизм контроля над тем, какие части кода могут произвести изменение значения.</p>
      <p>Один из частых случаев, когда может потребоваться иммутабельность — это реализация возможности отката к предыдущему состоянию. Допустим, мы разрабатываем какой-нибудь редактор и хотим, чтобы там работали клавиши Ctrl + Z (Command + Z на macOS). Сочетая датабиндинг с иммутабельностью, можно решить эту проблему довольно изящно: при каждом изменении сохранять предыдущее состояние модели в специальный массив, а при откате брать из массива последнее состояние и возвращать к нему модель.</p>
      <p>Без иммутабельности это работать не будет. Если существует возможность изменить объект состояния, лежащий в «массиве истории», то есть вероятность, что вместо отката назад мы получим откат неизвестно куда.</p>

      <h4>Реализация</h4>
      <p>Во многих языках программирования существуют хорошие встроенные механизмы, позволяющие достичь иммутабельности (а в некоторых языках иммутабельны вообще все значения). JavaScript не относится к числу таких языков. В нём есть const, запрещающее изменять значение переменной, но не значения её вложенных свойств. Ещё есть метод Object.freeze, который делает вроде бы то, что нужно, но с одним большим «но» — этот метод запрещает изменение значений свойств объекта, но не свойств его свойств. Иными словами, это «неглубокая» заморозка:</p>
      <pre>{`const object = {
  topProperty: 'Значение объекта',
  childObject: {
    deepProperty: 'Значение дочернего объекта',
  },
};

const freezedObject = Object.freeze(object);

freezedObject.topProperty = 'Другое значение объекта'; // Так нельзя, будет ошибка
freezedObject.childObject.deepProperty = 'Другое значение дочернего объекта';
// А вот так всё равно можно`}
      </pre>
      <p>Существуют несколько способов достичь более надёжной иммутабельности. Например, библиотеки вроде <a href="https://immutable-js.com/" target="_blank" rel="noopener noreferrer">ImmutableJS</a>. Однако можно пойти и другим путём. Вместо того, чтобы гарантировать иммутабельность программными средствами, можно использовать соответствующую конвенцию. Иными словами, собраться с коллегами и договориться: а давайте не будем изменять существующие объекты. Этот подход чреват возможными ошибками, однако достаточно прост в реализации.</p>
      <p>И вот в наше приложение заходит пользователь и что-то редактирует. Возникает дилемма. С одной стороны, мы не хотим изменять объект, с другой стороны, нам нужно изменить состояние.</p>
      <p>Решение: вместо того, чтобы изменять старый объект, мы создаём новый, почти такой же, как старый, но с некоторыми отличиями. Новый объект и будет изменённым состоянием. Старый мы можем сохранить в истории для возможности отката.</p>
      <p>Очень полезным инструментом для таких действий является метод Object.assign, о котором мы говорили ранее, и spread-синтаксис.</p>

      <h3>2 основных стратегии достижения иммутабельности</h3>
      <h4>Copy On Write</h4>
      <p>Copy On Write, копировании при записи. То есть, каждый раз, когда мы хотим изменить какую-либо часть состояния, мы создаём полностью независимую копию состояния, в которую вносим необходимое изменение.</p>
      <p>Плюс этого подхода — простота и надёжность. Физически не существует никакого способа изменить оригинал, производя манипуляции над копией.</p>
      <p>Есть и минус: производительность. Создание копии может занимать значительное время, а её хранение — значительное количество памяти.</p>

      <h4>Resource Sharing</h4>
      <p>Чтобы избавиться от минусов предыдущего подхода, можно сделать следующее: если какие-то части состояния остаются неизменными, будем копировать их по ссылке. Независимые копии будем создавать лишь для частей состояния, которые фактически были изменены. Такой подход называется Resource Sharing, совместное использование ресурсов.</p>
      <p>Resource Sharing производительнее, чем Copy On Write, однако страдает надёжность: теоретически есть возможность изменить то, что не должно быть изменено.</p>
      <h5>Пример Copy On Write и Resource Sharing</h5>
      <p>Пусть у нас есть список товаров, который определяется следующим состоянием:</p>
      <pre>{`const state = [
  {
    name: 'Товар 1',
    price: '100',
  },
  {
    name: 'Товар 2',
    price: '200',
  },
  {
    name: 'Товар 3',
    price: '300',
  },
];`}
      </pre>
      <p>Представим, что мы захотели изменить название второго товара на «Резиновая уточка». В случае Copy On Write мы:</p>
      <ol>
        <li>Создадим новый массив;</li>
        <li>Создадим копии всех трёх объектов;</li>
        <li>Изменим копию второго объекта;</li>
        <li>Положим копии объектов в новый массив.</li>
      </ol>
      <p>В случае Resource Sharing мы:</p>
      <ol>
        <li>Создадим новый массив;</li>
        <li>Создадим копию второго объекта;</li>
        <li>Модифицируем копию второго объекта;</li>
        <li>Положим в новый массив неизменный первый объект, изменённую копию второго объекта и неизменный третий объект.</li>
      </ol>
      <p>Copy On Write хорошо использовать там, где не ожидается проблем с производительностью. Если состояние небольшое, изменяется нечасто, не требуется функционал отката — это хороший повод использовать Copy On Write.</p>
      <p>Если Copy On Write не справляется, на помощь приходит Resource Sharing. Пожертвовав частью надёжности, можно избежать проблем с производительностью.</p>
      <p>Также можно использовать гибридные подходы. Например, если состояние делится на несколько крупных частей, можно использовать Copy On Write в пределах каждой части и Resource Sharing для состояния в целом.</p>

      <h3 id={'mock'}>Моки</h3>
      <p>Моки необходимы на этапе разработке и тестирования приложения - это просто данные. Моки это не Model. <span className="hl-5">Основная задача моков: подготовить View к работе с данными</span></p>

      <h2 id={'circular-dependency-plugin'}>Circular Dependency Plugin</h2>
      <p>Плагин для webpack, позволяющий обнаружить циклические зависимости.</p>
      <img src="img/mvp.png" width="600" height="400" alt="" />
      <img src="img/mvp-2.png" width="600" height="400" alt="" />

      <h2 id={'structural-design'}>Проектирование структуры, 2 принципа от общего к частному или от частного к общему</h2>
      <p>выделить отдельные сущности</p>
      <p>выявить свойства и методы сущностей и подобрать оптимальную структурудля каждой из них</p>
      <p>определиться, как сущности связаны между собой</p>
      <img src="img/str-1.png" width="600" height="400" alt="" />

      <p className="hl-10">Разработка по шаблонам:</p>
      <ul>
        <li>Разбиваем на компоненты: меню, фильтры, список объектов, форма редактирования, форма создания и т.д.</li>
        <li>Компоненты превращаем в шаблоны</li>
        <li>Изымем из шаблонов данные</li>
        <li>Эти данные переварим в моки</li>
        <li>Настроим в приложении связь, чтобы на основе данных рисовались шаблоны и в итоге компоненты ожили</li>
      </ul>

      <h2 id={'interaction-between-structures'}>Взаимодействие между структурами</h2>
      <p>Структур может быть несколько</p>
      <p>Некоторые из них могут быть связаны, например по ключу</p>
      <img src="img/str-2.png" width={600} height={270} alt="" />
      <img src="img/str-3.png" width={600} height={400} alt="" />
      <img src="img/str-4.png" width={800} height={400} alt="" />

      <h3 id={'adapter-pattern'}>Паттерн «Адаптер»</h3>
      <p>Адаптер — структурный паттерн проектирования. Позволяет объектам с несовместимыми интерфейсами работать вместе.</p>
    </section>
  );
}
export default SPAAndMVP;
