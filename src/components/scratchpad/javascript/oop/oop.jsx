import React from 'react';

function AboutProgramming() {

  return (
    <section className="conspect">
      <h1>Про программирование.</h1>
      <p className="hl-3">Если &quot;логике отношений&quot; место в данных, то &quot;логике отображение&quot; - самое место в шаблоне.</p>
      <h2>ООП-модель на основе прототипов</h2>
      <p>По концепции, в ООП на основе классов мы сначала создаем класс, который будет служить «схемой» для объектов, а затем создаем объекты на основе этой схемы. Чтобы построить более конкретные типы объектов, мы создаем «дочерние» классы; то есть мы вносим некоторые изменения в схему и используем получившуюся новую схему для создания более конкретных объектов.</p>
      <p>Для аналогии с реальным миром: если бы вы построили стул, вы сначала создали бы чертеж на бумаге, а затем изготовили бы стулья на основе этого чертежа. План здесь - это класс, а стулья - объекты. Если вы хотите построить кресло-качалку, вы должны взять чертеж, внести некоторые изменения и изготовить кресла-качалки, используя новый чертеж.</p>
      <p className="hl-8"><b><abbr data-title="способ мышления">Парадигма</abbr> программирования</b> — это совокупность идей и понятий, определяющих стиль написания компьютерных программ. Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.</p>

      <h2>ООП - объектно-ориентированная парадигма.</h2>
      <h3>Объект</h3>
      <p>Всё состоит из объектов. Подходы к организации кода.</p>
      <ul>
        <li>Объект — модель реального мира;</li>
        <li>Объект самодостаточен. Выполняет конкретную задачу;</li>
        <li>Объекты взаимодействуют с другими объектами.</li>
      </ul>
      <p>Плюсы ООП</p>
      <ul>
        <li><abbr data-title="с одной стороны">«Упрощается»</abbr> проектирование. Всё состоит из объектов;</li>
        <li>Распараллеливание процесса разработки;</li>
        <li>Создание сложных объектов из более простых;</li>
        <li>Удобней создавать расширяемые приложения;</li>
        <li>Переиспользование кода.</li>
      </ul>
      <p>Минусы ООП</p>
      <ul>
        <li><abbr data-title="с другой стороны">«Усложняется»</abbr>«Усложняется» проектирование;</li>
        <li>Проектировать сложней, чем использовать;</li>
        <li>Трудно выстраивать связи между классами (большие проекты);</li>
        <li>Легко потеряться в абстракциях и проектировании универсальных решений.</li>
      </ul>

      <h4>Объекты и компонентный подход</h4>
      <p>ООП оперирует понятиями: абстракция, наследование, совокупность, взаимодействие.</p>
      <p>В ООП компоненты — это классы, но классы это конечная точка нашего маршрута.</p>
      <p><b>Компонент</b> — это независимый модуль исходного кода программы, предназначенный для повторного использования. Компонентный подход, в свою очередь, это разделение кода на повторно используемые модули.</p>
      <p className="hl-5">Наши функции, которые мы уже называем компонентами, на самом деле возвращают лишь разметку в виде строки. Если в этой разметке потребуется какой-либо интерактив, функция с этим не справится. Давайте представим, что у нас вместо функций — объекты. Разметка сможет храниться в свойствах этого объекта. За изменение свойств объекта будут отвечать методы. А значит мы можем изменять нашу разметку снаружи, не создавая каждый раз новый компонент, как это было с функциями.</p>
      <p>объекты в чистом виде для компонентов тоже неудобны по ряду причин:</p>
      <ul>
        <li>нет удобного способа размножить объекты;</li>
        <li>непонятно, как выстроить между ними взаимодействие;</li>
        <li>непонятно, как их наследовать;</li>
        <li>ну или, хотя бы, как отличить один объект от другого.</li>
      </ul>

      <h4>Утиная типизация</h4>
      <p>Подход «Утиная типизация» позволяет нам определить (узнать) предмет (далее «сущность») по поведению:</p>
      <cite>Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка.</cite>
      <p>Иными словами, если у объекта есть определённый набор ключей, то этот объект относится к одному типу. Если у объекта другой определённый набор ключей, то этот объект относится к другому типу.</p>
      <p>Возьмём уже знакомый нам объект, который описывает повара. Как бы мы могли с помощью утиной типизации определить, что это повар? Например, если у объекта есть поля: имя, фамилия, инструмент и метод cut (поведение), то это повар. А если у него точно такой же набор полей, но метод code — это программист.</p>
      <pre>{`// повар
const cook = {
  firstName: 'Bob',
  lastName: 'Smith',
  tool: 'knife',
  cut: () => {},
};

// разработчик
const developer = {
  firstName: 'Dan',
  lastName: 'Abramov',
  tool: 'React',
  code: () => {},
};`}
      </pre>
      <p>Представьте, что нам потребовалось описать хирурга. Хирург тоже умеет резать, но далеко не продукты. У хирурга тоже может быть метод cut. Как же тогда понять, где повар, а где хирург?</p>
      <p>Можно добавить уникальный ключ каждому объекту, который будет содержать некий признак, по которому уже мы сможем определить, чем является этот объект. Но здесь мы сталкиваемся с другими проблемами. Например, этот словарь признаков нужно будет хранить и составлять. Согласитесь, это лишняя работа.</p>
      <p>К счастью, способ решения есть — это вышеупомянутые классы!</p>
      <p>P.S. Есть ещё один способ — функции-конструкторы. Это способ, которым пользовались фронтенд-разработчики до появления классов.</p>

      <h4>Функции-конструкторы</h4>
      <p>Об этом способе полезно знать, поскольку под капотом браузера классы устроены похожим образом, а легаси-код никто не отменял.</p>
      <p>Функция-конструктор — это обычная функция, особенной её делают договорённости:</p>
      <ul>
        <li>Функция-конструктор именуется с большой буквы. А также именем существительным, а не глаголом;</li>
        <li>Функция-конструктор вызывается только с оператором <span className="hl-1">new</span>.</li>
      </ul>
      <p>синтаксис у такой функции простой:</p>
      <pre>{`// Все свойства будущего объекта записываем через ключевое слово this
const GuitarPlayer = function (firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
};

// Все методы мы записываем через свойство prototype функции-конструктора
GuitarPlayer.prototype.play = function () {
  console.log('Rock!');
};

// Далее вызываем с оператором new
const richieSambora = new GuitarPlayer('Richie', 'Sambora');

// И результатом получаем объект с указанными свойствами и методами:
console.log(richieSambora);
/*
    {
        firstName: 'Richie',
        lastName: 'Sambora',
        __proto__: {
            play: function () {
                console.log('Rock!');
            },
        }
    }
*/`}
      </pre>
      <p className="hl-10">Такой объект называют экземпляром или инстансом (от англ. instance).</p>
      <p className="hl-9">Если вдруг забыли, this — это контекст функции. Всё, что мы запишем в this, попадёт в свойства нашей функции, а после её вызова с оператором new превратится в свойства полученного объекта.</p>
      <p>А раз мы строим что-то по форме, всегда можно проверить, по какой именно форме был получен экземпляр. Для этого в языке есть специальный оператор instanceof:</p>
      <pre>{`richieSambora instanceof GuitarPlayer; // true

const fakeRichieSambora = {
  firstName: 'Richie',
  lastName: 'Sambora',
  play: function () {
    console.log('Rock!');
  },
};

fakeRichieSambora instanceof GuitarPlayer; // false`}
      </pre>
      <p>Иными словами, мы построили конвейер для штамповки объектов одной структуры, то есть для штамповки компонентов, что в терминах ООП является «классом». Теперь у нас появился удобный синтаксис — class.</p>

      <h3>Классы</h3>
      <p><b>Класс</b>— это чертёж, по которому мы можем создавать объекты.</p>
      <p className="hl-9">Класс — это фрагмент кода с именем</p>
      <p>Это хорошо видно из его синтаксиса: фрагмент кода определяется блоком фигурных скобок {}, а класс — это блок фигурных скобок с именем и специальным выражением class.</p>
      <p>Класс может содержать методы (указаны в теле) и свойства (записываются через this в методах). Ничего более в классе быть не может, потому что классы нужны для создания объектов, а у объектов есть только свойства и методы.</p>
      <pre>{`class GuitarPlayer {
  constructor(firstName, lastName) {
    this.firstName = firstName; // Свойство firstName
    this.lastName = lastName; // Свойство lastName
  }

  // Метод play
  play() {
    console.log('Rock!');
  }
}`}
      </pre>
      <p>Названия свойствам и методам разработчик придумывает самостоятельно. Всем, кроме служебного метода constructor. <span className="hl-5">JavaScript выполнит этот метод при создании экземпляра класса</span> c помощью new:</p>
      <pre>{`new GuitarPlayer('Richie', 'Sambora'); // Вызовет constructor и передаст ему 'Richie' как
firstName и 'Sambora' как lastName`}
      </pre>
      <p>Конструктор в классе может быть только один, а может отсутствовать вовсе</p>

      <h5>Статические методы класса</h5>
      <p>со словом static перед:</p>
      <pre>{`class GuitarPlayer {
  play() {
    console.log('Rock!');
  }

  // Статический метод
  static getMusicalInstrument () {
    console.log('Guitar');
  }
}

const player = new GuitarPlayer();

player.play(); // 'Rock!'

GuitarPlayer.getMusicalInstrument(); // 'Guitar'
// Обратите внимание, что статические методы
// нужно вызывать у класса, а не экземпляра,
// об этой особенности ниже`}
      </pre>
      <p>Статические методы в первую очередь используются для описания вспомогательных функций. Например Math.min(), Object.entries(), Array.from(), Number.isNaN() — это всё статические методы встроенных объектов. Подобную функциональность можно реализовать в своих классах. Однако, у статических методов есть особенности.</p>
      <p>Первая особенность, что в static-методах нельзя использовать this. То есть static-методы можно представить как методы, которые никак не взаимодействуют с другими свойствами и методами класса. Поэтому static-методы в первую очередь используются для описания вспомогательных функций.</p>
      <p>Вторая, не менее важная, особенность, что static-методы принадлежат тому классу, в котором объявлены, и не передаются экземплярам, а значит вызвать static-методы у экземпляров нельзя:</p>
      <pre>{`class A {
  static print () {
    console.log('Я статичный метод');
  }
}

A.print(); // Выведет в консоль: 'Я статичный метод'

const a = new A();

a.print(); // Получим ошибку "TypeError: print is not a function", потому что у экземпляра нет метода print`}
      </pre>
      <p>Что нужно запомнить про статические свойства? Если если вы сомневаетесь, нужен вам static-метод или обычный метод, используйте обычный.</p>

      <h5>Новый синтаксис записи свойств класса</h5>
      <p>В предложениях к стандарту ECMAScript описан новый синтаксис записи свойств класса:</p>
      <pre>{`class GuitarPlayer {
  personalPhrase = 'Rock!'; // Объявляем почти как переменную

  play() {
    console.log(this.personalPhrase); // Обращаемся по-прежнему через this
  }
}

Кстати, никто не запрещает записать в свойство функцию:

class GuitarPlayer {
  personalPhrase = 'Rock!';

  play = function () {
    console.log(this.personalPhrase);
  }
}`}
      </pre>
      <p>И хотя этот способ ещё не часть стандарта, он уже поддерживается большинством браузеров, а благодаря инструментам вроде Babel разработчики могут его использовать без оглядки на браузеры, которые этот способ не поддерживают.</p>
      <p>Но смысла в этом нет, ведь у класса есть методы, а вот если вместо обычной функции использовать стрелочную, смысл появляется:</p>
      <pre>{`class GuitarPlayer {
  personalPhrase = 'Rock!';

  play = () => {
    console.log(this.personalPhrase); // Так this всегда будет GuitarPlayer
  }
}`}
      </pre>
      <p>Ведь стрелочная функция запоминает контекст this места, где была объявлена. Получается, такая запись навсегда привязывает стрелочную функцию к контексту this класса, в котором она была записана в свойство.</p>

      <h5>Публичные, приватные и защищённые поля класса</h5>
      <p>Все методы и свойства, о которых говорилось до этого, — публичные. Они называются так потому, что к ним можно обратиться «снаружи», то есть извне класса.</p>
      <p>Если же метод или свойство использовать вне класса не планируется, его делают приватным. Названия приватных полей начинаются с решётки #. Если обратиться к такому полю снаружи, получим ошибку. Кроме того, приватные свойства обязательно должны быть объявлены до первого использования:</p>
      <pre>{`class GuitarPlayer {
  // Объявляем приватные свойства
  #firstName;
  #lastName;

  constructor(firstName, lastName) {
    // Записываем в приватные свойства полученные значения
    this.#firstName = firstName;
    this.#lastName = lastName;
  }

  // Объявляем приватный метод
  #createPhrase = () => {
    return 'My name is &dollar;{this.#firstName} &dollar;{this.#lastName}';
  }

  whoAm() {
    console.log(this.#createPhrase());
  }
}

const player = new GuitarPlayer('Richie', 'Sambora');

player.whoAm(); // Выведет в консоль 'My name is Richie Sambora'

console.log(player.#createPhrase()); // Ошибка!`}
      </pre>
      <p>Приватные свойства и методы могут использоваться только внутри самого класса. Если в родительском классе объявлен приватный метод или свойство, обратиться к нему из дочернего класса не получится. Если поле класса не используется снаружи, но при этом должно быть доступно в дочерних классах, его пемечают как защищённое. Названия защищённых полей начинаются с нижнего подчёркивания _.</p>
      <p>В отличие от приватных, защищённые поля — это просто договорённость между разработчиками. JavaScript никак не ограничивает к ним доступ, и с точки зрения самого языка защищённые поля ничем не отличаются от публичных:</p>
      <pre>{`class Man {
  constructor(firstName, lastName) {
    // Защищённые поля, как и публичные, можно заранее не объявлять
    this._firstName = firstName;
    this._lastName = lastName;
  }
}

class GuitarPlayer extends Man {
  whoAm() {
    console.log('My name is $dollar;{this._firstName}
    $dollar;{this._lastName}'); // Защищённые поля доступны из дочернего класса
  }
}`}
      </pre>
      <p>Приватные поля с решёткой появились в JavaScript относительно недавно. До этого все поля, которые не должны были использоваться снаружи, записывали с помощью нижнего подчёркивания и не разделяли их на приватные и защищённые. Вы можете встретить это в старых проектах.</p>
      <p className="hl-7">Класс — это не функция, не объект и не переменная. Это отдельная синтаксическая конструкция. По поведению эта конструкция ближе всего к объявлению функции. Разве что к классу, в отличие от такого объявления функции, нельзя обратиться до объявления.</p>
      <p>Таким образом, классы позволяют нам:</p>
      <ul>
        <li>определять, как одни сущности взаимодействует с другими сущностями. Например, в чертеже описаны входы-выходы, куда подключается усилитель (другая сущность), и так далее;</li>
        <li>описывать, как другие сущности взаимодействуют с нашей сущностью. Например, гитаристу нужно играть на ней левой рукой, а не правой;</li>
        <li>указать, как создавать новые экземпляры, то есть новые сущности. Например, семиструнные гитары.</li>
      </ul>
      <p>Вопросы для самопроверки</p>
      <ul>
        <li>– Что такое ООП?</li>
        <li>– Что такое класс?</li>
        <li>– Можно совмещать ООП и функции в JavaScript?</li>
        <li>– Как в JavaScript создать класс?</li>
        <li>– Что такое конструктор?</li>
        <li>– Что такое метод класса?</li>
        <li>– Сколько классов должно экспортироваться из одного модуля?</li>
      </ul>

      <h3>Программный интерфейс</h3>
      <p><b>Интерфейс</b> — это описание того, как должен выглядеть объект без его реализации. Допустим, у меня есть массив. Что такое массив? Это объект, у которого есть свойство length, являющееся числом.</p>
      <p>Кроме свойства length, у этого массива есть метод map. map — это функция, которая принимает на вход функцию, которая принимает на вход элемент массива — любое значение. Вторым аргументом она принимает на вход индекс — число. Третий аргумент — весь массив. И возвращает эта функция новый элемент массива — любое значение. Сейчас мы говорим не о реализации, а лишь о типах данных, поступающих на вход и возвращаемых функцией.</p>
      <p>Ещё есть метод filter. Он принимает на вход функцию, которая принимает на вход элемент массива — любое значение, число и массив, а возвращает булево значение.</p>
      <p>И отличаются map и filter между собой тем, что первая функция возвращает новый элемент массива — любое значение, а вторая функция булево значение. Опишем структуру объекта типа Array с помощью псевдокода:</p>
      <pre>{`Array = {
   length: number,
   map: function(function(*, number, Array): *): Array,
   filter: function(function(*, number, Array): boolean): Array,
};`}
      </pre>
      <p>Мы описали неполную (ограничились length, map и filter) структуру массива, у которой length — это число, map и filter — это функции, которые принимают на вход другую функцию и возвращают массив. Подобное описание объектов (не с точки зрения синтаксиса, а с точки зрения смысла) является интерфейсом. То есть интерфейс — это описание структуры объекта, его свойств и методов, типов этих свойств, а также аргументов методов и их возвращаемых значений. Интерфейс не описывает реализацию, а только типы данных.</p>

      <h4>Примеры интерфейсов</h4>
      <p>Вот, например, интерфейс функции Math.abs выглядит так: Math.abs — это функция, которая принимает на вход число и возвращает ещё одно число. Array.map — это функция, которая принимает на вход функцию и возвращает массив.</p>
      <pre>{`Math.abs: function(number): number;
Math.random: function(): number,
Array.map: function(function(*, number, Array): *): Array;`}
      </pre>

      <h4>Почему интерфейс важен</h4>
      <p>Интерфейс — это способ описания ваших объектов, любых сущностей, без описания их реализации. Он содержит в себе минимальную информацию о структуре и типах данных. А эта информация помогает нам писать код, потому что мы знаем, что от нас ждут другие участки кода, функции, модули.</p>

      <h3>Объектно-ориентированное программирование</h3>
      <p>ООП достаточно сложная парадигма и даже на этапе определения появляются разночтения. Изначально ООП придумали для языка Smalltalk. Этот язык в свою очередь очень сильно повлиял на язык Objective C. В каноническом виде ООП — это описание всех сущностей в коде в виде объектов, которые обмениваются между собой сообщениями. Чтобы все это работало — объекты и сообщения между ними — у каждого объекта должен быть известный интерфейс. То есть, чтобы пользоваться конкретным объектом правильно, необходимо понимать, как он устроен, какие у него есть свойства и методы.</p>
      <p>Зачем нам нужно ООП? Зачем нам нужны чёткие и понятные интерфейсы объектов? Потому что с помощью ООП мы создаём абстракции. А что такое абстракция? Абстракция — это когда мы абстрагируемся от конкретных деталей реализации и переходим на уровень выше для того, чтобы понять, как взаимодействуют сущности на высоком уровне.</p>
      <p>ООП позволяет с помощью объектов описывать всё что угодно. Мы неоднократно разговаривали о гитаристах. Так же вы можете создать объект, чтобы описать некое животное, допустим, собаку. Вы можете создать объект, который будет описывать свойства этого животного и методы, которые можно использовать.</p>
      <p>Зачем мы создали абстракцию на уровне ООП? Для того, чтобы мы могли говорить не в терминах конкретных DOM-элементов, не в терминах того, как мы вставляем разметку в DOM-дерево, добавляем css-классы или производим другие операции с DOM. Мы создаём эти абстракции, чтобы описать сущности предметной области и логику.</p>
      <p>А что такое логика? Когда к вам приходит менеджер проекта, он обычно даёт вам техзадание, в котором написано — сайт содержит карточки задач, которые составляют полный список этих самых задач. Карточки переключаются между собой фильтрами, то есть имеется список фильтров. Получается, что когда вы начинаете использовать ООП в своём коде, вы отходите от конкретной реализации и описываете поведение вашего сайта на уровне абстракции. Это значит, что вместо того, чтобы оперировать такими понятиями как DOM-элемент, который является тегом <code>&lt;article&gt;</code>, у которого есть css-класс .task, внутри которого лежит тег <code>&lt;button&gt;</code>, вы оперируете понятием «карточка задачи». Чтобы у вас появилась карточка задачи, вам нужно соответственно описать класс, который называется Task.</p>
      <p>Задач у вас много, вы их начинаете между собой связывать. Задачи находятся внутри списка задач, то есть внутри доски, на которой эти задачи размещаются. Поэтому будет полезным создать новую абстракцию, которая так и называется — Board, для проведения манипуляций со списком карточек. Получается, что ООП помогает приблизиться к уровню описания техзадания вашего проекта. Если посмотреть на этот код без конкретных деталей реализации — вы начинаете писать его, как будто объясняете кому-то просто на английском языке. Компонент новой задачи, я отрисовываю в начале списка этих задач. Получается, я создаю новую абстракцию, которая уже не оперирует DOM-деревом, и это может быть нам полезно.</p>
      <p>Получается, что ООП позволяет нам говорить на более высоком уровне, позволяет нам обращаться с кодом на уровне понимания того, как работает в целом система. Ровно то, о чем было сказано выше — это объекты и сообщение между ними. Вы разделяете карточку задачи на некоторые объекты, которые есть внутри этой карточки и настраиваете между ними некоторые связи. А ещё, кроме того, что классы позволяют вам начать мыслить более абстрактно, у вас упрощается сопровождение кода. Наверное...</p>
      <p>Почему «наверное»? Вот здесь самая главная оговорка про ООП. Сейчас мы с вами рассматриваем, какие бывают виды компонентов, как их можно между собой стыковать, как они между собой взаимодействуют. Но дело в том, что ООП не работает без определённого рода договорённостей. Это значит, что в ООП нет смысла, если вы используете его только для себя. Если вы используете ООП в команде и используете в качестве этих абстракций (объектов) какие-то сущности, которые другие разработчики не поймут, то есть только плод вашего сознания, то ООП вам не поможет. ООП нужно для того, чтобы договориться всем вместе и начать разговаривать на одном языке.</p>

      <h4>«Недостатки» ООП</h4>
      <p>И самый главный минус — это высокий порог входа. Чтобы начать писать на ООП, вам нужно пройти тот путь, который вы прямо сейчас уже прошли. Сначала нужно понять, что такое программирование в принципе, что такое алгоритмы. Потом вам нужно понять, что такое функции внутри этих алгоритмов. Далее — что такое модули. И только потом, когда вы начнёте понимать эти вещи, вы сможете начать мыслить на более высоком уровне.</p>
      <p>Кроме этого существует мнение, что использование ООП сделает ваши программы лучше. Но само по себе не сделает. ООП — это просто способ написания кода, когда вы всё описываете в виде объектов, и описываете взаимосвязи между объектами. Но когда у вас появляется очень много разных сущностей, программа становится большой и внутри неё становится сложно ориентироваться, вам становится необходима архитектура приложения. То есть вам нужно будет не только выделить сами сущности и компоненты, но и определиться с их ролями, видом и организацией.</p>
      <p>Так же ООП не подходит для решения любой задачи. Очень частая ошибка новичков заключается в том, что, начиная изучать ООП, пишешь классы там, где просто достаточно написать одну маленькую функцию. Объектно-ориентированный подход нужно использовать только тогда, когда он нужен. Иногда бывают ограничения. Например, в языках Java и Kotlin, можно использовать только ООП-подход — потому что это ООП-языки, другие парадигмы в них не работают. Но важно помнить, что не нужно усложнять свой код с ООП, а это очень большой соблазн. Когда вы начинаете углубляться в абстракции — нужно уметь держать себя в руках и в какой-то момент времени останавливать рост абстракций.</p>

      <h4>Принципы ООП</h4>
      <p><span className="hl-7">Первый принцип называется инкапсуляция, второй — наследование, третий — полиморфизм.</span></p>

      <h5>Инкапсуляция</h5>
      <p>С латыни переводится как in capsulo — помещение чего-то в капсулу. И на самом деле, понятие инкапсуляции относится не только к программированию. В программировании инкапсуляция — это сокрытие деталей реализации, это как раз про интерфейсы. Первый принцип ООП — каждый объект должен иметь свой собственный чёткий интерфейс, и детали его реализации должны быть инкапсулированы внутри этого интерфейса.</p>
      <p>У нас есть компьютер, и он умеет очень много разных вещей. Он умеет отображать информацию на экране, умеет эту информацию принимать через клавиатуру, умеет выводить информацию через колонки, принимать через микрофон. Он умеет блокироваться, у него есть способы соединения с сетью, у него есть способы хранить информацию. Но это все разные вещи. Если посмотреть на компьютер как на объект, то его интерфейсом будет, например, экран и клавиатура. Интерфейс — это то, с помощью чего вы взаимодействуете с объектом. Я могу вводить информацию в компьютер, и компьютер мне эту информацию выведет. Мне по большому счёту не важно, как он это реализует. Мне это неинтересно, это интересно компьютеру. Компьютеру то, что пользователь ввёл с клавиатуры, нужно где-то сохранить. Ему нужен жёсткий диск. Когда я сижу за компьютером, мне не интересен жёсткий диск. Я пользуюсь публичным интерфейсом этого компьютера, а все детали его реализации инкапсулированы.</p>
      <p>Первый принцип ООП заключается в том, что у каждого объекта есть чёткий фиксированный интерфейс, но нам не интересны детали его реализации — они инкапсулированы и скрыты внутри объекта.</p>
      <p>Класс должен быть черным ящиком, мы взаимодействуем с классом через его публичный интерфейс. Мы не пытаемся изменить поведение или состояние класса в обход публичного интерфейса. Мы не пытаемся переписать приватные поля класса ради этого. И это очень важно, потому что если мы начинаем вмешиваться в то, как работает этот класс — мы можем сломать наш код или даже чужой код, который так же использует этот класс. Именно про это говорит принцип инкапсуляции.</p>
      <p>Инкапсулирование — это про то, что мы прячем реализацию внутрь, а наружу выставляем только публичные методы. Дело в том, что методы и свойства разделяются на два вида — публичные и приватные. Публичные — это то, чем мы можем пользоваться снаружи. Приватные — это то, как мы храним информацию внутри, к приватными относятся и #приватные свойства, и _защищённые.</p>
      <p>Рассмотрим объект Date. Я пользуюсь этим объектом как настоящей датой, я могу вывести её в консоль, могу потрогать её методы. То есть я пользуюсь этим объектом с помощью публичного интерфейса, но что является инкапсуляцией? Инкапсуляцией является то, что на самом деле где-то внутри себя Date хранит число — количество миллисекунд, прошедших с начала эпохи Unix, то есть с полуночи первого января 1970 года. Мне не нужно это знать, чтобы пользоваться объектом Date:</p>
      <pre>{`const now = new Date();
console.log(now.getMonth() + 1);`}
      </pre>
      <p>Это часть публичного интерфейса, а то, что он внутри хранит у себя число — это приватные данные, и нам это неинтересно.</p>
      <p>Интерфейс — это набор всех свойств и методов объекта, просто часть этих свойств и методов — публичная, а часть — приватная, то есть она инкапсулирована внутри объекта, и я не хочу ей пользоваться. Поэтому, например, нужны геттеры и сеттеры. Если бы я писал объект Date с нуля, я бы создал внутри свойство _value, которое было бы числовым. А потом создал бы методы set month() и get month():</p>
      <pre>{`const myDate = {
  _value: 0,

  getMonth() {
    return this._value / 100;
  },

  setMonth(value) {
    this._value = value;
  },
};`}
      </pre>
      <p>И эта часть интерфейса (защищёное поле _value) у меня приватная. Она нужна только для того, чтобы все работало. А эта часть (setMonth(), getMonth()) — публичная. Я как бы говорю другим программистам — пользуйтесь публичной частью моего объекта, потому что она замечательная, и у меня есть все необходимые методы, чтобы вы могли этим объектом пользоваться.</p>
      <p>В языке Java есть специальное слово private, которое помечает часть интерфейса как приватную, вы ничего не можете с ней сделать снаружи. В JavaScript не так. В нём вы можете получить доступ к приватным методам, поскольку на уровне самого языка нет конструкций, помечающих свойства и методы как приватные. Поэтому программисты просто договорились, что поля, начинающиеся с _ являются приватными, и к ним обращаться снаружи нельзя.</p>
      <p>JavaScript позволяет ограничить доступ снаружи к #приватным полям, но _защищённые доступны всем. Программисты просто договорились, что поля, начинающиеся с _, являются защищёнными, и к ним обращаться снаружи нельзя. Но вам всё равно нужно продумывать, какая часть вашего интерфейса будет публичной, а какая — приватной.</p>
      <p>Подытожим: к #приватным полям не даст обратиться сам JavaScript, к _защищённым сами программисты не будут. Получается, что интерфейс — про то, чтобы воспользоваться объектом, а приватная часть, инкапсуляция — она про то, чтобы не сломать то, за счёт чего этот объект работает.</p>
    </section>
  );
}
export default AboutProgramming;
