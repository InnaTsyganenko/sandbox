import React from 'react';

function ArrowFunction() {

  return (
    <section className="conspect">
      <h1>Стрелочные функции</h1>
      <h2>Синтаксис</h2>
      <p>В ECMAScript 2015 появился новый синтаксис для определения функций - стрелочные функции (arrow function). Он более лаконичен и особенно удобен при описании функций, <span className="hl-3"> выполняющих одно действие</span>.</p>
      <pre>{`{// Пример стрелочной функции
(param1, param2, paramN) => {
  // Действие 1
  // Действие N
  // return <Результат>
}

// Пример стрелочной функции без параметров
() => {
  // действие
}

// Стрелочная функция из одного действия
() => expression;

Пример определения стрелочной функции для умножения чисел:

const multiply = (a, b) => {
  return a * b;
}

multiply(2, 2); // 4}
`}
      </pre>
      <p>Функция multiply определена в виде выражения. Только вместо функционального выражения применяется выражение стрелочной функции (arrow function expression).<span className="hl-2">Важно запомнить: стрелочная функция всегда анонимна</span>. Мы не можем задать для неё имя и объявить декларативно, как это делали с function</p>
      <p>Поэтому, если требуется описать стрелочную функцию, к которой планируется обращение в будущем, необходимо сохранить на неё ссылку в переменную. Одним словом воспользоваться выражением стрелочной функции. В примере выше, ссылка на стрелочную функцию для умножения сохраняется в константе multiply.</p>

      <h2>Ещё более короткий синтаксис</h2>
      <p>Если функция состоит из одного выражения (действия), то фигурные скобки и оператор return необязательны:</p>
      <pre>{`const multiply = (a, b) => a * b;
multiply(2, 2); // 4`}
      </pre>

      <h2>Вернуть объект</h2>
      <p>А что если единственная задача стрелочной функции вернуть объект, созданный с помощью литерала? Можно ли в этом случае воспользоваться сокращённым синтаксисом, рассмотренным в прошлом разделе? Попробуем выполнить пример, представленный ниже. Увы, результатом станет не объект с единственным свойством stringCount, а значение undefined.</p>
      <pre>{`const getGuitar = () => { stringCount: 6 };
getGuitar(); // undefined`}
      </pre>
      <p>Почему так произошло? Дело в том, что интерпретатор не смог понять, что мы от него хотим. Точнее растолковал фигурные скобки в контексте описания тела функции. Ведь ранее мы об этом и говорили: для описания тела функции применяются фигурные скобки. Как же быть тогда с объектом?</p>
      <p>Решить эту проблему можно двумя способами. Первый самый простой: определить объект в теле функции и вернуть его в виде результата функции при помощи оператора return. Второй способ заключается в применении сокращённого синтаксиса. Только результат (новый объект) следует обернуть в круглые скобки. Тогда интерпретатор точно поймёт, что в скобках именно объект:</p>
      <pre>{`const getGuitar = () => ({ stringCount: 6 });
getGuitar(); // { stringCount: 6 }`}
      </pre>

      <h2>Отбрасываем скобки</h2>
      <p>На этом возможность «сэкономить» на символах при определении стрелочных функции не заканчивается. В случаях, когда стрелочная функция принимает лишь один параметр, круглые скобки можно не писать. Рассмотрим на примере:</p>
      <pre>{`const addTwo = count => count + 2;
addTwo(2); // 4`}
      </pre>
      <p>Определение функции addTwo выглядит ещё короче за счёт отказа от скобок.Однако мы рекомендуем не применять такой способ, а всегда описывать параметры стрелочной функции в скобках. Это удобно по нескольким причинам: при чтении кода глазу проще отделить тело функции от параметров. Причина субъективная, но многие разработчики сходятся в этом мнении. Другая причина заключается в упрощении рефакторинга. Если потребуется добавить второй параметр, то придётся возвращать скобки. Мелочь, но фактически дополнительное неудобство.</p>

      <h2>Отсутствует arguments</h2>
      <p>Вы уже знаете, что внутри function доступна локальная переменная arguments. Это массивоподобный объект, содержащий все аргументы, переданные в функцию. Напомним на примере:</p>
      <pre>{`function multiply(a, b) {
  console.log(arguments[0]);
  console.log(arguments[1]);
}

multiply(2, 5); // 2, 5`}
      </pre>
      <p>Стрелочным функциям переменная arguments недоступна. Если к ней обратиться, то вместо вывода значений аргументов, возникнет ошибка arguments is not defined. А как же тогда быть, если требуется описать функцию с неопределённым количеством параметров? Решить задачу поможет rest-оператор. Он соберёт все параметры в массив. Рассмотрим на примере:</p>
      <pre>{`const numbersToArray = (...numbers) => numbers;
console.log(numbersToArray(2, 5, 6, 6, 7)); // [2, 5, 6, 6, 7]`}
      </pre>
      <p>Совмещая эту возможность с методами массивов, можно получить интересные комбинации. Например, написать функцию для подсчёта суммы чисел и так далее (см. метод reduce).</p>

      <h2>Другие особенности</h2>
      <p>Стрелочные функции не могут использоваться в качестве функций-конструкторов. Они не образуют собственный контекст (this), а используют контекст окружения, в котором объявлены. Из-за отсутствия контекста, стрелочные функции не могут вызываться с помощью оператора new.</p>
      <p>А раз стрелочные функции не образуют собственный контекст, то применение методов apply, call и bind теряет смысл. Переопределить или задать произвольное значение контекста попросту не получится.</p>
      <p>Может показаться, что из-за отсутствия собственного контекста, стрелочные функции имеют ограниченное применение. Это не так. Особенность с контекстом реализована намерено, так как позволяет избавиться от потери окружения. До появления стрелочных функций, его приходилось сохранять самостоятельно, что не очень удобно. Рассмотрим на примере:</p>
      <pre>{`const musicStore = {
  artist: 'Bon Jovi',
  albums: [
      'Runaway',
      'Slippery when wet',
      'New Jersey',
      'Keep the faith',
  ],

  print() {
      this.albums.forEach(function(album) {
          console.log('&dollar;{this.artist} — &dollar;{album}');
      });
  }
}`}
      </pre>
      <p>Если выполнить этот небольшой фрагмент кода в консоли браузера, вместо имени артиста будет выведено значение undefined. Внутри анонимной функции, которая передаётся в forEach другой контекст. Поэтому вместо вывода значения поля artist мы получаем undefined. Исправить проблему можно несколькими способами.</p>
      <p>Первый заключается в применении старого подхода — предварительное сохранение контекста в отдельную переменную. Например:</p>
      <pre>{`print() {
  // Сохраним контекст
  const self = this;
  this.albums.forEach(function(album) {
      // Вместо 'this' обратимся к 'self'
      console.log('&dollar;{self.artist} — &dollar;{album}');
  });
}`}
      </pre>
      <p>Попробуйте обновить функцию (метод) print и вновь запустить пример. В этот раз результат вывода совпадёт с ожидаемым.</p>
      <p>Второй способ решения — воспользоваться стрелочной функцией. Поскольку стрелочные функции не образуют свой контекст, то ничего сохранять больше не нужно:</p>
      <pre>{`print() {
  this.albums.forEach((album) => {
      console.log('&dollar;{this.artist} — &dollar;{album});
  });
}`}
      </pre>
      <p>Но стрелочная функция — это не краткий способ объявления функции. У стрелочных функций есть определённая задача, они запоминают this (контекст) родителя. Пока что это нужно просто запомнить. В будущих разделах мы разберём, что такое this, и тогда же разберём, почему в некоторых случаях его важно запоминать.</p>
    </section>
  );
}
export default ArrowFunction;
