import React from 'react';

function Objects() {

  return (
    <section className="conspect">
      <h1>Объекты</h1>
      <p><b>Объект</b> — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Если массив — нумерованный список, где каждый элемент имеет свой порядковый номер, то объект — список, в котором каждый элемент сопоставлен со своим ключом и порядок совсем неважен.</p>
      <p>Для создания объекта используют уже знакомые вам фигурные скобки <code>&#123; &#125;</code>.</p>
      <pre>{`var cat = {};
// Так создаётся объект с именем cat`}
      </pre>
      <p>Добавляем свойства - пары «ключ-значение», которые содержит в себе объект, называются свойствами или атрибутами. Выглядят они так:</p>
      <pre>{`var cat = {
  name: 'Кекс',
  // name — ключ, 'Кекс' — значение
  age: 5
  // ключ — age, значение — 5

  // такие объекты также называют мапами или словарями
};`}
      </pre>
      <p>Cинтаксис:</p>
      <ul>
        <li>Ключ обособляется от значения двоеточием.</li>
        <li>Пары «ключ-значение» отделяются друг от друга запятыми.</li>
        <li>Значениями могут быть данные любого типа (число, строка, массив и так далее).</li>
      </ul>
      <div className="note">Запись объекта со всеми свойствами в фигурных скобках, называется литералом объекта. Если необходимо создать объект с помощью литерала, вам просто нужно использовать фигурные скобки. И если у объекта есть какие-то свойства, записать их внутри этих скобок.</div>

      <h2>Читаем из объекта</h2>
      <h3>Точечная нотация</h3>
      <p>Чтобы получить значение свойства, к нему надо обратиться через точку объект.ключ. Возвращает значение свойства объекта, если такое свойство есть. В противном случае вы получите undefined, то есть ничего.</p>
      <h3>Скобочная нотация</h3>
      <p>Скобочная нотация намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в переменную:</p>
      <pre>{`var name = 'Кекс';
var catsFavoriteFood = { 'Кекс': 'рыба' };

console.log(catsFavoriteFood.name);
// Выведет в консоль: undefined

console.log(catsFavoriteFood[name]);
// Выведет в консоль: рыба

console.log(catsFavoriteFood[name]);
// Незаметно внутри программы превращается в:
console.log(catsFavoriteFood['Кекс']);`}
      </pre>
      <p>Первое сообщение содержит undefined, потому что у объекта нет свойства name. Второе сообщение содержит искомое значение, потому что программа понимает, что в квадратных скобках переменная. Значение переменной подставится в скобки, а затем будет найдено нужное свойство объекта.</p>
      <p>В качестве ключей в объекте можно использовать любые строки, даже строки с пробелами. С точечной нотацией такие свойства прочитать не получится, а со скобочной — без проблем.</p>
      <pre>{`var cat = { 'favorite food': 'Сметана' };

console.log(cat.favorite food);
// Вызовет ошибку

console.log(cat['favorite food']);
// Отработает нормально`}
      </pre>

      <h2>Создание свойств</h2>
      <p>Начиная со стандарта ES2015 в объектах появились новые способы создания свойств: упростилось создание свойств на основе существующих переменных и появилась возможность использовать вычисляемые ключи (квадратные скобки) на этапе создания объекта.</p>

      <h2>Переопределение свойств.</h2>
      <p>Свойства объектов можно переопределять, как и обычные переменные.</p>
      <pre>{`var cat = {
  name: 'Кекс',
  age: 5
};

cat.age++; // Увеличили возраст кота на 1
console.log(cat.age) // Выведет в консоль: 6

cat.name = 'Рокки'; // Заменили снаружи значение свойства name
console.log(cat.name); // Выведет в консоль: Рокки`}
      </pre>

      <pre>{`


// Если в ES5 вам нужно было записать переменную
// в объект так, чтобы название свойства совпадало
// с названием переменной, приходилось дублировать
// название при объявлении объекта
const name = 'Harry Potter';
const user = {
  name: name,
  age: 10,
};

user; // {name: 'Harry Potter', age: 10}
// То ES2015 позволяет создавать такие свойства
// в объектах, используя в два раза меньше букв
const name = 'Harry Potter';
const user = {
  name,
  age: 10,
};

user; // {name: 'Harry Potter', age: 10}
Немного упростился и синтаксис объявления методов в объекте,
теперь можно не писать ключевое слово function.

// ES5
const name = 'Harry Potter';
const user = {
  name: name,
  age: 10,
  fire: function () {
    return 'Expecto Patronum';
  },
};

user.fire(); // 'Expecto Patronum'
// ES2015
const name = 'Harry Potter';
const user = {
  name,
  age: 10,
  fire() {
    return 'Expecto Patronum';
  },
};

user.fire(); // 'Expecto Patronum'
В некоторых случаях, в объектах хочется использовать вычисляемые ключи,
то есть создавать значения ключей с помощью квадратных скобок.
Например, это может пригодиться при использовании объектов в качестве словарей.
Новый синтаксис позволяет использовать вычисляемые ключи на этапе создания новых объектов,
а не только при обращении к уже существующим.

const voldemort = 'Tom Riddle';
const potter = 'Harry Potter';
const dumbledore = 'Albus Dumbledore';
const grindewald = 'Gellert Grindewald';

// Чтобы создать словарь, в котором в качестве ключей,
// например, используются уже существующие значения,
// или использовать ключи, которые содержат необычные
// символы, в ES5 приходилось пользоваться нотацией
// квадратных скобок уже после создания объекта, то есть
// постоянно изменять объект, добавляя в него новые значения
const antagonist = {};
antagonist[potter] = voldemort;
antagonist[dumbledore] = grindewald;
antagonist['Sirius Black'] = 'Bellatrix Lestrange';
// Новый синтаксис ES2015 позволяет использовать
// квадратные скобки ещё на этапе создания объекта
const antagonist = {
  [potter]: voldemort,
  [dumbledore]: grindewald,
  ['Sirius Black']: 'Bellatrix Lestrange',
};`}
      </pre>

      <h2>Передаём объект по ссылке</h2>
      <pre>{`var firstCat = {
  name: 'Кекс',
  age: 5
};

var secondCat = firstCat;
console.log(secondCat);
// Выведет: {name:"Кекс", age:5}

firstCat.name = 'Снежок';
console.log(secondCat);
// Выведет: {name:"Снежок", age:5}`}
      </pre>
      <p>Мы не трогали второй объект secondCat, но он изменился вместе с первым объектом firstCat.</p>
      <p>В JavaScript объект всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать или сорок. Это особенность объектов, она так и называется — передача объектов по ссылке.</p>

      <h2>Методы объектов</h2>
      <p>В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами объектов. Они вызываются так же, как и любые другие функции, через круглые скобки, а обращаемся мы к методам, как и к свойствам объекта. В итоге вызов метода записывается так: объект.метод().</p>
      <p>Главное в создании метода — придумать подходящее название, описывающее, что делает этот метод. В мире программирования есть устоявшиеся традиции именования. Например, функции, которые что-то возвращают, называются геттерами и начинаются со слова get. Это выглядит так:</p>
      <pre>{`var cat = {
  name: 'Кекс',
  color: 'рыжий',
  age: 5,

  getGreeting: function() {
    return 'Мяу, привет!';
  }
};

console.log(cat.getGreeting()); // Выведет: Мяу, привет!`}
      </pre>
      <p>Методы используются для работы с объектами. Они читают свойства, переписывают их и возвращают. Да, можно создать внешнюю функцию, передавать ей объект и обрабатывать внутри этой функции. Но намного удобней держать в объекте всё, что относится именно к этому объекту. Например, мы храним технические характеристики внутри объекта компьютера, нам нужно возвращать строку с данными и высчитывать цену. Эти две задачи связаны именно с объектом компьютера, поэтому мы будем записывать эти функции в объект.</p>
      <p>Изнутри методов можно обращаться к свойствам и другим методам объекта с помощью ключевого слова this. Оно указывает на текущий объект и называется контекстом вызова.</p>
      <p><span className="hl-6">Важная деталь:</span> пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.</p>
      <p></p>
      <p></p>
      <p></p>

      <h2>Геттеры и сеттеры</h2>
      <p>Многие методы объектов создаются для того, чтобы специальным образом задавать внутренние свойства этих объектов или давать доступ внешнему пользователю к таким свойствам. Такие внутренние свойства часто называют служебными или приватными и, по договорённости между всеми JavaScript-разработчиками, называют с подчёркивания _.</p>
      <pre>{`
        const wizard = {
          _level: 1, // Служебное свойство
          getLevel() {
            return this._level;
          },
        };

        wizard.getLevel(); // 1
      `}
      </pre>
      <p>По смыслу getLevel — это метод, который позволяет получить значение, то есть геттер (от англ. get, получать). А вот по синтаксису — обычная функция.</p>
      <p>В ES2015 появилась возможность создавать специальные методы, геттеры. Для их объявления используется специальный синтаксис, а снаружи к такому геттеру можно обращаться как к обычному свойству, через точку. Но при обращении будет вызываться именно геттер.</p>
      <pre>{`
        const wizard = {
          _level: 1,
          // Перед объявлением геттера нужно добавить слово get.
          // Параметры геттеру задать невозможно, потому что нет
          // никакого способа их передать
          get level() {
            return this._level;
          },
        };

        wizard.level; // 1
      `}
      </pre>
      <p>Хотя геттеры функции, они именуются как существительные, потому что снаружи к ним обращаются как к свойствам, без круглых скобок.</p>
      <p>Обратите внимание, что при объявлении геттера в его теле не нужно обращаться к нему же. Например, в примере выше, в теле метода level нельзя написать this.level, потому что эта строчка опять вызовет тот же самый геттер и браузер уйдёт в бесконечный цикл. Именно поэтому значение хранится в служебном свойстве _level. В целом геттеры и сеттеры используются для записи и чтения служебных свойств.</p>
      <p>Существует и обратный синтаксис для геттеров — сеттеры (от англ. set, задавать или устанавливать). Сеттеры нужны для того, чтобы мы могли создавать методы, которые изменяют внутренние свойства объектов.</p>
      <pre>{`
        const wizard = {
          _level: 1,
          get level() {
            return this._level;
          },
          // Синтаксис сеттера похож на синтаксис геттера:
          // такое же ключевое слово перед объявлением метода
          // (только в этот раз 'set' вместо 'get').
          // Но разница в том, что сеттер всегда принимает один параметр.
          // Не принимать параметра он не может,
          // как не может и принимать несколько параметров
          set level(newValue) {
            this._level = newValue;
          },
        };

        wizard.level; // 1
        wizard.level = 2; // Задаём новое значение
        wizard.level; // 2
      `}
      </pre>
      <p>Обратите внимание, чтобы вызвать сеттер и задать новое значение нужно использовать оператор присваивания (знак равенства).</p>
      <h3>Преимущество геттеров и сеттеров</h3>
      <p>Какая же польза от геттеров и сеттеров, если всё тоже самое можно описать одним свойством:</p>
      <pre>{`
        const wizard = {
          level: 1,
        };

        wizard.level; // 1
        wizard.level = 2; // Задаём новое значение
        wizard.level; // 2
      `}
      </pre>
      <p>Польза начинается, когда нам нужно преобразовывать значения этого свойства. Например, сможете ли вы ответить, что за служебное свойство _level? А что значит его значение 1? Это знает только автор кода. Для тех, кто будет обращаться к геттеру, лучше вернуть осмысленную фразу, которая сразу всё объяснит:</p>
      <pre>{`
        // Словарь уровней игрока
        const level = {
          [1]: 'Новичок',
          [2]: 'Удалец',
          [3]: 'Магистр',
        };

        const wizard = {
          _level: 1,
          get level() {
            return 'Кажется, я &dollar;{level[this._level]}';
          },
          set level(newValue) {
            this._level = newValue;
          },
        };

        wizard.level; // Кажется, я Новичок
      `}
      </pre>
      <p>Теперь перейдём к сеттеру. У нас всего три уровня (см. словарь level), а что будет, если передать в сеттер -1? Или 4? Очевидно, что новое значение установится, но тогда сломается геттер, потому что level[4] будет undefined. Конечно, можно попросить пользователей сеттера не передавать число меньше 1 и больше 3, тем самым переложить на них эти заботы, но хорошая программа умеет обрабатывать такие случаи сама.</p>
      <pre>{`
        // Начнём с функции, которая зажимает (так переводится её название)
        // переданное значение между min и max. Проверьте.
        // Функция всегда возвращает то из трёх значений,
        // которое будет не меньшим и не большим — средним.
        // То есть из трёх "a < b < c" значений всегда будет возвращаться "b".
        // Кроме случаев, когда изначальные min > max. Мы такие не учитываем,
        // потому что сами задаём min и max и уверены в них
        const clamp = (value, min, max) => {
          return Math.max(Math.min(max, value), min);
        };

        const level = {
          [1]: 'Новичок',
          [2]: 'Удалец',
          [3]: 'Магистр',
        };

        const wizard = {
          _level: 1,
          get level() {
            return 'Кажется, я &dollar;{level[this._level]}';
          },
          set level(newValue) {
            this._level = clamp(newValue, 1, 3);
          },
        };

        wizard.level = 100; // Уровня 100 не существует, поэтому будет взято значение 3 (1 < 3 < 100)
        wizard.level; // Кажется, я Магистр

        wizard.level = -Infinity; // Уровня минус бесконечность не существует,
        поэтому будет взято значение 1 (-Infinity < 1 < 3)
        wizard.level; // Кажется, я Новичок
      `}
      </pre>
      <p>Преобразование значений при чтении и записи самая очевидная польза от геттеров и сеттеров, но далеко не единственная. Например, проксирование Proxy для отслеживания изменений в объекте с самописными getLevel() и setLevel() работать не будет, а с штатными get level() и set level() — будет.</p>
      <p>Появились сокращения при объявлении свойств объекта. Мы можем указать в качестве ключа переменную, и эта переменная автоматически раскроется в пару ключ-значение, где ключ — имя переменной, а значение — значение переменной, соответственно.</p>
      <pre>{`
        const name = 'Кекс';
        const male = true;
        const age = 7;

        const expected = {
          name: name,
          male: male,
          age: age,
        };

        const actual = {name, male, age};

        console.log(actual);
      `}
      </pre>
      <p>Важно помнить, что при переименовании переменной переименуется и её ключ.</p>
      <pre>{`
        const name = 'Кекс';
        const male = true;
        const keksAge = 7;

        const expected = {
          name: name,
          male: male,
          age: keksAge,
        };

        const actual = {name, male, keksAge};

        console.log(actual);
      `}
      </pre>
      <p>При объявлении метода объекта появилась короткая запись, которая позволяет записать сразу тело функции и имя.</p>
      <pre>{`
        const name = 'Кекс';

        const expected = {
          name: name,
          meow: function () {
            return 'Мяу!';
          },
        };

        const actual = {
          name,
          meow() {
            return 'Мяу!';
          },
        };

        console.log(expected);
        console.log(actual);
      `}
      </pre>
      <p>Давайте проверим, есть ли у этого метода контекст?!</p>
      <pre>{`
        const name = 'Кекс';

        const actual = {
          name,
          meow() {
            return '&dollar;{this.name}: Мяу!';
          },
        };

        console.log(actual.meow());
      `}
      </pre>
      <p>Важно помнить, что метод — это не стрелочная функция, а обыкновенная.</p>
      <pre>{`
        (function () {
          const name = 'Кекс';

          const expected = {
            name: name,
            meow: () => {
              return '&dollar;{this.name}: Мяу!';
            },
          };

          const actual = {
            name,
            meow() {
              return '&dollar;{this.name}: Мяу!';
            },
          };

          console.log(expected.meow());
          console.log(actual.meow());
        })();
      `}
      </pre>
      <p>Помимо обычных методов у объектов доступны специальные методы — getter и setter.</p>
      <pre>{`
        let name = 'Кекс';

        const cat = {
          getName() {
            return name;
          },
          setName(newName) {
            name = newName;
          },
        };

        console.log(cat.getName());

        cat.setName('Новое имя');

        console.log(cat.getName());
      `}
      </pre>
      <p>Эти методы притворяются свойствами или полями объекта, хотя на самом деле являются функциями. Чтобы вызвать getter, надо обратиться к нему без скобок.</p>
      <pre>{`
        const name = 'Кекс';

        const cat = {
          get name() {
            console.log('Getter is called!');
            return 'Секрет';
          },
        };

        console.log(cat.name);
      `}
      </pre>
      <p>Соответственно, setter используется, чтобы установить значение.</p>
      <pre>{`
        const name = 'Кекс';

        const cat = {
          get name() {
            if (this.myName) {
              return this.myName;
            }
            return 'Секрет';
          },
          set name(newName) {
            this.myName = newName;
          },
        };

        console.log(cat.name);

        cat.name = 'Феофан';

        console.log(cat.name);
      `}
      </pre>
      <p>Если определен только setter, то взять значение по этому имени невозможно.</p>
      <pre>{`
        const name = 'Кекс';

        const cat = {
          set name(newName) {
            this.myName = newName;
          },
        };

        console.log(cat.name);

        cat.name = 'Феофан';

        console.log(cat.name);
        console.log(cat.myName);
      `}
      </pre>
      <p>Спецификация явно запрещает одновременно использовать одноимённое поле, get и set. Поле придётся переименовать, например в `_name`. Однако не во всех браузерах это вызывает ошибку, будьте внимательны.

      </p>
      <pre>{`
        const name = 'Кекс';

        const cat = {
          name,
          set name(newName) {
            this.myName = newName;
          },
          get name() {
            return this.myName;
          },
        };

        console.log(cat.name);

        cat.name = 'Феофан';

        console.log(cat.name);
        console.log(cat.myName);
      `}
      </pre>
      <p>getter может быть только функцией без параметров, а setter — функцией с ровно одним параметром.</p>
      <pre>{`
        const name = 'Кекс';

        const cat = {
          set name(newName) {
            this.myName = newName;
          },
          name,
          get name() { // Если добавить геттеру параметр, получим ошибку
            return this.myName;
          },
        };
      `}
      </pre>
      <p>Также ключи объектов теперь можно вычислять во время создания.</p>
      <pre>{`
        const name = 'Кекс';
        const states = ['Жидкий', 'Твёрдый', 'Газообразный'];
        const randomState = () => states[Math.floor(Math.random() * states.length)];

        const expected = {
          name: name,
        };
        expected[randomState()] = true;

        const actual = {
          name,
          [randomState()]: true,
        };

        console.log(expected);
        console.log(actual);
      `}
      </pre>
      <p>Благодаря этому можно использовать шаблонную строку в качестве ключа.</p>
      <pre>{`
        const name = 'Keкс';
        const owner = 'Александр';

        const actual = {
          name,
          ['owner — &dollar;{owner}']: true,
        };

        console.log(actual);
      `}
      </pre>
      <p>Ключи get и set также могут быть вычисляемыми.</p>
      <pre>{`
        const name = 'Keкс';
        const owner = 'Александр';

        const actual = {
          get ['name']() {
            return name;
          },

          ['owner — &dollar;{owner}']() {
            return owner;
          },
        };

        console.log(actual);
      `}
      </pre>
      <p>Из мелких изменений в объектах — подвешеная запятая и возможность определить одно и то же поле несколько раз, при этом побеждает самое позднее объявление.</p>
      <pre>{`
        const name = 'Keкс';
        const owner = 'Александр';

        const actual = {
          name,
          owner,
          owner: 'Пётр',
          ['owner']: 'Леопольд',
          allowsTrailingComma: true,
        };

        console.log(actual);
      `}
      </pre>

      <h2>Удаление и проверка свойств объектов</h2>
      <p>Свойства объектов можно удалять. В любой момент вы можете удалить свойство объекта при помощи оператора delete.</p>
      <p>Раз свойства у объектов можно удалять, то вполне возможна ситуация, когда потребуется выполнить проверку на существование определённого свойства. Это можно сделать несколькими способами. Первый: сравнить с undefined. Второй: воспользоваться оператором in.</p>
      <p>Выбирая первый способ, следует быть осторожным. Ничего не мешает присвоить свойству объекта значение undefined. Такая операция не удалит свойство, но может ввести в заблуждение во время выполнения проверки. Поэтому лучше воспользоваться вариантом с оператором in.</p>
      <pre>{`
        // Объект "Гитарист"
        const guitarPlayer = {
          firstName: 'Richie',
          lastName: 'Sambora',
          play() {
            console.log('Rock!');
          },
        };

        console.log(guitarPlayer.lastName);

        // Свойство может быть удалено
        delete guitarPlayer.lastName;

        console.log(guitarPlayer.lastName);




        const makeGuitarPlayer = (firstName, lastName) => {
          return {
            firstName,
            lastName,
          };
        };

        const guitarPlayer = makeGuitarPlayer('Richie', 'Sambora');
        console.log(guitarPlayer);

        // Проверим, существует ли свойство 'firstName'

        // Способ №1. Сравнить с undefined
        console.log(guitarPlayer.firstName !== undefined);

        // Способ №2. Воспользоваться оператором 'in'
        console.log('firstName' in guitarPlayer);

      `}
      </pre>
    </section>
  );
}
export default Objects;
