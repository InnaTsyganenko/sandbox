import React, {useState} from 'react';
import AboutGeteventlisteners from '../events/geteventlisteners';

function Events() {
  const [state, setState] = useState({
    activeItem: {},
  });

  function toggleActiveItem(value) {
    setState({activeItem: {[value]: true}});
  }

  return (
    <section className="conspect">
      <h1>События</h1>
      <h2>Знакомимся с событиями</h2>
      <p>Действие, когда пользователь что-то делает с элементами страницы (например, кликает по кнопке или нажимает клавишу) называется событием.</p>
      <p><a href="https://developer.mozilla.org/ru/docs/Web/Events" target="_blank" rel="nofollow noopener noreferrer">Справочник по событиям <abbr data-title="Mozilla Developer Network">MDN</abbr></a></p>
      <button className="add-theory-button"
        onClick={() => (state.activeItem['about-geteventlisteners']) ? toggleActiveItem('') : toggleActiveItem('about-geteventlisteners')}
      ><span className="hl-2">Про getEventListeners</span>
      </button>
      {(state.activeItem['about-geteventlisteners']) && <AboutGeteventlisteners />}

      <h2>Как добавить обработчик</h2>
      <pre>{`
button.addEventListener('click', function () {
// Инструкции
});
`}
      </pre>
      <ol>
        <li>Элемент
          <p>В примере выше button — кнопка, на которой мы будем ждать пользовательское событие (клик, нажатие, ввод). Этот элемент указывается в самом начале.</p>
          <p>Далее, через точку, мы добавляем addEventListener. То есть указываем, что хотим добавить «слушатель события».</p>
        </li>
        <li>Название события
          <p>Первый параметр функции addEventListener - название события, которое мы хотим поймать. Название записывается строкой, поэтому обязательно указывается в кавычках. Для всех событий есть специальные зафиксированные названия, поэтому мы не можем ловить событие клика, передав любую строку, которая придёт в голову, например, &apos;push&apos;.</p>
        </li>
        <li>Обработчик
          <p>Второй параметр addEventListener — функция. Функция addEventListener() говорит о том, что мы добавляем обработчик события на элемент. Дословно «добавляем слушатель события». Обработчик «слышит» всё, что происходит на странице и обязательно услышит, когда произойдёт то событие, которое нужно нам. Если мы правильно его настроим.</p>
          <p>Это и есть обработчик события. Внутри этой функции мы указываем, что нужно сделать, когда произойдёт событие, как его нужно обработать. Инструкции внутри этой функции могут быть любыми: можно выводить сообщения в консоль (это может пригодиться при отладке кода), менять классы или содержимое элементов, вызывать другие функции.</p>
        </li>
      </ol>
      <p>Главное, на что нужно обратить внимание — функция, переданная в обработчик, не выполняется сразу. Действия из тела этой функции выполнятся только когда произойдёт установленное событие.</p>
      <p>В итоге всю запись из примера можно прочитать так: добавим обработчик клика на кнопку button. При клике по кнопке должны выполниться какие-то инструкции.</p>
      <pre>{`
var button = document.querySelector('.button');

button.addEventListener('click', function () {
// Инструкции
});
`}
      </pre>
      <p>Мы передаём одну функцию в качестве параметра в другую функцию — в addEventListener. Такая запись может удивить, но это обычная практика — в JavaScript так делать можно, мы не записываем функцию в переменную.</p>
      <p>У такой функции нет своего имени, она не записана в переменную. Мы создаём её там же, где передаём в другую функцию. Такие функции, которые создаются в момент передачи и не имеют названия, называются анонимными функциями.</p>
      <p>Обратите внимание на самую важную часть — мы передаём функцию в обработчики, а не вызываем её. Если мы вызовем обработчик, код из него сразу выполнится, и в нужный момент наши инструкции не сработают. Код выполнится только один раз в момент вызова и больше не будет повторяться. Это распространённая ошибка, но так делать неправильно.</p>
      <pre>{`
// Так добавлять обработчик неправильно

button.addEventListener('click', function () {
console.log('Клик по кнопке');
}());
// В консоль сразу же выведется сообщение: Клик по кнопке

// А такой код верный:

button.addEventListener('click', function () {
console.log('Клик по кнопке');
});
// Сообщение выведется, когда произойдёт событие клика
`}
      </pre>
      <p>Вообще JavaScript выполняет программу последовательно, команду за командой. Но к событиям это не относится. Дело в том, что события не происходят последовательно, синхронно. Мы настраиваем обработчик, но инструкции выполняются не сразу, а только тогда, когда произойдёт событие. Это может произойти и через 5 минут после открытия сайта, и через 10, а может пользователь вообще не кликнет по ссылке или кнопке. Тогда событие не случится. События асинхронны, то есть происходят не по расписанию в какое-то конкретное время, друг за другом, а тогда, когда понадобится.</p>

      <h3>Объект event</h3>
      <p>Объект event — параметр функции-обработчика. Он всегда передаётся браузером в эту функцию в момент наступления события. Этот объект содержит много полезных свойств и методов.</p>
      <p>Чтобы использовать event, достаточно указать этот объект параметром функции-обработчика и написать инструкции. Остальное сделает JavaScript. Среди некоторых разработчиков принято называть параметр сокращённо — evt, во избежание ошибок.</p>

      <h3>Клавиатурные события - keydown</h3>
      <p>У события «нажатие на клавишу» есть специальное название — keydown. Такое событие срабатывает при нажатии на любую клавишу. Обратите внимание, слушать это событие можно только на элементах, которые имеют состояние фокуса: поля ввода, кнопки, элементы с атрибутом tabindex, документ. При нажатии фокус должен находиться на соответствующем элементе.</p>
      <pre>{`
document.addEventListener('keydown', function() {
// Код отсюда выполнится при каждом нажатии любой клавиши
});

document.addEventListener('keydown', function(evt) {
// Проверяем, что код клавиши равен 27
if (evt.keyCode === 27) {
  // Код отсюда выполнится только при нажатии ESC
}
});
`}
      </pre>
      <p>Кроме keyCode есть и другие свойства для определения нажатой клавиши. Например, key и code. Они возвращают названия клавиш, а не их номера. Эти свойства пока поддерживаются не во всех браузерах, но когда поддержка станет лучше, стоит начать использовать их вместо keyCode в соответствии с современным стандартом JavaScript.</p>

      <h3>Выбор клавиши</h3>
      <p>Это свойство называется keyCode. С помощью этого свойства каждую клавишу можно определить по коду. Например, у Enter код 13, а у ESC — код 27.</p>
      <pre>{`
document.addEventListener('keydown', function(evt) {
// Проверяем, что код клавиши равен 27
if (evt.keyCode === 27) {
  // Код отсюда выполнится только при нажатии ESC
}
});
`}
      </pre>
      <p className="hl-2">Кроме keyCode есть и другие свойства для определения нажатой клавиши. Например, key. Его отличие в том, что он возвращает не код клавиши, а её название в виде строки: «Enter», «Alt», «Escape». Ещё есть свойство code. Оно тоже возвращает название клавиши, при этом на значение не влияет выбранный язык клавиатуры. Эти свойства пока поддерживаются не во всех браузерах, но когда поддержка станет лучше, стоит начать использовать их вместо keyCode в соответствии с современным стандартом JavaScript.</p>

      <h2>Действия по умолчанию</h2>
      <p>Некоторые элементы страницы имеют действия по умолчанию. Их ещё называют дефолтными действиями. Например, клик по кнопке отправления формы вызывает отправку данных этой формы на сервер, а при клике по ссылке браузер переходит по этой ссылке.</p>
      <p>Когда срабатывает событие, браузер создаёт объект события Event. Объект event — параметр функции-обработчика. Он всегда передаётся браузером в эту функцию в момент наступления события. Этот объект содержит всю информацию о событии. У него есть свои свойства и методы, с помощью которых можно эту информацию получить и использовать. Один из методов как раз позволяет отменить действие браузера по умолчанию — preventDefault().</p>
      <p>Чтобы использовать свойства и методы объекта event, достаточно указать этот объект параметром функции-обработчика и написать инструкции. Остальное сделает JavaScript. Среди некоторых разработчиков принято называть параметр сокращённо — evt. Это позволяет избежать некоторых ошибок. Объект события будет передан в функцию, как только это событие случится.</p>
      <pre>{`
link.addEventListener('click', function(evt) {
// Отменяем действие по умолчанию
evt.preventDefault();

// Добавляем инструкции для события клика
console.log('Произошёл клик');
});
`}
      </pre>
      <p>В примере мы отменили действие по умолчанию и при клике по ссылке переход не произойдёт. Вместо этого при клике в консоль выведется сообщение: Произошёл клик.</p>
      <p>Примеры: по клику на кнопку нужно открыть попап, а не перейти по ссылке; проверка формы перед отправкой.</p>
      <p>Не для всех событий можно отменить действие по умолчанию. Например, событие прокручивания страницы scroll проигнорирует попытки отменить его. Чтобы узнать, можно отменить действие по умолчанию или нет, нужно обратиться к свойству cancelable объекта Event. Оно будет равно true, если событие можно отменить, и false — в обратном случае.</p>

      <h2>Обработчики событий onclick и onsubmit</h2>
      <p> JavaScript следит за всем, что происходит на странице. Клик по кнопке или отправка формы — это событие. Мы можем сказать JavaScript, что сделать, когда некое событие произойдёт. Для этого используют обработчики событий. Инструкции, которые должны будут выполниться, когда событие произойдёт, располагают между фигурных скобок.</p>
      Свойство onclick означает «по клику» и говорит JavaScript, какое событие мы хотим отслеживать.
      А та часть инструкции, которая идёт после onclick, называется обработчиком событий:
      <pre>{`
let button = document.querySelector('button');
// Сначала мы находим саму кнопку и сохраняем её в переменную
button.onclick = function() {
/* После того, как кнопка была найдена, мы указываем JavaScript,
что делать, когда по этой кнопке кликнут. Это может быть, например,
вывод сообщения в консоль */
console.log('Кнопка нажата!');
};
`}
      </pre>
      <p>При каждом клике по кнопке в консоли будет появляться новое сообщение Кнопка нажата!.</p>
      За обработку отправки формы отвечает свойство onsubmit:
      <pre>{`
let form = document.querySelector('form');
form.onsubmit = function() {
console.log('Форма отправлена!');
};
`}
      </pre>
      После отправки формы в консоли появится сообщение
      <pre>{'Форма отправлена!.'}</pre>
      <p>For example, новый текст на странице должен появляться, когда пользователь подпишется на рассылку.</p>
      <p>Для этого нам снова понадобится обработчик событий, только на этот раз мы будем отслеживать не клики, а отправку формы.</p>
      <p>В HTML кнопка отправки имеет тип submit, а в JavaScript за обработку этого события отвечает свойство onsubmit.</p>
      <p>Обратите внимание, обработчик событий в данном случае добавляется не на кнопку, а на саму форму:</p>
      <pre>{`
let someForm = document.querySelector('.some-form');
someForm.onsubmit = function() {
  console.log('Форма отправлена!');
};
`}
      </pre>
      <a href="examples/click-popup/index.html">Пример реализации открытия/закрытия попапа</a>

      <h2>Обработчики onchange и oninput</h2>
      <p>Чтобы отслеживать изменения в поле ввода, можно использовать обработчики onchange и oninput. Разница между ними заключается в следующем:</p>
      <p>onchange срабатывает, если значение поля ввода изменилось и пользователь закончил ввод. Например, если пользователь передвинул ползунок и отпустил его. Или ввёл что-то в текстовое поле и убрал из него курсор.</p>
      <p>oninput срабатывает на каждое изменение значения, независимо от того, завершил пользователь ввод или нет. Например, он сработает на каждое изменение положения ползунка, даже если пользователь продолжает его двигать. И на каждый новый символ в текстовом поле, даже если пользователь продолжает вводить текст. Когда мы меняем размер элементов, браузеру приходится перерисовывать страницу. Это трудоёмкая операция, и лучше выполнять её как можно реже<span className="span hl-4">Используйте обработчик oninput с осторожностью.</span></p>
      <h3>Событие change</h3>
      <p>change срабатывает, когда состояние поля меняется. В случае с чекбоксами, оно срабатывает, когда меняется статус с невыбранного поля на выбранное и наоборот.</p>
      <pre>{`
element.addEventListener('change', function () {
  …
});
`}
      </pre>

      <h2>Фазы событий</h2>
      <p>Работать с событиями несложно: достаточно подписаться на нужное событие с помощью addEventListener и подготовить функцию обратного вызова с кодом. При наступлении события эта функция выполнится.</p>
      <p>При нажатии на кнопку событие click произойдёт почти на всех элементах. Порядок того, на каком элементе оно произойдёт первым, зависит от фазы события. В настоящее время в стандарте закреплено три фазы: захват, целевое событие и всплытие. Фаза целевого события, как правило, не используется.</p>
      <p>Порядок фаз: захват, событие на элементе (испускание, отправка, dispatch), всплытие (если возможно)</p>

      <h3>Фаза захвата</h3>
      <p>Другие названия: погружение, перехват, capturing. На этой фазе, когда пользователь нажмёт на кнопку, событие произойдёт сначала на body, затем на form, и только потом оно опустится до button.</p>
      <p>Отследить это можно, навесив обработчики одного и того же события (например, click) на каждый из тегов и добавив к ним вывод console.log() или alert — код, позволяющий идентифицировать элемент. В этом случае на стадии захвата сначала выведется последовательно результат обработчика на body, следом form, и в конце button.</p>

      <h3>Фаза всплытия</h3>
      <p>Вторая фаза называется всплытие (bubbling). Это та самая фаза, которая используется по умолчанию в addEventListener и в устаревшем способе добавления обработчика через.onclick.</p>
      <p>Здесь наступление событий работает с точностью наоборот. Когда пользователь кликает по кнопке, сначала отработает обработчик на самой кнопке, затем на её первом родителе form и только потом дойдёт очередь до body. После этого (вне примера), событие поднимется до html, document, а в некоторых случаях и window.</p>
      <p>Важно запомнить: захват произойдёт в любом случае, а всплытие только если возможно. Всплытие возможно для почти всех событий, кроме focus/onfocus, blur, mouseleave, mouseenter.</p>


      <h2>Делегирование событий</h2>
      <p>Делегирование событий — это подход, который сокращает количество однотипных обработчиков в коде.</p>
      <p>Вместо добавления одинаковых обработчиков на каждый элемент списка, добавим один обработчик на родительском элементе, то есть родителю делегируется (поручается) обработка событий его дочерних элементов:</p>
      <pre>{`<ul> <!-- onListClick() -->
  <li>...</li>
  <li>...</li>
  <li>...</li>
  <li>...</li>
  <li>...</li>
</ul>
// script.js
const onListClick = function (evt) {
  if (evt.target.nodeName === 'LI') {
    // Действия
  }
}`}
      </pre>
      <p>Как это работает: В момент клика на элементе li, ссылка на него записывается в свойство target интерфейса Event, Начинается стадия всплытия, Всплытие доходит и срабатывает на ul. Обработчик проверяет, является ли evt.target элементом списка и выполняет код.</p>
      <p></p>
      <p></p>
      <pre>{``}
      </pre>

      <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#examples" target="_blank" rel="noopener noreferrer">HTMLElement: input event</a></p>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/beforeinput_event" target="_blank" rel="noopener noreferrer">HTMLElement: beforeinput event</a></p>
    </section>
  );
}
export default Events;
