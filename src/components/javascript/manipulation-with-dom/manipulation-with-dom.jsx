import React from 'react';

function ManipulationWithDOM() {

  return (
    <section className="conspect">
      <h1>Работа с Document Object Model</h1>

      <h2>Живые и неживые коллекции в JavaScript</h2>
      <p>Есть несколько способов, чтобы найти сразу несколько элементов на странице - querySelectorAll, getElementsByTagName, children и так далее - разные методы возвращают разные коллекции. Элементы записываются в структуру или сущность, которая называется коллекцией. Коллекцию можно сохранить в переменной. Коллекция — сущность, которая похожа на массив объектов, но при этом им не является, на самом деле это набор DOM-элементов. При этом к элементам коллекции можно обращаться по индексу и перебирать в цикле for, как и обычные массивы.</p>
      <p>В консоли коллекция выглядит как список, в котором элементы перечислены через запятую. Весь список обёрнут в квадратные скобки, а у элементов указан только их тег и, например, класс:</p>
      <pre>{`[p.card__text, p, p]
<p class="card__text">Готовим мороженое!</p>
<p>Санкт-Петербург</p>
<p>mail@htmlacademy.ru</p> `}
      </pre>
      <p>Типы коллекций:</p>
      <ul>
        <li>HTMLCollection — коллекция непосредственно HTML-элементов.</li>
        <li>NodeList — коллекция узлов, более абстрактное понятие. Например, в DOM-дереве есть не только узлы-элементы, но также текстовые узлы, узлы-комментарии и другие, поэтому NodeList может содержать другие типы узлов.</li>
      </ul>
      <p>Способы получения коллекций:</p>
      <ul>
        <li>
          <p><span className="hl-3">element.querySelectorAll()</span> — возвращает все элементы, которые подходят под указанное правило. DOM-коллекция, полученная через querySelectorAll похожа на массив, но им не является. Поэтому ещё одно название таких коллекций — псевдомассив. Эта запись остаётся статичной и изменения в DOM на неё никак не влияют.  Можно сказать, что querySelectorAll работает, как любая переменная, в которую мы записали какое-нибудь значение. Пока мы не переопределим переменную, в ней так и будет находиться то значение, которое мы в неё записали, независимо от того, что происходит в коде. Поэтому такая коллекция называется статичной (или не живой).</p>
          <p>В консоли рядом с коллекцией выводится NodeList - это тип этой коллекции, такой тип возвращает querySelectorAll и ряд других методов. Особенность такой коллекции в том, что она может содержать не только DOM-элементы вроде li или div, но и перенос строки, текстовое содержимое элементов в качестве отдельных элементов коллекции. NodeList может быть статичной или динамической, это зависит от того, каким способом она вызвана.</p></li>
        <li>
          <p><span className="hl-3">parentElement.children</span> — вызывается на родительском элементе и собирает все дочерние элементы в динамическую коллекцию типа HTMLCollection. Такие коллекции реагируют на изменения в DOM. Если один из элементов коллекции будет удалён из DOM, то он пропадёт и из коллекции.</p>
          <p>Такая коллекция содержит только DOM-элементы. Текстовое содержимое или переносы строк не могут попасть в неё в виде отдельных элементов. <span className="hl-3">Все HTMLCollection живые в отличие от NodeList.</span></p>
        </li>
        <li>getElementsByTagName(tag) — находит все элементы с заданным тегом,</li>
        <li>getElementsByClassName(className) — находит все элементы с заданным классом,</li>
        <li>getElementsByName(name) — находит все элементы с заданным атрибутом name.</li>
      </ul>
      <p>Последние три метода возвращают живые коллекции. Они используются реже, потому что в большинстве случаев удобнее применять querySelectorAll, но могут встречаться в старом коде.</p>
      <p>Для решения большинства задач можно ограничиться неживыми коллекциями. Но если нужно сохранить ссылку на реальное состояние DOM — понадобится живая коллекция. Это удобно в тех случаях, когда программе нужно постоянно манипулировать списком элементов, которые могут регулярно удаляться и добавляться. Хороший пример — задачи в системе учёта задач. С помощью живой коллекции можно хранить именно те задачи, которые фактически существуют в данный момент времени.</p>
      <p>Структура и некоторые свойства коллекции имеют много общего с массивом. Например, у неё тоже есть свойство length, и элементы коллекции можно перебирать в цикле for...of, потому что это перечисляемая сущность. Но, как упоминалось ранее, коллекции не во всём похожи на обычные массивы. С коллекциями не работают такие методы массивов, как push, splice и другие. Для их использования нужно преобразовать коллекцию в массив — например, с помощью метода Array.from:</p>
      <pre>{`const booksList = document.querySelector(`.books`);
const books = booksList.children;

// Выведет обычный массив с элементами из коллекции books
console.log(Array.from(books));
`}
      </pre>
      <p>При этом нужно помнить — массив статичен, поэтому при таком преобразовании теряются преимущества живых коллекций.</p>

      <h2>DOM и разметка</h2>
      <p>Любое изменение, которое мы вносим в DOM, не является изменением разметки сайта. DOM может изменяться путём воздействия на него через JavaScript; либо же пользователем, путём взаимодействия с интерфейсом.</p>
      <p>Рассмотрим на примере: допустим, у нас на странице есть форма с двумя флажками, один из которых заранее отмечен. Допустим, пользователь снял отметку с первого чекбокса и поставил во втором. При сохранении или отправке формы мы хотим узнать значение чекбокса, который отметил пользователь, для этого мы можем попробовать использовать следующий код, для того, чтобы найти чекбокс с нужным именем и атрибутом checked:</p>
      <pre>{'document.querySelector(`input[name="someCheckbox"][checked]`).value;'}
      </pre>
      <p>Однако, это неверно — когда пользователь взаимодействует с разметкой, используя элементы управления, то он изменяет DOM. То же самое мы можем делать из JavaScript. А в селекторе, который используется в коде выше, идёт привязка к разметке, и в данной ситуации такой селектор вернёт первое поле ввода, так как только у первого поля ввода в разметке присутствует атрибут checked. Чтобы такого не происходило, мы можем использовать псевдоклассы (как в CSS):</p>
      <pre>{'document.querySelector(`input[name="someCheckbox"]:checked`).value;'}</pre>
      <p>Тогда селектор найдёт поле ввода, которое выбрано на данный момент.</p>
      <p>Помните, что любая манипуляция с DOM не меняет разметку. В этом плане ввести в заблуждение могут инструменты разработчика. Если проинспектировать страницу, то во вкладке «Elements» можно увидеть, казалось бы, разметку. Однако на самом деле это DOM, просто браузер помогает нам смотреть на DOM, как на разметку. Чтобы увидеть разметку, нужно из контекстного меню на странице выбрать пункт «View Page Source».</p>
      <p>Разметка для DOM — это начальное состояние, то есть то состояние, которое появляется после загрузки страницы. После этого в ход вступают пользователь, JavaScript, какие-либо сторонние библиотеки, и DOM может измениться и уже не соответствовать разметке.</p>

      <h2>Шаблоны и данные</h2>
      <p>Шаблон — некоторая оболочка для данных, разметка, любой способ отобразить информацию. Шаблон никогда не несёт содержательной информации.</p>
      <p>Данные — информация, которую вводит пользователь, присылает сервер или которая может быть сгенерирована компьютером.</p>
      <p>Данные не должны повторять шаблон, они должны описывать параметры сущностей, которыми мы оперируем. Простой способ отделить шаблон от данных — попробовать изменить одно или другое.</p>
      <p>Например, использовать иной способ отображения данных (отобразить товары в линейку вместо списка) или изменить отображаемую информацию (описать не утюг, а пылесос). Допустим, у нас есть структура, описывающая логотип:</p>
      <pre>{`const header = {
    logo: {
        src: 'logo.png',
        width: 100,
        height: 30
    }
};
`}
      </pre>
      <p>С первого взгляда можно подумать, что это данные, однако, такую информацию неправильно хранить как данные. Эта информация описывает логотип, расположенный в шапке, она не приходит с сервера, не вводится пользователем, возможно, эта информация никогда не поменяется. Поэтому данная информация не является данными — это шаблон, который описывает, как некоторая сущность должна выглядеть. Данными могут быть: название компании, адрес, телефон и тому подобное.</p>
      <p>Дизайнер говорит нам, что в интерфейсе мы должны для некоторых пользователей показывать товары списком, а для других (кто хочет) сеткой. Неужели нам придётся заводить два одинаковых списка продуктов? Нет! Как раз список продуктов, приведённый выше, является данными, а способы показа товаров являются шаблоном.</p>
      <p>Данные не должны меняться в зависимости от того, каким образом они должны отображаться. Шаблон отвечает за то, куда вставить данные — в элемент списка или элемент сетки.</p>

      <h3>Создание DOM элементов</h3>
      <p>В условиях использования JavaScript DOM-элемент является шаблоном. DOM-элементы можно создать несколькими способами:</p>
      <ul>
        <li>На основе разметки — в специальные места разметки в тексте разметки подставляются данные;</li>
        <li>На основе строк;</li>
        <li>Компилируемые шаблоны — использование сторонних библиотек, способных переводить некоторый язык в разметку;</li>
        <li>На основе DOM-API:
          <ul>
            <li>На основе шаблонного элемента (template из WebComponents);</li>
            <li>С помощью обёрток над шаблонами (Incremental DOM).</li>
          </ul>
        </li>
      </ul>
      <p>Простой способ отделить шаблон от данных — попробовать заменить их: изменить способ отображения данных или отображаемую информацию.</p>

      <h2>Работа с элементами</h2>

      <h3>querySelector</h3>
      <p>Этот метод принимает CSS-селектор и возвращает первый подходящий элемент. Он понимает любые CSS-селекторы:</p>
      <pre>{`document.querySelector('селектор');

// Поиск элемента по тегу
var list = document.querySelector('ul');

// Поиск последнего элемента из списка
var lastProduct = document.querySelector('li:last-child');

// Поиск элемента по классу
var price = document.querySelector('.price');

// Поиск третьего элемента из списка товаров
var thirdProduct = document.querySelector('.product:nth-child(3)');
`}
      </pre>
      <p>Эта инструкция состоит из двух частей. Первая часть — элемент, внутри которого будет искать JavaScript. Словом document обозначается веб-страница, к которой скрипт подключён. Неважно, как называется файл на самом деле, в JavaScript это всегда «документ». Он является элементом-родителем для любого другого элемента на странице.</p>
      <p>Вторая часть инструкции — это то, что нужно сделать. Её называют <span className="hl-5">методом</span>.</p>
      <p>Обратите внимание, что дочерние элементы не обязательно искать в document:</p>
      <pre>{`
const userDialog = document.querySelector('.setup');
const similarListElement = userDialog.querySelector('.setup-similar-list');
`}
      </pre>
      <p className="hl-4">Если найден родитель элемента, избыточно запускать поиск по всему документу. Это ресурсоёмкая операция, потому что документ может быть очень большим.</p>

      <h2>Методы</h2>

      <h3>Метод createElement, создание элемента</h3>
      <p>Метод принимает на вход строку с именем тега и возвращает созданный DOM-элемент. Этот элемент можно записать в переменную для дальнейших манипуляций.</p>
      <p>Обратите внимание, что createElement — метод именно объекта document. То есть с его помощью мы создаём какой-то элемент для этого документа, пока не указывая, где он будет находиться в DOM.</p>
      <pre>{'document.createElement(имя тега);'}</pre>
      <p>Новый элемент будет доступен из скрипта, но в разметке не появится, пока мы не скажем JavaScript, где разместить новый элемент. Для этого можно использовать метод append.</p>

      <h2>Data-атрибуты</h2>
      <p>В HTML можно создавать свои собственные атрибуты. Имена таких атрибутов начинаются с префикса data-, после которого идёт любое выбранное разработчиком слово.</p>
      <pre>{'<div data-menu-item="Nemesida">'}</pre>
      <p>Чтобы получить значение data-атрибута в JavaScript, используют свойство dataset, после которого указывают имя атрибута без префикса data-:</p>
      <pre>{'элемент.dataset.menuItem'}</pre>
      <p>Если имя атрибута состояло из нескольких слов и в нём были дефисы, то в JavaScript его записывают в «верблюжьем» стиле (по-английски camelCase): дефисы убирают, а каждое слово, кроме первого, пишут с большой буквы.</p>
      <pre>{`let element = document.querySelector('div');
console.log(element.dataset.catName); // Выведет: Кекс`}
      </pre>

      <h3>Удаление элемента</h3>
      <p>Удалять элементы со страницы можно разными способами, один из самых простых — вызов метода remove на элементе, который нужно удалить.</p>
      <pre>{'element.remove();'}</pre>

      <h3>Метод append, appendChild()</h3>
      <p>элемент-родитель.append(добавляемый-элемент);</p>
      <p>Метод append добавляет указанный в скобках элемент в конец элемента-родителя. При этом содержимое элемента-родителя не затирается.</p>
      <p>C помощью этого метода можно и элементы, и простые строки. Метод append не копирует элементы, а перемещает.</p>
      <p>Если указать в скобках элемент, который уже есть в разметке, этот элемент исчезнет со своего прежнего места и появится там, куда его добавил метод append. Получить таким образом несколько элементов не выйдет.</p>
      <p>В коде вы обнаружите обращение к дочернему элементу шаблона через element.children[0].</p>
      <p>Сравнительно недавно в стандарте появились методы, которые позволяют вставить что угодно и куда угодно:</p>
      <ul>
        <li>node.append(...nodes) – вставляет nodes в конец node,</li>
        <li>node.prepend(...nodes) – вставляет nodes в начало node,</li>
        <li>node.after(...nodes) – вставляет nodes после узла node,</li>
        <li>node.before(...nodes) – вставляет nodes перед узлом node,</li>
        <li>node.replaceWith(...nodes) – вставляет nodes вместо node.</li>
      </ul>
      <p>Мы не можем вставить один элемент несколько раз в разные места страницы. Мы же не можем быть в нескольких местах одновременно? Вот и элементы DOM не могут.</p>
      <pre>{`// Находим элемент-родитель
let parent = document.querySelector('.parent');

// Добавляем новый элемент на страницу
parent.append(newElement);


var list = document.querySelector('.cards');
var card = document.createElement('li');
card.classList.add('card');

// После вызова этого метода новый элемент отрисуется на странице
list.appendChild(card);
`}
      </pre>
      <p>Последовательность добавления элемента в DOM может быть другой: можно создать элемент с помощью createElement и сразу вставить его в родительский элемент, а уже затем добавлять классы. Но это не лучший путь — каждое изменение в DOM вызывает перерисовку страницы, а это дорогая операция, она занимает много времени.</p>

      <h3>Клонирование элемента</h3>
      <p>Для это нужно использовать метод cloneNode. Он возвращает склонированный элемент.</p>
      <pre>{`element.cloneNode(true);
// Вернёт склонированный элемент со всеми вложенностями

element.cloneNode(false);
// Вернёт склонированный элемент без вложенностей

element.cloneNode();
// 0_o`}
      </pre>
      <p>При передаче true в качестве аргумента клонируется сам элемент вместе со всеми вложенностями. Причём клонируются атрибуты, классы и текстовое содержимое всех вложенностей. Такое клонирование называется глубоким.</p>
      <p>Если передать методу в качестве аргумента значение false, то будет скопирован сам элемент со своими классами и атрибутами, но без дочерних элементов.</p>
      <div className="note">Лучше всегда явно передавать аргумент в cloneNode, чтобы избежать ошибок в работе программ.</div>

      <h3>Как получить текст из поля ввода</h3>
      <p>Нужно обратиться к свойству поля ввода value. Оно хранит информацию, введённую в поле. Результат можно сохранить в переменную и использовать дальше в коде.</p>
      <pre>{'input.value;'}</pre>

      <h2>Шаблоны и тег &lt;template&gt;</h2>
      <p>Тег template хранит в себе шаблон для будущих элементов. Он там же, где и вся разметка сайта, только его содержимое не отображается на странице.</p>
      <p>Обычно каждому тегу template дают уникальное название и записывают в атрибут id (идентификатор). Значения этого атрибута не могут повторяться на одной странице. По id можно найти необходимый шаблон.</p>
      <p>Шаблон в разметке:</p>
      <pre>{`<body>
  …
  <template id="text-template">
    <p class="text"></p>
  </template>
</body>`}
      </pre>

      <h3>Контент тега &lt;template&gt;, document-fragment</h3>
      <p>Внутри <span className="hl-7">template</span> находится document-fragment или просто фрагмент. Он является хранилищем содержимого тега <span className="hl-5">template</span>. Именно благодаря ему разметка из template не отображается на странице.</p>
      <p>Чтобы получить необходимые элементы в шаблоне, надо обратиться к <span className="hl-6">document-fragment</span>, он находится в свойстве <span className="hl-8">content</span> и дальше искать нужные элементы привычными методами поиска.</p>
      <p>Если искать элементы через querySelector и другие методы поиска внутри template, то мы не получим нужные нам элементы. Они лежат в свойстве content этого тега. Это свойство и содержит document-fragment, внутри которого уже можно искать привычными методами поиска.</p>
      <p>Если мы хотим найти элемент в шаблоне, надо искать так:</p>
      <pre>{`const template = document.querySelector('#text-template');
// Нашли template в документе

const content = template.content;
// Получили содержимое, фрагмент

const text = content.querySelector('.text');
// Нашли нужный шаблон
Эту запись можно сократить.
Например, записать в отдельную переменную контент, а в другую искомый шаблон.

const textTemplate = document.querySelector('#text-template').content;
const text = textTemplate.querySelector('.text');`}
      </pre>
      <p>Эту запись можно сократить. Например, записать в отдельную переменную контент, а в другую искомый шаблон.</p>
      <pre>{`const textTemplate = document.querySelector('#text-template').content;
const text = textTemplate.querySelector('.text');`}
      </pre>
      <p>Такая запись удобней, потому что отдельно в коде элемент template обычно не используют. Вся работа ведётся с его контентом и шаблоном, который в этом контенте хранится.</p>
      <p>В шаблоне можно менять текст, классы, а затем добавлять элементы на страницу. Это мы сделаем в следующих шагах. А пока найдём content и внутри него элемент с классом item, который является шаблоном новой задачи.</p>
      <div className="note">Есть ещё один метод в DOM API, который позволяет искать элементы по идентификатору — getElementById. В отличие от других методов он может быть вызван только на всём документе, а не отдельном элементе.</div>

      <h2>Методы для изменения классов - объект classList</h2>
      <p>Так как DOM-элементы — объекты, все они имеют набор свойств и методов. Среди свойств DOM-элементов — объект classList. Он содержит методы для управления классами DOM-элемента</p>
      <p>Синтаксис простой. Сначала мы указываем DOM-элемент, которому хотим добавить класс, затем обращаемся к свойству classList через точку и вызываем метод add(), передав ему строку с необходимым классом.</p>
      <p className="hl-2">Кстати, обратите внимание, мы ставим точку, когда ищем элемент по селектору, но не ставим её при удалении или добавлении класса. Это правило важно запомнить. Чтобы было легче, можно помнить о том, что названия classList.remove и classList.add говорят сами за себя. Мы что-то делаем с классом элемента, поэтому нам надо передать только строку с названием класса. А искать элемент через querySelector можно разными способами. Мы говорили об этом раньше. Поэтому мы ставим точку перед названием класса, чтобы явно указать, что мы ищем именно по классу, а не тегу или как-то иначе.:</p>
      <pre>{`
// Когда ищем элемент по классу, используем точку
var product = document.querySelector('.product');

// Но когда добавляем класс, точки нет!
product.classList.add('product--sale');
`}
      </pre>

      <h3>Метод classList.contains, проверяем наличие класса</h3>
      <p>элемент.classList.contains(&apos;класс&apos;);</p>
      <p>Метод вернёт true (истина), если класс у элемента есть, и false (ложь), если класса нет.</p>

      <h3>Метод classList.remove</h3>
      <p>Убирает с элемента тот класс, который указан в скобках:</p>
      <pre>{`
элемент.classList.remove('класс');

var popup = document.querySelector('.popup');
// Перед названием селектора ставим точку

popup.classList.remove('popup--open');
// Перед названием класса точка не ставится
Результат в разметке такой же, как при удалении класса вручную.

<!-- Исходное состояние разметки -->
<section className="popup popup--open">
…
</section>

<!-- Состояние после вызова classList.remove -->
<section className="popup">
…
</section>
`}
      </pre>

      <h3>Метод classList.add</h3>
      <p>Чтобы добавить элементу класс, нужно использовать метод classList.add:</p>
      <pre>{`
элемент.classList.add('класс');`}
      </pre>
      Метод-переключатель classList.toggle убирает у элемента указанный класс, если он есть, и добавляет, если этого класса нет:
      <pre>{`
элемент.classList.toggle('класс');`}
      </pre>

      <a href="examples/ice-cream-shop/index.html" target="blank">Посмотреть пример работы методов</a>

      <h2>Методы padStart() и padEnd()</h2>
      <p>JavaScript метод padStart() позволяет дополнить текущую строку, начиная с её начала (слева) с помощью пробельного символа (по умолчанию), или заданной строкой, таким образом чтобы результирующая строка достигла заданной длины.</p>
      <p>Если Вам необходимо дополнить текущую строку, начиная с её конца (справа), то Вы можете воспользоваться методом padEnd().</p>
      <pre>{`// дополнить текущую строку пробельными символами до заданной длины
string.padStart( targetLength );

// дополнить текущую строку переданными символами до заданной длины
string.padStart( targetLength, padString  ); `}
      </pre>
      <dl>
        <dt>targetLength</dt><dd>Целое число, которое определяет длину текущей строки после того как она будет заполнена. Если значение отсутствует, или меньше длины текущей строки, то текущая строка будет возвращена с той же длиной (останется без изменений).</dd>
        <dt>padString</dt><dd>Определяет строковое значение, которым будет дополнена текущая строка. При необходимости заданная строка может быть повторена с целью достижения заданной длины для текущей строки, или усечена, если заданная длина строки была достигнута ранее. Значение по умолчанию для этого параметра - &quot; &quot; (U+0020).</dd>
      </dl>
      <p>Подготовить и вывести на консоль значения из массива, выравнивая при этом длину строки конкретного элемента для удобного просмотра и чтения выведенной информации:</p>
      <pre>{`let array = ["147.13", "20.11", "40.99", "13.06", "255", "189"];
let outputValues = array.map( val => parseFloat( val ).toFixed( 2 ).padStart( 10 ).padEnd( 14, " RUR"));

console.log( outputValues.join( "\n") );

// результат вывода будет следующим:

  147.13 RUR
   20.11 RUR
   40.99 RUR
   13.06 RUR
  255.00 RUR
  189.00 RUR`}
      </pre>

      <h3>String.prototype.trim()</h3>
      <p>Метод trim() удаляет пробельные символы с начала и конца строки. Пробельными символами в этом контексте считаются все собственно пробельные символы (пробел, табуляция, неразрывный пробел и прочие) и все символы конца строки (LF, CR и прочие).</p>
      <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank" rel="noopener noreferrer">String.prototype.trim() MDN</a></p>

      <h2>Надо запрограммировать приложение — список дел.</h2>
      <ul>
        <li>задача считается выполненной и исчезает, если юзер кликнул по чекбоксу;</li>
        <li>если все задачи выполнены, появляется сообщение, что больше задач нет;</li>
        <li>если в пустой список добавляется новая задача, сообщение исчезает;</li>
        <li>чтобы добавить новую задачу, надо ввести описание в поле ввода и нажать «Добавить задачу», задача появится в конце списка.</li>
      </ul>
      <p>Найдём список и каждую задачу в списке с помощью querySelector и querySelectorAll. Каждая задача состоит из текста и поля с типом checkbox.</p>
      <p>Мы могли бы добавлять событие клика на всю задачу, на весь элемент &lt;li&gt;, но это решение не оптимальное. Пользователь может случайно кликнуть по задаче, не желая её закрывать.</p>
      <p>Поэтому сначала найдём чекбокс внутри каждой задачи, навесим обработчик. У нас много элементов, будем использовать функцию.</p>
      <p>Кстати, почему мы использовали именно функцию, а не добавили обработчик на элемент прямо внутри цикла? Всё дело в областях видимости. Мы уже говорили про замыкания, когда делали галерею в этой главе про события. Если бы мы навесили обработчик внутри цикла, наша программа работала бы некорректно, потому что удалялся бы только последний элемент коллекции элементов.</p>
      <p>Если задачи будут удалены, то и длина коллекции будет равна 0. И тогда можно показать сообщение.</p>
      <p>Для добавления задачи можно ловить клики по этой кнопке, но универсальней будет использовать специальное событие submit. Оно срабатывает всегда при отправке формы. Это событие универсально потому, что иногда форму можно отправить не только кликом по кнопке, но и нажатием какой-то клавиши. Например, «Enter».</p>
      <p>Отправка формы — действие формы по умолчанию, которое нам нужно отменить. Для этого будем использовать evt.preventDefault().</p>
      <p>Запустим цикл, в теле цикла будем клонировать шаблон, менять содержимое дочернего элемента и последовательно вставлять копии на страницу.</p>
      <p>Мы уже нашли шаблон задачи и записали его в переменную newItemTemplate. Попробуем склонировать этот шаблон и записать копию в новую переменную. Выведем копию в консоль, чтобы убедиться, что копирование сработало. Будем использовать глубокое клонирование, чтобы сохранить все элементы в структуре задачи.</p>
      <p>Чтобы задача удалялись, надо повесить обработчик на чекбокс. При изменении статуса чекбокса будем удалять задачу из списка… Ничего не напоминает? Мы уже писали этот код, он есть в функции addCheckHandler. Мы передавали в эту функцию те элементы списка, которые уже были на странице. Теперь у нас есть новый элемент, который до этого не существовал, и его тоже надо передать в эту функцию, чтобы добавить обработчик.</p>
      <p>Мы будем передавать task в функцию addCheckHandler до того, как будем добавлять этот элемент на страницу. Тогда в списке будет появляться элемент с обработчиком и всем необходимым функционалом. Мы как будто сначала настраиваем элемент, а уже затем добавляем его на страницу.</p>
      <p>Осталась пара мелочей. Нужно прятать сообщение, если задачи в списке появились. Для этого добавим ветку else в функцию toggleEmptyListMessage. В ней будем добавлять класс hidden абзацу с сообщением. Будем вызывать эту функцию сразу после того, как задача добавилась в список.</p>
      <p>Ещё будем удалять текст из поля ввода после того, как задача добавилась на страницу. Это маленький, но приятный элемент для пользователей — не нужно каждый раз перед добавлением новой задачи удалять текст руками.</p>
      <p><a href="examples/list-of-tasks/index.html" target="_blank" rel="nofollow noopener noreferrer">Программа: «Список дел»</a></p>
      <p><a href="examples/messenger/index.html" target="_blank" rel="nofollow noopener noreferrer">Программа: «Мессенджер»</a></p>
      <p><a href="#">Result (Likes counter)</a></p>
    </section>
  );
}
export default ManipulationWithDOM;
