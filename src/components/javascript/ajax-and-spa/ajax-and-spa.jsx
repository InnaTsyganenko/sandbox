import React from 'react';

function AjaxAndSPA() {

  return (
    <section className="conspect">
      <h1>Ajax — Async, Callback &amp; Promise</h1>
      <p>Ajax (Asynchronous Javascript And XML) - это основа приложения Javascript. Он широко используется с SPA (одностраничным приложением). Он используется для связи с сервером.</p>
      <p>Он был создан в 2005 году, когда XML был основным форматом обмена данными между сервером и клиентом. В 2015 году JSON стал основным форматом обмена данными. AJAX используется для связи между клиентом и сервером</p>
      <p>Чтобы полностью понять ajax, нам необходимо понять <span className="hl-6">асинхронную природу javascript</span> и то, как работать с асинхронным программированием.</p>
      <p>Асинхронность в Javascript - это два действия, при которых одно действие запускает другое действие, которое будет завершено в будущем.</p>
      <p>Например, регистрация для события щелчка и ожидание щелчка пользователем и / или выполнение вызова сервера для получения некоторых данных. Это похоже на то, что нам нужно обработать что-то, чего у нас нет сразу, поэтому мы ждем, пока это завершится, и как только это будет сделано, мы его обрабатываем.</p>
      <p>Пример асинхронной операции:</p>
      <pre>{`Timer Example :

function showSessionExpire(){
  console.log("Your session expired");
}
setTimeout(showSessionExpire, 1000);
console.log("showSessionExpire will execute after 1000 ms");

Выведет:
VM18:5 showSessionExpire will execute after 1000 ms
undefined
VM18:2 Your session expired`}
      </pre>
      <pre>{`File Reader Example :

var reader = new FileReader();

reader.onload = function(e) {
  var text = reader.result;
}

reader.readAsText(file, encoding);`}
      </pre>

      <h2>Callback</h2>
      <p>При написании асинхронного кода мы используем функции обратного вызова. Почему? Асинхронные операции выполняются не сразу. Чтобы выполнить какое-то действие после завершения асинхронной операции, в JavaScript применяют функции обратного вызова или, проще говоря, — колбэки. Это утверждение вы неоднократно успели проверить на практике. Идея функций обратного вызова предельно проста, но с ними легко зарулить на шоссе «ад колбэков».</p>

      <h3>Ад колбэк-функций (callback hell)</h3>
      <p>За примером далеко ходить не надо. Простая задача: требуется запросить с сервера несколько наборов данных: получить список пользователей, затем их публикации, и в конце концов комментарии к этим публикациям. Три запроса, каждый из которых должен быть выполнен после предыдущего. Для большей визуализации посмотрим на абстрактный пример кода:</p>
      <pre>{`getUsers((error, users) => {

// Обрабатываем список пользователей
// и запрашиваем их публикации
getPosts(users, (error, posts) => {

   // Обрабатываем публикации пользователей
   // и запрашиваем к ним комменты
  getComments(posts, (error, comments) => {

      // Обрабатываем комментарии
      // Здесь может быть что-то ещё…
 });
});
});`}
      </pre>
      <p>В этом примере три асинхронных операции. Каждая из них принимает два параметра: данные (результат работы предыдущей функции) и функцию обратного вызова. Параметр error хранит информацию об ошибке. Функция будет выполнена после завершения асинхронной операции. Уже сейчас, глядя на этот код, становится немного не по себе: он превращается в лесенку. Обратите внимание, мы только определили цепочку вызовов асинхронных операций. В настоящем приложении между вызовами этих функций может находится дополнительный код, а асинхронных операций быть значительно больше. В этом и заключается ад колбэков: «лестница» продолжит расти при добавлении асинхронных операций. Поддержка кода усложнится или станет вовсе нереальной.</p>
      <p>Что такое обратный вызов: - Допустим, у нас есть функция F1, которая вызывает F2. F2 выполняет некоторую асинхронную операцию, такую как AJAX. F1 хотел бы узнать результат вызова ajax. Теперь F1 передаст другую функцию, скажем C1, в качестве дополнительного параметра для F2, который F2 вызовет после того, как полностью обработает запрос ajax.</p>
      <p>Подумайте об этом, как будто F1 получает услугу от F2, предоставляя детали услуги вместе с C1. Когда F2 завершает обслуживание, он информирует F1, вызывая C1 с некоторыми дополнительными данными.</p>
      <p>Зачем нам нужен callback: потому что мы не хотим дублировать код ajax каждый раз, когда нам нужно. Мы хотим создать общую функцию ajax, которая принимает данные ajax в качестве входных данных вместе со ссылкой на обратный вызов. После завершения вызова он вызывает обратный вызов, чтобы вызывающий мог продолжить работу с результатом вызова ajax.</p>
      <p>Мы можем использовать служебную функцию ajax в n местах, передав такие сведения о вызове ajax, как URL-адрес, метод и ссылку на обратный вызов. Обратные вызовы - отличный способ отделить основную логику ajax от остальной части приложения. Но, к сожалению, становится очень сложно обрабатывать обратный вызов, когда мы выполняем серию вызовов ajax, когда один вызов зависит от предыдущего вызова. Мы можем столкнуться с трудностями при поддержании нескольких ссылок обратного вызова и обработке нескольких состояний успеха и ошибок. Promise - лучший способ управлять несколькими вызовами ajax. Давайте теперь исследуем Promise.</p>

      <h3>Иллюстрация проблемы</h3>
      <p>Давайте возьмём какой-нибудь код с колбэками и попробуем его переписать с использованием промисов. Начнём с абстрактных примеров: напишем простейшую программу для приготовления супа:</p>
      <pre>{`const TIMEOUT = 1000;

const makeSoup = () => {
  console.log('> Иду за продуктами');
  const products = ['Капуста', 'Картофель', 'Мясо'];
  setTimeout(() => {
    console.log('> Нарезаю продукты: {products.join(', ')}');
    setTimeout(() => {
      console.log('> Продукты нарезаны!');
      setTimeout(() => {
        console.log('> Начинаю варить суп из: {products.join(', ')}');
        setTimeout(() => {
          return Math.random() > 0.5
            ? console.log('> Суп готов!')
            : console.log('> Упс! Сломалась плита.');
        }, TIMEOUT);
      }, TIMEOUT);
    }, TIMEOUT);
  }, TIMEOUT);
};

makeSoup();`}
      </pre>
      <p>В этом коде визуализируется асинхронный процесс приготовления супа. Все асинхронные операции имитируются при помощи setTimeout. Попробуйте скопировать этот код и выполнить его в REPL (например, в консоли браузера) несколько раз.</p>
      <p>Наигравшись с кодом, посмотрите на него ещё раз более придирчивым взглядом. Что в нём не нравится? Пожалуй, ответ очевиден: лестница колбэк-функций. Можно попытаться порефакторить этот код и немного «замазать» проблему. Однако, корень зла останется и обязательно проявит себя чуть позже.</p>
      <p>Попробуем решить эту же задачу при помощи промисов. Не будем углубляться в теорию, а сразу применим промисы на практике. Детали работы с ними разберём чуть позже. Сейчас важно увидеть их в действии. Попробуйте выполнить ниже приведённый фрагмент кода:</p>
      <pre>{`const TIMEOUT = 1000;

const buyProducts = () => {
  console.log('> Иду за продуктами...');
  return new Promise((resolve) => {
    setTimeout(() => {
      const products = ['Картофель', 'Капуста', 'Мясо'];
      resolve(products);
    }, TIMEOUT);
  });
};

const prepareProducts = (products) => {
  console.log('> Нарезаю продукты: {products.join(', ')}');
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log('> Продукты нарезаны!');
      resolve(products);
    }, TIMEOUT);
  });
};

const makeSoup = (preparedProducts) => {
  console.log('> Начинаю варить суп из: {preparedProducts.join(', ')}');
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      return Math.random() > 0.5
        ? resolve('> Суп готов!')
        : reject('> Упс! Сломалась плита.');
    }, TIMEOUT);
  });
};

buyProducts()
  .then(prepareProducts)
  .then(makeSoup)
  .then((result) => console.log(result))
  .catch((error) => console.log(error));`}
      </pre>
      <p>Визуально кода получилось больше, но пока не это главное. Ответьте на вопрос: лучше ли он читается? Все действия по приготовлению супа мы вынесли в отдельные функции (пока не будем вдаваться в подробности их содержимого). Название каждой функции соответствует выполняемому действию: купить продукты, нарезать ингредиенты, сварить суп.</p>
      <p>Обратите внимание на порядок вызова функций. Он стал прозрачным и последовательным. Вызываем первую функцию (buyProducts), а затем prepareProducts, makeSoup и так далее. Глядя на этот код, мы можем легко определить последовательность действий. Мы построили цепочку вызовов промисов. Пока непонятно, как она работает, но уже выглядит заманчиво и проще, чем лесенка из колбэков.</p>

      <h2>Promise</h2>
      <p>Поддержка промисов появилась в ECMAScript 2015. Промисы позволяют организовать асинхронный код по-другому. Сделать его более плоским и последовательным, похожим на синхронный код.</p>
      <p>Промис — это специальный объект (Promise). Он позволяет отследить выполнение асинхронной операции и сохранить её результат. Сами асинхронные операции выполняются как и прежде: не сразу, а когда-нибудь. Поэтому важно запомнить и уяснить, промисы — это не «магическая» замена асинхронных операций и не возможность получить результат такой операции сразу. Это просто объект, позволяющий более эффективно работать с асинхронным кодом.</p>

      <h3>Синтаксис</h3>
      <p>В JavaScript для работы с промисами есть специальный объект Promise. Он впервые появился в ECMAScript 2015, но это не значит, что до этого времени никто не знал о промисах. На самом деле, идея промисов не новая. До появления нативной поддержки применялись сторонние библиотеки. Синтаксис отличался, но основная концепция была неизменна — предоставить объект, который будет знать о завершении асинхронной операции. Promise используется для решения проблем с множественными обратными вызовами и обеспечивает лучший способ управления успешными и ошибочными состояниями. Promise вначале выглядит немного сложным, но с ним очень просто и эффективно справиться. Обещание - это объект, который возвращается асинхронной функцией, такой как ajax.</p>
      <p>Чтобы воспользоваться промисами необходимо создать экземпляр встроенного объекта Promise. В этом нам поможет оператор new:</p>
      <pre>{'const myPromise = new Promise(<executor>);'}</pre>
      <p>Конструктор объекта Promise в качестве единственного параметра принимает функцию. Эту функцию принято называть «функция-исполнитель» (executor), и она принимает два параметра. Оба параметра — колбэки:</p>
      <ul>
        <li>resolve — функция, которая будет выполнена, если промис разрешён (асинхронная операция выполнилась успешно);</li>
        <li>reject — функция, которая будет выполнена, если промис отклонён (асинхронная операция не выполнилась или завершилась с ошибкой);</li>
      </ul>
      <p>Для большей наглядности посмотрим на интерфейс функции-исполнителя:</p>
      <pre>{'function (resolve, reject) {}'}</pre>
      <p>Само собой вместо обычной function мы можем использовать стрелочные функции. Параметры функции — это не что иное, как самые обычные колбэки.</p>
      <p>Теперь важная информация: функция-исполнитель (executor) выполняется сразу. Это может быть неочевидным на первый взгляд. Убедимся на простом примере:</p>
      <pre>{`const myPromise = new Promise((resolve, reject) => {
  console.log('Привет! Я функция-исполнитель.');

  // Другой код
});`}
      </pre>
      <p>В этом примере мы создаём экземпляр объекта Promise и в качестве параметра передаём функцию. Эта функция принимает в свою очередь два параметра, а в теле функции описан вывод в консоль. Попробуйте выполнить этот код. Сразу увидите вывод сообщения «Привет! Я функция-исполнитель». Функция исполнитель выполнилась сразу, автоматически.</p>
      <p>Теперь самый главный вопрос: где писать код асинхронной операции? Это следует делать внутри функции-исполнителя. Поскольку она вызывается сразу, асинхронный код встанет в очередь на выполнение и останется только дождаться, когда завершится операция. Вспомним пример с приготовлением супа:</p>
      <pre>{`const makeSoup = (preparedProducts) => {
  console.log('> Начинаю варить суп из: {preparedProducts.join(', ')}');
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      return Math.random() > 0.5
        ? resolve('> Суп готов!')
        : reject('> Упс! Сломалась плита.');
    }, TIMEOUT);
  });
};`}
      </pre>
      <p>Внутри функции-исполнителя мы описываем ту самую асинхронную операцию. В нашем случае мы реализуем её с помощью setTimeout. Асинхронная операция заключается в выполнении бессмысленного действия: получить случайное число и, если оно больше 0.5, то суп готов и об этом следует сообщить. А если меньше, то всё пропало. Считаем, что сломалась плита, и сообщаем о неудаче.</p>
      <p>А что мы подразумеваем под словом «сообщить»? Вызов соответствующего колбэка. Посмотрим на параметры для функции-исполнителя. Их два: resolve и reject. Оба параметра ожидают функции, то есть колбэки. Выше мы отмечали: resolve должен быть вызван в случае успешного выполнения асинхронной операции, а reject если пошло что-то не так. Параметры reject и resolve называются так неслучайно.</p>
      <p>Промис обладает состоянием, и оно изменяется во время жизни объекта. Одновременно промис может быть только в одном из трёх состояний:</p>
      <ul>
        <li>pending (ожидание);</li>
        <li>fulfilled (выполнен успешно/разрешён);</li>
        <li>rejected (отклонён).</li>
      </ul>
      <p>Жизненный цикл промиса начинается с состояния pending (ожидание). В это состояние промис переходит сразу после создания экземпляра объекта. Это вполне логично, ведь асинхронная операция не может быть выполнена прямо сейчас.</p>
      <p>Дальше всё зависит от результата выполнения асинхронной операции. Если она выполняется успешно, то мы вызываем колбэк resolve и его вызов переведёт объект промиса в состояние fulfilled (выполнен/разрешён). Ну, а если мы выполним колбэк reject, то промис перейдёт в состояние rejected (отклонён).</p>
      <p>Сейчас может показаться, что в теле колбэков мы должны написать какой-то код, который явно будет менять состояние промиса, но это не так. Состояние меняется автоматически в зависимости от вызываемого колбэка. Выполняем колбэк, переданный в первом параметре — подразумеваем успех (fulfilled). Во втором — ошибка (reject). Состояние промиса меняется автоматически.</p>
      <p>Теперь важная деталь. Промисы не позволяют откатится на предыдущее состояние. Такой возможности не существует. Например, если мы вызвали resolve, переведя тем самым промис в состояние fulfilled, то даже если сразу выполнить reject, то состояние промиса не изменится. Справедливо и обратное: после выполнения reject, вызов resolve не приведёт к изменению состояния промиса. Рассмотрим на примере:</p>
      <pre>{`const myPromise = new Promise((resolve, reject) => {
  resolve('success');
  // Инструкция выполнится, но не повлияет на состояние промиса
  reject('error');
});`}
      </pre>
      <p>Внутри функции-исполнителя мы сначала вызываем resolve, то есть переводим промис в состояние «fulfilled», а затем пытаемся перевести в «rejected». Выполнение этого кода не приведёт к ошибке, но состояние промиса не изменится. Раз мы перевели промис в состояние fulfilled, то обратного пути нет.</p>
      <p>Есть две части, использующие объект обещания. Внутри асинхронной функции (Часть 1) и где она вызывается (Часть 2).</p>
      <p>Часть 1 - Внутри функции Async,</p>
      <p>Объект обещания создан.</p>
      <p>Асинхронная функция возвращает объект обещания</p>
      <p>Если асинхронное выполнение выполнено успешно, объект обещания разрешается путем вызова его метода разрешения.</p>
      <p>Если async выполняется с ошибкой, объект обещания отклоняется путем вызова его отклоненного метода.</p>
      <p>Часть 2 - Внешняя функция Async</p>
      <p>Вызвать функцию и получить объект обещания</p>
      <p>Прикрепите обработчик успеха, обработчик ошибок к объекту обещания, используя метод then</p>

      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>

      <h2>Междоменный вызов</h2>
      <p>У AJAX есть ограничение, заключающееся в том, что по умолчанию он не может отправлять запросы AJAX на междоменный сервер.</p>
      <p>В приведенном выше примере мы используем API, предоставленный api.github.com, и jsfiddle для выполнения нашего кода пользовательского интерфейса. Здесь наш код javascript живет на сервере jsFiddle и пытается получить данные с сервера github. Это кросс-домен.</p>
      <p>По умолчанию AJAX не может выполнять перекрестный вызов домена, браузер отклоняет вызовы в другой домен. Есть два варианта совершения междоменного звонка.</p>
      <p>Использование CORS</p>
      <p>Использование JSONP</p>
      <p>Оба варианта требуют некоторых изменений сервера. Это невозможно сделать только с помощью javascript.</p>
      <p>CORS - это новый способ обработки запросов AJAX с перекрестным происхождением. github api включены CORS. Чтобы включить CORS, ответ должен содержать заголовок Access-Control-Allow-Origin со значением домена или * для работы всех. Github использует *</p>
      <p>JSONP также можно использовать, если CORS не может быть включен сервером или для старых браузеров. JSONP фактически использует тег скрипта для получения данных с сервера. Скрипт может быть получен из любого домена, поэтому в JSONP нам нужно создать скрипт с URL-адресом как src, а сервер должен заключить ответ в функцию обратного вызова. Ответ, отправленный сервером, на самом деле является кодом javascript, который содержит данные внутри функции-оболочки. В JSONP не выполняется вызов ajax.</p>
    </section>
  );
}
export default AjaxAndSPA;
