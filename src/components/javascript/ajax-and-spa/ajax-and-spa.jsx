import React from 'react';

function AjaxAndSPA() {

  return (
    <section className="conspect">
      <h1>Ajax — Async, Callback &amp; Promise</h1>
      <p>Ajax (Asynchronous Javascript And XML) - это основа приложения Javascript. Он широко используется с SPA (одностраничным приложением). Он используется для связи с сервером.</p>
      <p>Он был создан в 2005 году, когда XML был основным форматом обмена данными между сервером и клиентом. В 2015 году JSON стал основным форматом обмена данными. AJAX используется для связи между клиентом и сервером</p>
      <p>Чтобы полностью понять ajax, нам необходимо понять <span className="hl-6">асинхронную природу javascript</span> и то, как работать с асинхронным программированием.</p>
      <p>Асинхронность в Javascript - это два действия, при которых одно действие запускает другое действие, которое будет завершено в будущем.</p>
      <p>Например, регистрация для события щелчка и ожидание щелчка пользователем и / или выполнение вызова сервера для получения некоторых данных. Это похоже на то, что нам нужно обработать что-то, чего у нас нет сразу, поэтому мы ждем, пока это завершится, и как только это будет сделано, мы его обрабатываем.</p>
      <p>Пример асинхронной операции:</p>
      <pre>{`Timer Example :

function showSessionExpire(){
  console.log("Your session expired");
}
setTimeout(showSessionExpire, 1000);
console.log("showSessionExpire will execute after 1000 ms");

Выведет:
VM18:5 showSessionExpire will execute after 1000 ms
undefined
VM18:2 Your session expired`}
      </pre>
      <pre>{`File Reader Example :

var reader = new FileReader();

reader.onload = function(e) {
  var text = reader.result;
}

reader.readAsText(file, encoding);`}
      </pre>

      <h2>Callback</h2>
      <p>При написании асинхронного кода мы используем функции обратного вызова. Почему? Асинхронные операции выполняются не сразу. Чтобы выполнить какое-то действие после завершения асинхронной операции, в JavaScript применяют функции обратного вызова или, проще говоря, — колбэки. Это утверждение вы неоднократно успели проверить на практике. Идея функций обратного вызова предельно проста, но с ними легко зарулить на шоссе «ад колбэков».</p>

      <h3>Ад колбэк-функций (callback hell)</h3>
      <p>За примером далеко ходить не надо. Простая задача: требуется запросить с сервера несколько наборов данных: получить список пользователей, затем их публикации, и в конце концов комментарии к этим публикациям. Три запроса, каждый из которых должен быть выполнен после предыдущего. Для большей визуализации посмотрим на абстрактный пример кода:</p>
      <pre>{`getUsers((error, users) => {

// Обрабатываем список пользователей
// и запрашиваем их публикации
getPosts(users, (error, posts) => {

   // Обрабатываем публикации пользователей
   // и запрашиваем к ним комменты
  getComments(posts, (error, comments) => {

      // Обрабатываем комментарии
      // Здесь может быть что-то ещё…
 });
});
});`}
      </pre>
      <p>В этом примере три асинхронных операции. Каждая из них принимает два параметра: данные (результат работы предыдущей функции) и функцию обратного вызова. Параметр error хранит информацию об ошибке. Функция будет выполнена после завершения асинхронной операции. Уже сейчас, глядя на этот код, становится немного не по себе: он превращается в лесенку. Обратите внимание, мы только определили цепочку вызовов асинхронных операций. В настоящем приложении между вызовами этих функций может находится дополнительный код, а асинхронных операций быть значительно больше. В этом и заключается ад колбэков: «лестница» продолжит расти при добавлении асинхронных операций. Поддержка кода усложнится или станет вовсе нереальной.</p>
      <p>Что такое обратный вызов: - Допустим, у нас есть функция F1, которая вызывает F2. F2 выполняет некоторую асинхронную операцию, такую как AJAX. F1 хотел бы узнать результат вызова ajax. Теперь F1 передаст другую функцию, скажем C1, в качестве дополнительного параметра для F2, который F2 вызовет после того, как полностью обработает запрос ajax.</p>
      <p>Подумайте об этом, как будто F1 получает услугу от F2, предоставляя детали услуги вместе с C1. Когда F2 завершает обслуживание, он информирует F1, вызывая C1 с некоторыми дополнительными данными.</p>
      <p>Зачем нам нужен callback: потому что мы не хотим дублировать код ajax каждый раз, когда нам нужно. Мы хотим создать общую функцию ajax, которая принимает данные ajax в качестве входных данных вместе со ссылкой на обратный вызов. После завершения вызова он вызывает обратный вызов, чтобы вызывающий мог продолжить работу с результатом вызова ajax.</p>
      <p>Мы можем использовать служебную функцию ajax в n местах, передав такие сведения о вызове ajax, как URL-адрес, метод и ссылку на обратный вызов. Обратные вызовы - отличный способ отделить основную логику ajax от остальной части приложения. Но, к сожалению, становится очень сложно обрабатывать обратный вызов, когда мы выполняем серию вызовов ajax, когда один вызов зависит от предыдущего вызова. Мы можем столкнуться с трудностями при поддержании нескольких ссылок обратного вызова и обработке нескольких состояний успеха и ошибок. Promise - лучший способ управлять несколькими вызовами ajax. Давайте теперь исследуем Promise.</p>

      <h3>Иллюстрация проблемы</h3>
      <p>Давайте возьмём какой-нибудь код с колбэками и попробуем его переписать с использованием промисов. Начнём с абстрактных примеров: напишем простейшую программу для приготовления супа:</p>
      <pre>{`const TIMEOUT = 1000;

const makeSoup = () => {
  console.log('> Иду за продуктами');
  const products = ['Капуста', 'Картофель', 'Мясо'];
  setTimeout(() => {
    console.log('> Нарезаю продукты: {products.join(', ')}');
    setTimeout(() => {
      console.log('> Продукты нарезаны!');
      setTimeout(() => {
        console.log('> Начинаю варить суп из: {products.join(', ')}');
        setTimeout(() => {
          return Math.random() > 0.5
            ? console.log('> Суп готов!')
            : console.log('> Упс! Сломалась плита.');
        }, TIMEOUT);
      }, TIMEOUT);
    }, TIMEOUT);
  }, TIMEOUT);
};

makeSoup();`}
      </pre>
      <p>В этом коде визуализируется асинхронный процесс приготовления супа. Все асинхронные операции имитируются при помощи setTimeout. Попробуйте скопировать этот код и выполнить его в REPL (например, в консоли браузера) несколько раз.</p>
      <p>Наигравшись с кодом, посмотрите на него ещё раз более придирчивым взглядом. Что в нём не нравится? Пожалуй, ответ очевиден: лестница колбэк-функций. Можно попытаться порефакторить этот код и немного «замазать» проблему. Однако, корень зла останется и обязательно проявит себя чуть позже.</p>
      <p>Попробуем решить эту же задачу при помощи промисов. Не будем углубляться в теорию, а сразу применим промисы на практике. Детали работы с ними разберём чуть позже. Сейчас важно увидеть их в действии. Попробуйте выполнить ниже приведённый фрагмент кода:</p>
      <pre>{`const TIMEOUT = 1000;

const buyProducts = () => {
  console.log('> Иду за продуктами...');
  return new Promise((resolve) => {
    setTimeout(() => {
      const products = ['Картофель', 'Капуста', 'Мясо'];
      resolve(products);
    }, TIMEOUT);
  });
};

const prepareProducts = (products) => {
  console.log('> Нарезаю продукты: {products.join(', ')}');
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log('> Продукты нарезаны!');
      resolve(products);
    }, TIMEOUT);
  });
};

const makeSoup = (preparedProducts) => {
  console.log('> Начинаю варить суп из: {preparedProducts.join(', ')}');
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      return Math.random() > 0.5
        ? resolve('> Суп готов!')
        : reject('> Упс! Сломалась плита.');
    }, TIMEOUT);
  });
};

buyProducts()
  .then(prepareProducts)
  .then(makeSoup)
  .then((result) => console.log(result))
  .catch((error) => console.log(error));`}
      </pre>
      <p>Визуально кода получилось больше, но пока не это главное. Ответьте на вопрос: лучше ли он читается? Все действия по приготовлению супа мы вынесли в отдельные функции (пока не будем вдаваться в подробности их содержимого). Название каждой функции соответствует выполняемому действию: купить продукты, нарезать ингредиенты, сварить суп.</p>
      <p>Обратите внимание на порядок вызова функций. Он стал прозрачным и последовательным. Вызываем первую функцию (buyProducts), а затем prepareProducts, makeSoup и так далее. Глядя на этот код, мы можем легко определить последовательность действий. Мы построили цепочку вызовов промисов. Пока непонятно, как она работает, но уже выглядит заманчиво и проще, чем лесенка из колбэков.</p>

      <h2>Promise</h2>
      <p>Поддержка промисов появилась в ECMAScript 2015. Промисы позволяют организовать асинхронный код по-другому. Сделать его более плоским и последовательным, похожим на синхронный код.</p>
      <p>Промис — это специальный объект (Promise). Он позволяет отследить выполнение асинхронной операции и сохранить её результат. Сами асинхронные операции выполняются как и прежде: не сразу, а когда-нибудь. Поэтому важно запомнить и уяснить, промисы — это не «магическая» замена асинхронных операций и не возможность получить результат такой операции сразу. Это просто объект, позволяющий более эффективно работать с асинхронным кодом.</p>

      <h3>Синтаксис</h3>
      <p>В JavaScript для работы с промисами есть специальный объект Promise. Он впервые появился в ECMAScript 2015, но это не значит, что до этого времени никто не знал о промисах. На самом деле, идея промисов не новая. До появления нативной поддержки применялись сторонние библиотеки. Синтаксис отличался, но основная концепция была неизменна — предоставить объект, который будет знать о завершении асинхронной операции. Promise используется для решения проблем с множественными обратными вызовами и обеспечивает лучший способ управления успешными и ошибочными состояниями. Promise вначале выглядит немного сложным, но с ним очень просто и эффективно справиться. Обещание - это объект, который возвращается асинхронной функцией, такой как ajax.</p>
      <p>Чтобы воспользоваться промисами необходимо создать экземпляр встроенного объекта Promise. В этом нам поможет оператор new:</p>
      <pre>{'const myPromise = new Promise(<executor>);'}</pre>
      <p>Конструктор объекта Promise в качестве единственного параметра принимает функцию. Эту функцию принято называть «функция-исполнитель» (executor), и она принимает два параметра. Оба параметра — колбэки:</p>
      <ul>
        <li>resolve — функция, которая будет выполнена, если промис разрешён (асинхронная операция выполнилась успешно);</li>
        <li>reject — функция, которая будет выполнена, если промис отклонён (асинхронная операция не выполнилась или завершилась с ошибкой);</li>
      </ul>
      <p>Для большей наглядности посмотрим на интерфейс функции-исполнителя:</p>
      <pre>{'function (resolve, reject) {}'}</pre>
      <p>Само собой вместо обычной function мы можем использовать стрелочные функции. Параметры функции — это не что иное, как самые обычные колбэки.</p>
      <p>Теперь важная информация: функция-исполнитель (executor) выполняется сразу. Это может быть неочевидным на первый взгляд. Убедимся на простом примере:</p>
      <pre>{`const myPromise = new Promise((resolve, reject) => {
  console.log('Привет! Я функция-исполнитель.');

  // Другой код
});`}
      </pre>
      <p>В этом примере мы создаём экземпляр объекта Promise и в качестве параметра передаём функцию. Эта функция принимает в свою очередь два параметра, а в теле функции описан вывод в консоль. Попробуйте выполнить этот код. Сразу увидите вывод сообщения «Привет! Я функция-исполнитель». Функция исполнитель выполнилась сразу, автоматически.</p>
      <p>Теперь самый главный вопрос: где писать код асинхронной операции? Это следует делать внутри функции-исполнителя. Поскольку она вызывается сразу, асинхронный код встанет в очередь на выполнение и останется только дождаться, когда завершится операция. Вспомним пример с приготовлением супа:</p>
      <pre>{`const makeSoup = (preparedProducts) => {
  console.log('> Начинаю варить суп из: {preparedProducts.join(', ')}');
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      return Math.random() > 0.5
        ? resolve('> Суп готов!')
        : reject('> Упс! Сломалась плита.');
    }, TIMEOUT);
  });
};`}
      </pre>
      <p>Внутри функции-исполнителя мы описываем ту самую асинхронную операцию. В нашем случае мы реализуем её с помощью setTimeout. Асинхронная операция заключается в выполнении бессмысленного действия: получить случайное число и, если оно больше 0.5, то суп готов и об этом следует сообщить. А если меньше, то всё пропало. Считаем, что сломалась плита, и сообщаем о неудаче.</p>
      <p>А что мы подразумеваем под словом «сообщить»? Вызов соответствующего колбэка. Посмотрим на параметры для функции-исполнителя. Их два: resolve и reject. Оба параметра ожидают функции, то есть колбэки. Выше мы отмечали: resolve должен быть вызван в случае успешного выполнения асинхронной операции, а reject если пошло что-то не так. Параметры reject и resolve называются так неслучайно.</p>
      <p>Промис обладает состоянием, и оно изменяется во время жизни объекта. Одновременно промис может быть только в одном из трёх состояний:</p>
      <ul>
        <li>pending (ожидание);</li>
        <li>fulfilled (выполнен успешно/разрешён);</li>
        <li>rejected (отклонён).</li>
      </ul>
      <p>Жизненный цикл промиса начинается с состояния pending (ожидание). В это состояние промис переходит сразу после создания экземпляра объекта. Это вполне логично, ведь асинхронная операция не может быть выполнена прямо сейчас.</p>
      <p>Дальше всё зависит от результата выполнения асинхронной операции. Если она выполняется успешно, то мы вызываем колбэк resolve и его вызов переведёт объект промиса в состояние fulfilled (выполнен/разрешён). Ну, а если мы выполним колбэк reject, то промис перейдёт в состояние rejected (отклонён).</p>
      <p>Сейчас может показаться, что в теле колбэков мы должны написать какой-то код, который явно будет менять состояние промиса, но это не так. Состояние меняется автоматически в зависимости от вызываемого колбэка. Выполняем колбэк, переданный в первом параметре — подразумеваем успех (fulfilled). Во втором — ошибка (reject). Состояние промиса меняется автоматически.</p>
      <p>Теперь важная деталь. Промисы не позволяют откатится на предыдущее состояние. Такой возможности не существует. Например, если мы вызвали resolve, переведя тем самым промис в состояние fulfilled, то даже если сразу выполнить reject, то состояние промиса не изменится. Справедливо и обратное: после выполнения reject, вызов resolve не приведёт к изменению состояния промиса. Рассмотрим на примере:</p>
      <pre>{`const myPromise = new Promise((resolve, reject) => {
  resolve('success');
  // Инструкция выполнится, но не повлияет на состояние промиса
  reject('error');
});`}
      </pre>
      <p>Внутри функции-исполнителя мы сначала вызываем resolve, то есть переводим промис в состояние «fulfilled», а затем пытаемся перевести в «rejected». Выполнение этого кода не приведёт к ошибке, но состояние промиса не изменится. Раз мы перевели промис в состояние fulfilled, то обратного пути нет.</p>
      <p>Есть две части, использующие объект обещания. Внутри асинхронной функции (Часть 1) и где она вызывается (Часть 2).</p>
      <p>Часть 1 - Внутри функции Async,</p>
      <p>Объект обещания создан.</p>
      <p>Асинхронная функция возвращает объект обещания</p>
      <p>Если асинхронное выполнение выполнено успешно, объект обещания разрешается путем вызова его метода разрешения.</p>
      <p>Если async выполняется с ошибкой, объект обещания отклоняется путем вызова его отклоненного метода.</p>
      <p>Часть 2 - Внешняя функция Async</p>
      <p>Вызвать функцию и получить объект обещания</p>
      <p>Прикрепите обработчик успеха, обработчик ошибок к объекту обещания, используя метод then</p>

      <h3>Цепочки промисов</h3>
      <p>Следующим шагом разберёмся, как использовать объект промис и получить результат выполнения асинхронной операции. Вернёмся к примеру с приготовлением супа и рассмотрим вот этот кусочек кода:</p>
      <pre>{`const TIMEOUT = 1000;

const buyProducts = () => {
  console.log('> Иду за продуктами...');
  return new Promise((resolve) => {
    setTimeout(() => {
      const products = ['Картофель', 'Капуста', 'Мясо'];
      resolve(products);
    }, TIMEOUT);
  });
};`}
      </pre>
      <p>Задача функции buyProducts — приобрести продукты для приготовления супа. Поскольку операция асинхронная, мы воспользовались промисами. Отчётливо видно, что результатом выполнения функции buyProducts станет новый экземпляр объекта Promise. Если посмотреть на функцию-исполнитель (напомним, мы передаём её при создании объекта Promise), то видно, что список продуктов будет передан в качестве параметра при вызове колбэка resolve. Запомните это.</p>
      <p>Обратите также внимание, что при описании функции-исполнитель мы не описали параметр reject. Это не является ошибкой. Просто для задачи «купить продукты» не предусмотрен негативный сценарий.</p>
      <p>Теперь попробуем получить результат выполнения асинхронной операции. Для этого мы воспользуемся методом then у экземпляра объекта Promise. Метод позволяет определить функцию, которая выполняется при переходе промиса в состояние fulfilled (выполнен успешно). Именно с этой функцией мы работаем внутри функции-исполнителя через параметр resolve. Давайте посмотрим, как это выглядит в коде:</p>
      <pre>{`// Функция 'buyProducts' вернёт новый Promise
const buyProductPromise = buyProducts();

// Передаём функцию для 'resolve'
buyProductPromise.then((products) => console.log('Купили продукты: {products.join(', ')}'));`}
      </pre>
      <p>Первым делом мы получаем результат выполнения buyProducts. Она вернёт новый промис. Мы сохраним его в переменную buyProductPromise. На самом деле, отдельную переменную создавать необязательно. Можно сразу обращаться к методу then: buyProducts().then(...). Мы делаем это для повышения наглядности, чтобы зафиксировать, что результатом функции будет экземпляр объекта Promise.</p>
      <p>Затем применяем метод then. Это своего рода мостик к функции-исполнителю, которую мы определили при создании экземпляра объекта Promise. Метод then в первом параметре принимает функцию, которая должна быть выполнена при переходе промиса в состояние fulfilled. То есть эта функция станет значением колбэка resolve. Говоря другими словами, в первый параметр then мы передаём функцию для параметра resolve. Остановитесь на этом месте и прочтите абзац ещё раз.</p>
      <p>Никакой магии: мы определяем колбэк, который будет вызван после завершения асинхронной операции. При определении колбэка мы предусматриваем параметр products. Через него мы получим список приобретённых продуктов. Как они в него попадут? Ответ кроется в месте вызова колбэка resolve. Обратите внимание, при вызове resolve мы передаём в качестве параметра данные о товарах.</p>

      <h3>Обработка ошибок</h3>
      <p>Интерфейс функции-исполнителя предусматривает два параметра: resolve и reject. Давайте посмотрим, как можно обработать ситуацию, когда в асинхронной операции возникла какая-то ошибка и промис перешёл в состояние rejected, то есть был вызван колбэк reject.</p>
      <p>Решить эту задачу можно двумя способами. Первый вам уже знаком: воспользоваться методом then. В первом параметре он принимает колбэк, который будет вызван в случае перехода промиса в fulfilled. А во втором, колбэк, который будет вызван при переходе в reject. Немного модифицируем функцию buyProducts — добавим поддержку негативного сценария.</p>
      <pre>{`const TIMEOUT = 1000;

const buyProducts = () => {
  console.log('> Иду за продуктами...');
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const products = ['Картофель', 'Капуста', 'Мясо'];
      return Math.random() > 0.5
        ? resolve(products)
        : reject('> Упс! В магазине нет нужных товаров');
    }, TIMEOUT);
  });
};

buyProducts().then(
    (products) => console.log(products),
    (error) => console.log(error)
);`}
      </pre>
      <p>Внутри функции-исполнителя мы добавили дополнительное условие: в зависимости от случайного значения будем вызывать либо resolve(), либо reject(). Обратите внимание на описание метода then. В первом параметре передаём функцию для resolve, а во втором для reject. Принцип определения такой функции точно такой же. Попробуй несколько раз выполнить этот код. В одних случаях результатом будет вызов resolve, а в другом reject.</p>

      <h4>catch</h4>
      <p>Второй способ обработки перехода промиса в состояние rejected заключается в использовании метода catch у промиса. В качестве параметра ему необходимо передать колбэк для reject. Рассмотрим на примере:</p>
      <pre>{`// Код функции 'buyProducts' остался без изменений
buyProducts()
    .then((products) => console.log(products))
    .catch((error) => console.log(error));`}
      </pre>
      <p>В этом примере использования промиса, определение функции для reject переехало из второго параметра then в catch. Остальной код остался прежним.</p>
      <p>А какой способ выбрать? Чаще всего удобней использовать catch, чтобы не загромождать метод then. Вторая причина выбора в пользу catch: обработка ошибок в цепочках промисов.</p>
      <p>Мы рассмотрели общий принцип работы с промисами и теперь готовы познакомиться с важной функцией: построением цепочек. Начнём с основ. В прошлом разделе мы воспользовались методами then и catch, но не обсудили одну деталь: а что является результатом вызова этих методов?</p>
      <p>Методы then и catch всегда возвращают новый промис. За счёт этого мы можем строить цепочки вызовов промисов. Собственно немного с этим мы уже познакомились, когда применяли метод catch. Это стало возможным благодаря тому, что then вернул новый промис.</p>
      <p>А зачем нам может пригодиться эта возможность? Для последовательного выполнения операций. Вспомните пример с приготовлением супа. Он включает несколько действий (купить продукты, подготовить их и так далее). Каждая следующая операция должна происходить после выполнения предыдущей. Вот тут нам и пригождаются цепочки:</p>
      <pre>{`buyProducts()
   // Мы можем описывать функции прямо на месте
   // или указать ссылку на существующую функцию.
   // Помните, это обычный колбэк
  .then(prepareProducts)
  .then(makeSoup)
  // Для последнего действия готовой функции нет,
  // поэтому описываем её прям здесь.
  .then((result) => console.log(result))
  .catch((error) => console.log(error));`}
      </pre>
      <p>Давайте проговорим, как выполняется приведённый фрагмент кода. Метод then вернёт новый промис. Мы вызываем then и определяем колбэк для resolve. Затем повторяем этот алгоритм для всех остальных действий. Для последней задачи (результат приготовления супа) у нас нет отдельной функции, поэтому мы описываем её на месте в виде анонимной функции.</p>
      <p>При построении цепочек из промисов мы получаем ещё одну крутую возможность — передачу результата выполнения промиса вниз по цепочке. Это означает, что в каждом последующем then мы можем получить результат выполнения колбэка предыдущего then. Посмотрим на примере:</p>
      <pre>{`new Promise((resolve) => resolve(1))
    .then((result) => result + 1) // 2
    .then((result) => result + 1) // 3
    .then((result) => console.log(result)); // 3`}
      </pre>
      <p>Каждый колбэк, который мы описываем для then возвращает результат увеличения значения, полученного в виде параметра на единицу. Этот результат передаётся вниз по цепочке. Таким образом, в конце мы получаем 3. Эту возможность можно сравнить с конвейерной лентой. На каждом шаге появляется возможность улучшить предыдущий результат.</p>
      <p>Наверняка вас интересует вопрос применения цепочек из промисов на практике. Подход применяется довольно часто. Возьмём задачу получения данных от сервера. Сначала мы должны их получить (например, в виде JSON строки), затем их десериализовать (распарсить), потом, возможно, нужно что-то в них добавить или преобразовать к другому формату и так далее. Это прекрасная задачка для применения цепочек.</p>
      <p>Обратите внимание на применение метода catch. Мы описываем его один раз в конце цепочки промисов. Как в этом случае будет происходить обработка ошибки? Если любой из вышестоящих промисов в цепочке будет отклонён (rejected), то мы попадём в catch и сможем обработать эту ситуацию. Стоит отметить, что выполнение цепочки на этом прекратится. Если ошибка произошла в первом then, то последующие выполнятся не будут, инициативу перехватит catch.</p>
      <p>Никто не запрещает нам описывать отдельный колбэк для обработки rejected. Мы знаем, что это можно сделать во втором параметре then или расставив дополнительные catch, но такая необходимость возникает не так часто. Возьмём пример с получением данных от сервера. Если мы не смогли получить данные, то смысла в выполнении операций, которые их используют — попросту нет.</p>

      <h3>Методы промисов</h3>
      <h4>resolve () и reject ()</h4>
      <p>В прошлом материале мы пользовались конструктором Promise для создания новых промисов. Это отличный вариант, но в некоторых ситуациях он многословен. Например, у нас есть функция, которая должна только возвращать промис в состоянии fulfilled (для построения цепочки). В этом случае создавать объект, описывать функцию-исполнитель немного многословно.</p>
      <p>К счастью, у объекта Promise есть два статических метода: resolve и reject. Первый, как и следует из названия позволяет сразу выполнить промис, а второй отклонить. Благодаря этим статическим методам, мы можем обойтись без громоздкой записи. Оба этих метода возвращают промис. Рассмотрим простой пример:</p>
      <pre>{`const getRemoteData = () => Promise.resolve('Данные загружены!');
const getBadData = () => Promise.reject('Произошла ошибка');

getRemoteData()
  .then((value) => console.log(value))
  .then(getBadData)
  .catch((error) => console.log(error));`}
      </pre>
      <p>В этом примере у нас есть две функции getRemoteData (не будем вдаваться в детали её предназначения) и getBadData. Мы знаем, что первая функция всегда будет выполнять промис, поэтому для сокращения кода можем воспользоваться методом resolve. Это равносильно, если мы написали бы:</p>
      <pre>{`return new Promise((resolve, reject) => {
  resolve('Данные загружены!');
});`}
      </pre>
      <p>Далеко не во всех случаях возникает необходимость отклонить промис, а раз так, то мы можем выразить это более лаконично. С отклонением промиса ситуация похожа. Для этого нам доступен статический метод reject. Его применение демонстрирует функция getBadData.</p>

      <h4>all ()</h4>
      <p>Другим не менее важным и полезным методом у объекта Promise является — all(). Метод принимает в качестве единственного параметра массив из промисов и возвращает новый промис, который будет выполнен, после выполнения всех промисов, переданных в метод all, или отклонён в случае отклонения одного из промисов той же коллекции.</p>
      <p>Метод all нам пригодится в ситуациях, когда требуется дождаться выполнения нескольких промисов. Например, нам требуется выполнить несколько асинхронных операций, а только потом начать работать с полученными данными. Чтобы было проще представить, рассмотрим эту задачу сразу на примере:</p>
      <pre>{`const TIMEOUT = 1000;

const makeThing = (number) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Это действие №{number}');
    }, TIMEOUT);
  });
};

const firstThing = makeThing(1);
const secondThing = makeThing(2);
const thirdThing = makeThing(3);

Promise
  .all([
    firstThing,
    secondThing,
    thirdThing
  ])
  .then((value) => console.log(value));`}
      </pre>
      <p>Функция makeThing делает бесполезную работу — принимает номер действия и формирует информационную строку, используя этот номер. Дальше мы определяем несколько действий — 1, 2, 3. Наша задача дождаться выполнения всех этих действий, а затем обработать результат.</p>
      <p>Метод all помогает решить эту задачу. В качестве параметра мы передаём массив из подготовленных промисов. Результатом будет новый промис, который в случае успешного выполнения позволит получить результат выполнения всех промисов. Таким образом, value будет содержать массив со значениями выполненных промисов.</p>
      <p>Обратите внимание на порядок значений в результирующем массиве. Он соответствует порядку переданных в метод all промисов.</p>

      <h4>race ()</h4>
      <p>У объекта Promise есть ещё один полезный метод — race. Дословно это слово можно перевести как «гонка». В отличие от метода all, он не будет ждать выполнения всех промисов, а дождётся выполнения первого. Здесь уже порядок промисов, передаваемых в качестве параметра, не имеет значения. Рассмотрим пример синтаксиса:</p>
      <pre>{`// Предыдущий код идентичен
Promise
  .race([
    thirdThing,
    firstThing,
    secondThing,
  ])
  .then((value) => console.log(value));`}
      </pre>

      <h2>Async/Await</h2>
      <p>В основе async/await лежат промисы. async/await — это синтаксический сахар для промисов, который делает ваш асинхронный код ещё более похожим на синхронный.</p>

      <h3>async</h3>
      <p>Начнём знакомиться с введения нового ключевого слова — async. Оно позволяет определить асинхронную функцию. Результатом выполнения такой функции будет новый промис. async вы можете использовать как при объявлении функций декларативно, так и для функций-выражений. Рассмотрим сразу несколько примеров:</p>
      <pre>{`async function foo() {
  // Применение async для функции объявленной декларативно
}

const boo = async () => {
  // Применение async для функции объявленной в виде выражения
}

console.log(foo()); // Promise
console.log(boo()); // Promise`}
      </pre>
      <p>Результатом выполнения двух функций станет новый промис. Мы всего лишь добавили одно ключевое слово и получили промис. Если применять промисы, то нам пришлось бы воспользоваться конструктором, либо выполнить resolve. Давайте попробуем немного улучшить пример и вернуть из async функции какое-нибудь значение. По традиции вернём фразу Hello, world, а затем сделаем вывод в консоль:</p>
      <pre>{`const foo = async () => 'Hello, world';

foo()
 .then((text) => console.log(text)); // Hello, world`}
      </pre>
      <p>Вы уже знаете, результатом выполнения async функции будет новый промис. Внутри функции возвращается строка Hello, world, как если бы воспользовались методом resolve. Дальше применяем уже знакомый метод then, передав ему колбэк-функцию.</p>
      <p>Рассмотренный пример — это ни что иное, как применение статического метода resolve у объекта Promise. Давайте посмотрим на вариант синтаксиса с промисами, чтобы проще было провести аналогию. Тоже самое:</p>
      <pre>{`const foo = () => Promise.resolve('Hello, world');

foo()
 .then((text) => console.log(text));`}
      </pre>

      <h3>await</h3>
      <p>Ключевое слово async избавляет от необходимости создавать и возвращать промисы. Эта операция выполняется автоматически. Теперь посмотрим на второе ключевое слово — await. Оператор позволяет дождаться окончания выполнения промиса.</p>
      <p>Важно сразу запомнить: ключевое слово await допускается использовать только внутри функции, объявленной с использованием ключевого слова async. Рассмотрим на примере получения списка публикаций:</p>
      <pre>{`const URL = 'https://jsonplaceholder.typicode.com/posts';

const getPosts = async () => {
  const response = await fetch(URL);
  const posts = await response.json();
  return posts;
};

(async () => {
    const posts = await getPosts()
    console.log('Список публикаций: ');
    console.log(posts);
})();`}
      </pre>
      <p>Обратите внимание, функция getPosts объявлена с использованием ключевого слова async, то есть результатом функции станет промис. В первой строке функции вызывается метод fetch. Он тоже возвращает промис, поэтому уже здесь можно применить оператор await.</p>
      <p>Затем полученные публикации мы парсим с помощью метода json(). Вновь применяем оператор await, а после этого возвращаем результат. Как работает fetch повторяться не будем — про него рассказали в отдельном разделе.</p>
      <p>Чтобы воспользоваться функцией getPosts, мы опять применяем await. Затем выводим список публикаций. Обратите внимание, сначала в консоль будет выведена фраза «Список публикаций», а только потом массив с публикациями.</p>
      <p>Для обработки ошибок нам потребуется воспользоваться операторами try/catch. Взгляните на пример:</p>
      <pre>{`// Специально объявим некорректный адрес
const URL = 'https://jsonplaceholder.typicode';

const getPosts = async () => {
  let response;
  try {
    response = await fetch(URL);
  } catch (error) {
    console.log(error);
    return [];
  }

  const posts = await response.json();
  return posts;
};

const posts = await getPosts();
console.log('Список публикаций: ');
console.log(posts);`}
      </pre>
      <p>Пример делает тоже самое, что и предыдущий, но в него мы добавили обработку ошибку с помощью блока try/catch. Чтобы воспроизвести ошибку мы специально указали некорректный адрес до сервиса. При выполнении метода fetch возникнет ошибка, которая будет перехвачена в блоке catch. Содержимое ошибки выводится в консоль, а затем из функции возвращается пустой массив. Попробуйте запустить этот код в консоли.</p>

      <h4>Promise.all и await</h4>
      <p>Мы уже знаем, что await помогает дождаться разрешения промиса, а как быть если требуется подождать несколько промисов? Из раздела «Методы промисов» мы знаем: для этой задачи у объекта Promise есть метод all. Он принимает массив промисов. Этот же метод может применяться совместно с await. Стоит помнить, что вызов должен происходить внутри async функции.</p>
      <p>Переработаем прошлый пример, чтобы нужно было одновременно загружать и посты, и комментарии:</p>
      <pre>{`const Url = {
    POST: 'https://jsonplaceholder.typicode.com/posts',
    COMMENT: 'https://jsonplaceholder.typicode.com/comments',
};

const getData = async (url) => {
    const response = await fetch(url);
    const posts = await response.json();
    return posts;
};

(async () => {
    const [posts, comments] = await Promise.all([getData(Url.POST), getData(Url.COMMENT)]);
    console.log('Список публикаций: ');
    console.log(posts);
    console.log('Список комментариев: ');
    console.log(comments);
})();`}
      </pre>
      <p></p>
      <p></p>
      <p></p>
      <pre>{``}
      </pre>

      <h2>Междоменный вызов</h2>
      <p>У AJAX есть ограничение, заключающееся в том, что по умолчанию он не может отправлять запросы AJAX на междоменный сервер.</p>
      <p>В приведенном выше примере мы используем API, предоставленный api.github.com, и jsfiddle для выполнения нашего кода пользовательского интерфейса. Здесь наш код javascript живет на сервере jsFiddle и пытается получить данные с сервера github. Это кросс-домен.</p>
      <p>По умолчанию AJAX не может выполнять перекрестный вызов домена, браузер отклоняет вызовы в другой домен. Есть два варианта совершения междоменного звонка.</p>
      <p>Использование CORS</p>
      <p>Использование JSONP</p>
      <p>Оба варианта требуют некоторых изменений сервера. Это невозможно сделать только с помощью javascript.</p>
      <p>CORS - это новый способ обработки запросов AJAX с перекрестным происхождением. github api включены CORS. Чтобы включить CORS, ответ должен содержать заголовок Access-Control-Allow-Origin со значением домена или * для работы всех. Github использует *</p>
      <p>JSONP также можно использовать, если CORS не может быть включен сервером или для старых браузеров. JSONP фактически использует тег скрипта для получения данных с сервера. Скрипт может быть получен из любого домена, поэтому в JSONP нам нужно создать скрипт с URL-адресом как src, а сервер должен заключить ответ в функцию обратного вызова. Ответ, отправленный сервером, на самом деле является кодом javascript, который содержит данные внутри функции-оболочки. В JSONP не выполняется вызов ajax.</p>

      <h2>JSON</h2>
      <p>JSON (JavaScript Object Notation) — открытый текстовый формат для обмена данными. Формат разработан Дугласом Крокфордом. JSON хорошо читается людьми и прекрасно решает задачу передачи объектов, основанных на наборе из пар ключ-значение. Подробные сведения о формате доступны в документе RFC 4627.</p>
      <p>Формат JSON берёт начало из JavaScript (вспомните аббревиатуру), но фактически не зависит от языка программирования. Это означает, что применять формат JSON можно и в других языках программирования. PHP, C#, Go, Python и многие другие языки программирования поддерживают JSON по умолчанию (нативно) или с помощью вспомогательных библиотек.</p>
      <p>За счёт универсальности, формат JSON упрощает обмен данными. Не важно, какие технологии используются на клиенте или сервере. Они смогут договориться за счёт универсального формата.</p>
      <p>JSON не единственный формат для обмена данными. Есть более сложные форматы. Например, XML. Этот формат долгое время был стандартом при обмене данными, но в итоге JSON вытеснил его из многих сценариев за счёт своей лаконичности.</p>

      <h3>Синтаксис</h3>
      <pre>{`{
    "first_name": "Ivan",
    "last_name": "Sidorov"
}`}
      </pre>
      <p>Внешне он похож на описание объекта в JavaScript с помощью литерала, но на самом деле это не объект. Обычная строка, которую без проблем можно передать куда угодно. Например, с клиента на сервер. Содержимое JSON — это коллекция из пар ключ/значение. Ключи определяются слева, а значение отделяется символом двоеточия (:). Синтаксически это выглядит так, как если описать обычный JavaScript-объект.</p>
      <p>Важная особенность, что ключи должны быть обрамлены в двойные кавычки. Пожалуй, это главное отличие от описания объектов в JavaScript, где кавычки необязательны при описании ключей. Если их не поставить в JSON, то он будет считаться невалидным и его не смогут разобрать парсеры.</p>

      <h3>Типы данных в JSON</h3>
      <p>В формате JSON вам доступны две структуры данных — коллекция из пар ключ/значение и упорядоченный список значений. Не пугайтесь слов «структура данных». Это понятие мы обязательно обсудим позже. Пока просто запомните, что в данном контексте под ним подразумеваются объекты (коллекция из пар ключ/значение) и массивы (упорядоченный список значений) из JavaScript.</p>
      <p>Значение в формате JSON может быть одним из шести типов: объект, строка, массив, число, булево и null. Других типов значений JSON содержать не может. Рассмотрим пример:</p>
      <pre>{`{
    "band": "Bon Jovi",
    "title": "Slippery when wet",
    "year": 1986,
    "tracks": [
        "Let it rock",
        "You give love a bad name",
        "Livin'on a prayer",
        "Social Disease"
    ],
    "members": [
        {
            "name": "Jon Bon Jovi",
            "role": "singer",
            "active": true
        },
        {
            "name": "Richie Sambora",
            "role": "guitar player",
            "active": false
        }
    ],
    "relatedGroups": null
}`}
      </pre>
      <p>Строковые значения должны быть взяты в двойные кавычки. Здесь мало, что отличается от JavaScript. Единственное — кавычки должны быть двойными. Числа (year), булевы значения (active) и значения null пишутся как есть. Без каких-либо символов.</p>
      <p>Обратите внимание: в примере используются вложенные структуры. Ключ members и tracks — это массивы значений. Внутри массива могут быть любые значения, поддерживаемые в JSON. Мы привели пример со строковыми значениями и объектами.</p>
      <p>Начинаться JSON документ не обязан с объекта (как в нашем примере). Может начинаться с массива.</p>
      <p>Для оптимизации отступы, лишние пробелы можно удалить. Таким образом, JSON превратится в длинную строку, но размер передаваемых данных сократится. Такой подход часто применяется на практике.</p>
      <p>К JSON предъявляется несколько требований. Мы уже про них говорили: допустимые типы данных, двойные кавычки для строк, отсутствие висящих запятых (помните об этом, это одна из самых частых ошибок) и так далее. Чтобы убедиться, что подготовленный JSON-документ валиден, есть специальные сервисы, расширения для редакторов и пакеты в NPM.</p>
      <p>Для экспериментов можем порекомендовать сервис JSON Formatter & Validator. Он позволяет не только проверить JSON на корректность, но и отформатировать его — привести в читабельный вид.</p>

      <h3>Из JSON и обратно</h3>
      <p>Для работы с JSON в JavaScript есть одноимённый встроенный объект JSON. Он предоставляет два метода: stringify (для получения JSON строки, соответствующей переданному значению) и parse (для разбора JSON строки и получению значения).</p>
      <p>Все перечисленные примеры вы сможете повторить, воспользовавшись консолью в инструментах разработчиков. Сначала рассмотрим конвертацию JSON-строки в объект. В качестве тестовых данных воспользуемся ранее приведённым примером:</p>
      <pre>{`const albumJSON = {
    "band": "Bon Jovi",
    "title": "Slippery when wet",
    "year": 1986,
    "tracks": [
        "Let it rock",
        "You give love a bad name",
        "Livin'on a prayer",
        "Social Disease"
    ]
};

// Преобразуем JSON объект в объект
const albumObject = JSON.parse(albumJSON);

// Получим объект
// {band: "Bon Jovi", title: "Slippery when wet",
//  year: 1986, tracks: Array(4) }
console.log(albumObject);`}
      </pre>
      <p>В примере текст в формате JSON сохранён в переменную albumJSON. Обратите внимание на кавычки. Это именно строка, а не литерал объекта. Затем в переменную albumObject присваиваем результат вызова JSON.parse(). Аргументом этот метод принимает строку в формате JSON, а результатом станет объект, полученный в ходе преобразования.</p>
      <p>Обратная процедура выполняется с помощью метода stringify. Рассмотрим на ещё одном примере:</p>
      <pre>{`const user = {
    firstName: 'Keks',
    type: 'cat',
    favorites: [
        'milk',
        'meat',
    ],
}

// Получим JSON-строку
const jsonText = JSON.stringify(user);

// {"firstName":"Keks","type":"cat","favorites":["milk","meat"]}
console.log(jsonText);`}
      </pre>
      <p>Для преобразования (сериализации) объекта user в JSON мы воспользовались методом JSON.stringify(). Аргументом передали объект, а результатом стала строка — текст в формате JSON.</p>
      <p>Методы stringify и parse могут принимать дополнительные аргументы для настройки преобразования. В данном разделе они не будут рассмотрены. Получить информацию по ним вы сможете из MDN.</p>

      <h2>Fetch API</h2>
      <p>Для отправки запросов к серверу браузеры долгое время предоставляли лишь один способ — объект XMLHttpRequest. В своё время Microsoft сделала прорыв с этой технологией и позже XMLHttpRequest был стандартизирован WHATWG.</p>
      <p>С тех пор прошло много времени и требования к этой, на первый взгляд, несложной задаче изменились. Объектом XMLHttpRequest пользоваться стало неудобно. Отсутствие поддержки промисов, не совсем очевидный интерфейс и так далее. Это не говорит, что XMLHttpRequest работает плохо и не годится для взаимодействия с сервером. Вовсе нет. Это по-прежнему рабочий инструмент, но сегодня браузеры предлагают новое, улучшенное API для выполнения запросов — Fetch API.</p>
      <p>Главное преимущество заключается в гибкости и универсальности. Мы говорим Fetch API, но по факту подразумеваем метод fetch. Метод, с помощью которого можно по-разному взаимодействовать с сервером: получать и отправлять произвольные данные с клиента. И для этих задач требуется всего лишь один метод. Это уже проще, чем настраивать XMLHttpRequest.</p>
      <p>Помимо этого Fetch API хорошо интегрировано с другими смежными технологиями. Например, с сервис-воркерами (service worker), технологией позволяющий добавить поддержку оффлайн-режима для веб-приложений.</p>
      <p>Все современные браузеры давно поддерживают fetch. Для более старых доступны полифилы. Выходит, сегодня нет никаких препятствий для использования fetch.</p>
      <p>Метод принимает два параметра: адрес ресурса, на который требуется отправить запрос и объект с настройками. Второй параметр опционален и может не использоваться:</p>
      <pre>{'const promise = fetch(url, [options]);'}</pre>
      <p>Результатом выполнения метода fetch станет промис (promise). За счёт поддержки промисов, обрабатывать результат метода fetch становится гораздо удобней. Попробуем проверить на реальном примере. Запросим информацию о публикациях с песочницы JSONPlaceholder с помощью fetch:</p>
      <pre>{`fetch('https://jsonplaceholder.typicode.com/posts/')
  .then((response) => response.json())
  .then((posts) => console.log(posts))`}
      </pre>
      <p>Этот простой пример демонстрирует выполнение GET-запроса для получения данных (список публикаций) в JSON. В первый параметр методу fetch мы передали адрес ресурса. Второй параметр не задали, так как для выполнения этого запроса дополнительное конфигурирование не требуется. По умолчанию fetch выполнит именно GET запрос.</p>
      <p>Раз метод возвращает промис, мы получаем возможность использовать знакомые методы then, catch и finally. В случае успешного разрешения промиса мы получим экземпляр объекта Response. В нём хранится ответ от сервера. Само собой не в текстом виде, а в структурированном. Объект позволит понять состояние ответа и получить не только данные из тела ответа, но и при необходимости служебную информацию. Например, заголовки, установленные сервером.</p>
      <p>В представленном примере нас интересуют только данные. Нам заранее известно, что сервер вернёт информацию о публикациях в JSON. Мы не делаем дополнительных проверок, а сразу пытаемся получить объект из JSON. Для этого мы используем метод json() у экземпляра объекта Response.</p>
      <p>Встроенный метод автоматически извлечёт данные из потока ответа, разберёт их (преобразует в объект) и вернёт новый промис. А раз результатом станет промис, то можно продолжать цепочку then и обработать результат — получить данные.</p>

      <h3>Объект Response</h3>
      <p>В нём хранится вся информация об ответе сервера. Заголовки, результат выполнения запроса, и другая служебная информация. Всё это доступно в Response. Рассмотрим наиболее полезные свойства этого объекта.</p>
      <p>Сервер может исполнить не все запросы. Самая банальная ситуация: запрашиваемый ресурс не найден. Это может случиться по разным причинам: ресурс был, но потом его перенесли в другое место или в адресе была допущена ошибка. На такой запрос сервер ответит кодом 404.</p>
      <p>Возникает вопрос, а как понять статус выполнения запроса? Ведь если сервер вернул 404, то нет никого смысла пытаться извлечь JSON. Данных ведь нет. При этом промис не будет отклонён. Идея перехватить такую ситуацию с помощью catch не увенчается успехом.</p>
      <p>Определить успешность выполнения запроса поможет свойство ok. Оно содержит булево значение. Если запрос выполнен успешно, ok будет true. В противном случае false.</p>
      <p>Успех определяется на основании кода ответа сервера на запрос. Если код ответа в диапазоне чисел 200-299, значит он выполнился успешно. Всё что не попадает в диапазон означает ошибку.</p>
      <p>Немного доработаем пример получения списка публикаций. Добавим в него проверку успешности выполнения запроса:</p>
      <pre>{`// Объявим отдельную функцию для проверки
// статус выполнения запроса. Её можно
// описать прямо в 'then', но это ухудшит
// читабельность кода
const checkStatus = (response) => {
  if (response.ok) {
    return response;
  }

  const {statusText, status} = response;
  throw new Error('{status} — {statusText}');
}

// Для проверки обработки ошибки изменить часть адреса
// c 'posts' на 'post2424'. Заведомо укажите
// несуществующий адрес
fetch('https://jsonplaceholder.typicode.com/posts/')
  .then(checkStatus)
  .then((response) => response.json())
  .then((posts) => console.log(posts))
  .catch((error) => console.log(error));`}
      </pre>
      <p>Код примера немного подрос, но мы не потеряли в читабельности. Проверку успешности выполнения запроса вынесли в отдельную функцию checkStatus. Это делать необязательно. Проверку можно описать на месте — в анонимной функции, которую передаём в then.</p>
      <p>Однако это скажется на читабельности кода. Кроме того, функция checkStatus универсальна и пригодится для выполнения схожих операций.</p>
      <p>В теле функции checkStatus выполняется проверка свойства ok. Если оно равно true, значит запрос выполнился успешно. Можно возвращать объект запроса и продолжать конвейер обработки (обработать JSON и так далее).</p>
      <p>В случае отрицательного значения ok нужно что-то сделать. Разумным решением в такой ситуации станет формирование объекта с ошибкой. Для этого создаём экземпляр объекта Error. Параметром в конструктор передадим значение свойств status и statusText.</p>
      <p>В первом свойстве (status) доступен код ответа сервера — трёхзначное число. Например, 404 (ресурс не найден). А в свойстве statusText пояснительная строка. Например, Not found. Стоит отметить, что пояснительная строка может отсутствовать.</p>
      <p>Подготовив описание ошибки, бросаем исключение при помощи оператора throw. Вернёмся к основному коду. В первый then передаём ссылку на функцию checkStatus. Если она вернёт промис (запрос выполнен успешно), значит всё хорошо и можно продолжать обработку запроса.</p>
      <p>Другой вариант развития событий — исключительная ситуация. Та самая ошибка, которую мы подготовили в функции checkStatus. Её нужно перехватить. Для этого применяем метод catch и выводим содержимое ошибки в консоль.</p>
      <p>Скопируйте приведённый фрагмент кода и выполните в консоли браузера. Код выполнится без ошибки. В консоли отобразятся публикации. Чтобы протестировать второй сценарий (возникновение ошибки), исправьте адрес (пример в комментарии). Затем вновь выполните код. В этот раз произойдёт ошибка, которую перехватит catch.</p>

      <h4>Обработка ошибок</h4>
      <p>Для обработки успешности выполнения запроса применяется свойство ok или status. Последнее может быть полезным, если требуется более тонкая проверка и разные реакции на различные коды ответов.</p>
      <p>Для обработки успешности выполнения запроса применяется свойство ok или status. Последнее может быть полезным, если требуется более тонкая проверка и разные реакции на различные коды ответов.</p>
      <p>Хорошо, а как быть с другими ошибками? Рассмотренный пример хорошо подходит для обработки выполнения запросов, но могут возникнуть ситуации, когда запрос вовсе не получилось отправить. Типичный пример — ошибка сети.</p>
      <p>В такой ситуации промис, возвращаемый методом fetch, будет отклонён (rejected). Следовательно, обработать такую ошибку поможет метод catch. Поэтому не забывайте добавлять его в конце цепочки then.</p>
      <p>Для проверки этого сценария на практике скопируйте предыдущий фрагмент кода в консоль, но не выполняйте. Сначала перейдите на вкладку «Network» и включите режим «Offline». После этого вернитесь в консоль и выполните код примера.</p>
      <p>Как видите, произошла ошибка «Failed to fetch» и она была успешно обработана с помощью catch.</p>

      <h4>Заголовки</h4>
      <p>Любой ответ содержит заголовки. На клиенте с ними работать приходится реже (по сравнению с сервером). Установленные заголовки доступны через свойство headers. Это обычный объект, поэтому используются стандартные приёмы работы c объектами.</p>
      <p>После прочтения всего перечисленного может сложиться впечатление, что fetch предназначен лишь для работы с данными в формате JSON. Это не так. Объект Response предоставляет несколько готовых методов для получения тела ответа в другом формате. Некоторые из них:</p>
      <ul>
        <li>blob() — возвращает тело ответа в виде бинарных данных с установленным типом. Пригодится для получения файлов, изображений и так далее.</li>
        <li>formData() — возвращает тело ответа в виде объекта FormData — пары/ключ значения, представляющие поля формы.</li>
        <li>text() — возвращает тело ответа в виде текста в кодировке UTF-8.</li>
      </ul>
      <p>Перечисленные методы применяются реже, чем ранее рассмотренный json(), но всё же могут встретиться. Рассмотрим несколько примеров. Обработку ошибок делать не станем для краткости:</p>
      <pre>{`// Загрузим произвольное изображение.
fetch('https://www.fillmurray.com/200/300')
    .then((response) => response.blob())
    .then((imageBlob) => {
        const newImage = document.createElement('img');
        newImage.src = URL.createObjectURL(imageBlob);
        document.body.appendChild(newImage)
    }); `}
      </pre>
      <p>В этом примере кода происходит загрузка изображения с сервиса «FillMurray». Пусть ссылка не содержит расширение, но при обращении к ней мы получим ссылку на изображение. Дальше применяем метод blob() у объекта с ответом. Он вернёт тело ответа в виде бинарных данных.</p>
      <p>Последний шаг — обработка результата. Создаём новой элемент img и добавляем загруженное изображение. Применение других методов выполняется аналогичным образом.</p>

      <h3>Повторный вызов методов</h3>
      <p>При использовании методов чтения контента ответа, следует помнить: можно воспользоваться только одним. Если выполнить чтение ответа с помощью json(), то ниже применить text() (или другой) уже не получится. Произойдёт ошибка.</p>
      <p>Необходимость применять разные методы для одного ответа крайне мала, поэтому с такой ситуацией вы вряд ли столкнётесь на практике. Однако, если такая задача возникнет, то её можно решить предварительным клонированием объекта c ответом. Для этого у него есть метод clone.</p>

      <h3></h3>
      <p>Как мы отметили выше, работа с fetch не ограничивается лишь получением данных от сервера. Ничего не мешает их передавать различными методами. Эта задача не сильно сложней, но придётся задействовать второй параметр метода fetch — объект с настройками.</p>
      <p>Попробуем подготовить и отправить запрос методом POST (речь о методе в контексте протокола HTTP). Экспериментировать будем на песочнице «JSONPlaceholder», поэтому все примеры сможете повторить в своём браузере, просто копируя код и выполняя его в консоли.</p>
      <pre>{`// Отправим информацию о новой публикации
// на сервер HTTP-методом POST.

// Данные для отправки
const post = {
  id: 1,
  userId: 31337,
  title: 'Обзор метода fetch',
  body: 'Содержимое обзора',
}

// Вторым параметром передадим объект с конфигурацией.
// Определим в нём метод, заголовки и тело запроса.
fetch('https://jsonplaceholder.typicode.com/posts', {
    // Вместо 'POST' здесь может быть
    // любой другой  HTTP-метод.
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(post)
})
    .then((response) => response.json())
    .then((json) => console.log(json));`}
      </pre>
      <p>В этом примере кода задействован второй параметр метода fetch. В него мы передаём объект с настройками. По умолчанию метод fetch выполняет HTTP-запрос методом GET. Метод переопределяется в объекте с конфигурацией, в одноимённом свойстве method. На месте POST может быть любой другой HTTP-метод. Например: PUT, PATCH, DELETE и так далее.</p>
      <p>При подготовке запроса нам доступна возможность установить произвольные заголовки. Для этого в конфигурационном объекте предусмотрено свойство headers. Это обычный объект, где каждая пара ключ/значение описывает заголовок.</p>
      <p>В приведённом примере определяем один заголовок — Content-Type (тип содержимого). Данные передаются в формате JSON, ему соответствует тип application/json. Другие заголовки добавляются аналогичным образом. Например, если потребуется добавить заголовок User-Agent, то достаточно описать ещё одну пару ключ/значение:</p>
      <pre>{`// …
headers: {
  'Content-Type': 'application/json',
  'User-Agent': 'Google Chrome'
},`}
      </pre>
      <p>Тело запроса фиксируется в свойстве body. Мы планируем отправить данные в JSON, поэтому сразу сериализуем подготовленный объект с данными.</p>
      <p>Дальше всё повторяется — пишем код для обработки ответа. Ответом на такой POST запрос станет JSON, содержащий созданную сущность.</p>

      <h3>Отправка формы</h3>
      <p>При помощи метода fetch можно отправить и форму. Он поддерживает интерфейс FormData, следовательно дополнительных преобразований делать не нужно. Рассмотрим пример: попробуем отправить форму .user-form с помощью метода fetch:</p>
      <pre>{`const userForm = document.querySelector('.user-form');
userForm.addEventListener('submit', (evt) => {
    evt.preventDefault();

    // Отправка формы
    fetch('/form', {
        method: 'POST',

        // Содержимое формы помещаем в тело
        // запроса.
        body: new FormData(userForm),
    })
        // Дальше может быть обработка результатов…
        .then((response) => console.log(response));
});`}
      </pre>
      <p>Пример не содержит описание формы. В данном контексте это не сильно важно. Мы находим форму .user-form, подписываемся на событие submit и при его наступлении выполняем отправку. Поскольку форма отправляется методом POST, приходится задействовать второй параметр и подготовить объект с настройками. Содержимое формы получаем при помощи объекта FormData и устанавливаем в тело запроса (body). Если форма содержит поле &lt;input type="file"&gt;, то дополнительных действий делать не требуется. Файл будет отправлен.</p>
      <p>Дальше сценарий ничем не отличается от рассмотренных ранее — выполняем then и можем приступать к обработке результатов отправки формы.</p>
      <p>Пользоваться методом fetch несложно. API лаконичен, а результат в виде объекта-промис упрощает обработку. Мы можем легко группировать операции обработки результаты в цепочки, тем самым упрощая код.</p>
      <p>Поскольку применяются промисы, то ничего не мешает воспользоваться операторами async/await. Они позволяют сделать код ещё более похожим на синхронный. Стоит ли использовать их повсеместно? Зависит от ситуации и предпочтений.</p>
      <pre>{`(async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts');
    const posts = await response.json();
    console.log(posts);
})();`}
      </pre>
    </section>
  );
}
export default AjaxAndSPA;
