import React from 'react';

function OperatorsSpreadAndRest() {

  return (
    <section className="conspect">
      <h1>Операторы spread и rest</h1>
      <p>Операторы spread и rest так же, как и цикл for..of появились в спецификации ES2015 и работают с перечисляемыми структурами данных.</p>
      <p>Операторы spread и rest помогают очень быстро вытаскивать отдельные значения из списков или, наоборот, быстро создавать новые списки на основе других списков. Превращение одних списков в другие помогает, когда нужно создать одну структуру на основе другой.</p>
      <h2>Оператор rest (прочее, остальное)</h2>
      <p>Оператор rest всегда идёт последним параметром и собирает в себе всё, что передали в конце функции в массив.</p>
      <p>В JS есть много функций, которые работают с любым количеством аргументов. Например, для функции Math.max неважно среди какого количества элементов определять максимальный.</p>
      <pre>{`
        Math.max(1, 2, 3);
        Math.max(1);
        Math.max(1, 2, 3, 4, 5, 100, 1000, Infinity);
        Math.max(); // -Infinity, если вам интересно
        Math.max(1, 2);
      `}
      </pre>
      <p>Чтобы написать такую функцию в ES5, нам приходилось обращаться к коллекции arguments, которая есть во всех функциях, кроме стрелочных.</p>
      <pre>{`
        const getMaxValue = function() {
          // Превращаем все переданные аргументы в массив
          const passedValues = Array.prototype.slice.call(arguments);
          let max = -Infinity;

          // Перебираем массив в поисках максимального элемента
          for (let i = 0; i < passedValues.length; i++) {
            if (passedValues[i] > max) {
              max = passedValues[i];
            }
          }

          return max;
        };

        console.log(getMaxValue(1, 2, 3)); // 3
      `}
      </pre>
      <p>В ES2015 появился более простой способ обратиться ко всем аргументам сразу: оператор rest (остальные). Оператор rest используется при объявлении функции и выглядит как многоточие, после которого идёт название. Это значит, что все аргументы, которые будут переданы после многоточия, будут собраны в одну перечисляемую структуру данных и обратиться к ней можно будет по заданному нами названию, в примере ниже это vals.</p>
      <pre>{`
        const getMaxValue = (...vals) => {
          let max = -Infinity;

          // vals это перечисляемая структура, поэтому на ней
          // работает цикл for..of
          for (const val of vals) {
            if (val > max) {
              max = val;
            }
          }

          return max;
        };

        console.log(getMaxValue(1, 2, 3)); // 3
      `}
      </pre>
      <p>Оператор rest может работать не со всеми переданными аргументами, а только с частью. В примере ниже, в перечисляемую структуру попадут все переданные аргументы, начиная с третьего, а первый и второй параметр будут работать, как в обычной функции.</p>
      <pre>{`
        const oneVeryOddRestFunction = (a, b, ...rest) => {
          console.log(a);
          console.log(b);

          for (const val of rest) {
            console.log(val);
          }
        };
      `}
      </pre>
      <p>Даже из названия rest-оператора (остальные), можно понять, что при объявлении функций оператор rest должен всегда быть последним.</p>
      <h2>Оператор spread</h2>
      <p>Оператор spread — это оператор, в какой-то степени, обратный оператору rest. Если оператор rest собирает несколько переданных значений в одну перечисляемую структуру, то spread (в переводе с английского «распространить») делает ровно наоборот — он превращает одно перечисляемое значение в несколько отдельных.</p>
      <p>Оператор, противоположный оператору rest — оператор spread, который позволяет превратить массив в параметры через запятую.</p>
      <pre>{`
        // Сразу начнём с примера. Math.max принимает
        // на вход только отдельные аргументы. Нам нужно
        // найти максимальный элемент в массиве
        const whoIsTheGreatestOfThemAll = [1, 2, Infinity, 100, -3];

        // Раньше, чтобы передать массив в Math.max
        // приходилось упражняться в остроумии и выдумке
        // и вспоминать о методе apply
        Math.max.apply(null, whoIsTheGreatestOfThemAll);

        // Теперь, этого можно не делать, потому что
        // существует spread-оператор. Он может за одну
        // операцию превратить массив
        // (или любую другую перечисляемую структуру)
        // в список значений
        Math.max(...whoIsTheGreatestOfThemAll);

        // Из-за этой особенности, с помощью spread-оператора
        // можно превращать в массивы любые другие перечисляемые
        // структуры
        [...document.querySelectorAll('div')].filter(
          (it) => it.classList.contains('block__element_modifier'),
        );
      `}
      </pre>
    </section>
  );
}
export default OperatorsSpreadAndRest;
