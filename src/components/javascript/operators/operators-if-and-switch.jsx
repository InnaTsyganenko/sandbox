import React from 'react';

function OperatorsIfAndSwitch() {

  return (
    <section className="conspect">
      <h1>Операторы if &amp; switch</h1>
      <h2>Условная конструкция if ... else (если ... иначе)</h2>
      <p>Условная конструкция позволяет выполнять действия в зависимости от условия.Условие — это инструкция, которая возвращает true или false. Выглядит условная конструкция так:</p>
      <pre>{`
if (условие) {
  // Инструкции, которые выполнятся, если условие истинно
} else {
  // Инструкции, которые выполнятся, если условие ложно
}

Вложенные условия:

      if (условие1) {
        if (условие2) {
          действия;
        }
      }
`}
      </pre>
      <p>Условие записывают в круглых скобках после слова if (переводится с английского как «если»). После этого внутри фигурных скобок пишут инструкции, которые выполнятся, если условие истинно. Условие считается истинным, если инструкция внутри круглых скобок возвращает true.</p>
      <p>Конструкция else (переводится как «иначе») говорит JavaScript, что делать, если условие ложно. Внутри фигурных скобок после else пишут инструкции, которые должны выполниться, если условие вернёт false.</p>
      <p>Использование условных конструкций в скрипте ещё называют ветвлением, а код внутри фигурных скобок — веткой.</p>

      <h2>Операторы сравнения:</h2>
      <dl>
        <dt>&gt;</dt>	<dd>больше</dd>
        <dt>&lt;</dt>	<dd>меньше</dd>
        <dt>&gt;=</dt>	<dd>больше или равно</dd>
        <dt>&lt;=</dt>	<dd>меньше или равно</dd>
      </dl>

      <h2>Логические операторы.</h2>
      <dl>
        <dt>&amp;&amp;</dt> <dd>или «логическое И» возвращает true только в том случае, если оба условия, слева и справа от него, возвращают true.</dd>
        <dt>||</dt> <dd>или «логическое ИЛИ» возвращает true если любое из условий слева или справа от него, возвращают true.</dd>
        <dt>!</dt> <dd>или «логическое отрицание» меняет булево значение выражения справа от него на противоположное.</dd>
      </dl>

      <h2>Операторы равенства:</h2>
      <dl>
        <dt>==</dt>
        <dd>Нестрогое равенство (с приведением типов). Сравнивает два значения, перед этим приводит одно из значений к типу другого. Если значения равны, возвращает true.</dd>
        <dt>===</dt>
        <dd>Строгое равенство (без приведения типов)	Сравнивает два значения. Если типы значений разные или значения не равны, возвращает false.</dd>
        <dt>!=</dt>
        <dd>Неравенство (с приведением типов)	Сравнивает два значения, перед этим приводит одно из значений к типу другого. Если значения не равны, возвращает true.</dd>
        <dt>!==</dt>
        <dd>Строгое неравенство (без приведения типов)	Сравнивает два значения. Если типы значений разные или значения не равны, возвращает true.</dd>
      </dl>
      <p>Любые значения внутри проверок приводятся к булеву типу. Все числа кроме 0 — true, при этом 0 — false.</p>
      <p>Все строки, кроме пустой строки — true, пустая строка &apos;&apos; — false.</p>
      <p>Как же быть, если есть два значения разных типов, а на приведение по умолчанию надеяться не хочется? Использовать приведение «руками».</p>
      <p>Например, можно привести числовое значение к строковому типу. Один из способов — использовать команду число.toString(). Например:</p>
      <pre>{`var number = 1;

// Выведет число: 1 (number)
console.log(number);

// Выведет строку: 1 (string)
console.log(number.toString());`}
      </pre>

      <h2>Команда Number</h2>
      <p>Привести число к строке можно с помощью команды .toString(). Но иногда, наоборот, требуется превратить строку в число, чтобы сравнить их. Для этого можно использовать команду parseInt(). Пример:</p>
      <pre>{`var string = '1';

      console.log(string);
      // выведет строку: 1 (string)

      console.log(parseInt(string, 10));
      // выведет число: 1 (number)`}
      </pre>
      <p>Обратите внимание, что у команды два аргумента: строка, которую мы пытаемся превратить в число; основание системы счисления, в которую мы переводим число.</p>
      <p>Мы привыкли работать в десятичной системе счисления, но в программировании часто приходится иметь дело с другими системами: второй аргумент. И хотя сейчас мы не будем разбираться в тонкостях систем счисления, не забывайте про эту особенность команды parseInt() и всегда явно указывайте второй аргумент, чтобы избежать ошибок.</p>


      <p>Счётчик лайков, пример работы условной конструкции:</p>
      <pre>{`<code>
let heart = document.querySelector('.heart');
let likesNumber = document.querySelector('.likes-number');

heart.onclick = function () {
  if (heart.classList.contains('added')) {
    likesNumber.textContent--;
  } else {
    likesNumber.textContent++;
  }

  heart.classList.toggle('added');
};
</code>`}
      </pre>
      <a href="program-like-counter.html">Счётчик лайков</a>
      <a href="program-comments.html">Комментарии в ленту</a>

      <h2>Оператор switch</h2>
      <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch#syntax" target="_blank" rel="noopener noreferrer">MDN. switch</a></p>
      <p>Такой вот сложный и перегруженный код:</p>
      <pre>{`const weathers = ['Солнечно', 'Ветрено', 'Дождливо', 'Морозно', 'Пасмурно', 'Гололёд'];

const getСlothing = function (weather) {
if (weather === 'Солнечно') {
  return 'Майку';
} else if (weather === 'Ветрено') {
  return 'Куртку';
} else if (weather === 'Дождливо') {
  return 'Дождевик';
} else if (weather === 'Морозно') {
  return 'Пуховик'
} else if (weather === 'Пасмурно') {
  return 'Плащ'
}
return 'Непонятно!';
}`}
      </pre>
      <p>Можно заменить на код с оператором switch:</p>
      <pre>{`const getСlothing = function (weather) {
switch (weather) {
  case 'Солнечно':
    return 'Майку';
  case 'Ветрено':
    return 'Куртку';
  case 'Дождливо':
    return 'Дождевик';
  case 'Морозно':
    return 'Пуховик';
  case 'Пасмурно':
    return 'Плащ';
  default:
    return 'Непонятно!';
}
}`}
      </pre>
      <p>switch принимает в скобках выражение, результат которого будет проходить строгое сравнение со значениями case’ов (англ. «случай»). При нахождении совпадения выполнится блок кода соответствующего case. Блок кода указывается через двоеточие после указания case.</p>
      <p>Если тождественный случай отсутствует, то сработает блок default. Этот блок используется для обработки не предусмотренных входных значений.</p>
      <p>Чтобы прервать выполнение switch, используется return или ключевое слово break.</p>
      <p>Пример с объединением кейсов</p>
      <pre>{`const isEven = function (number) {
  switch (number) {
    case 0:
    case 2:
    case 4:
      return 'Чётное'
    case 1:
    case 3:
      return 'Нечётное'
    default:
      return 'Я умею считать только до 4 :('
  }
}
isEven(1); // 'Нечётное'`}
      </pre>
      <p>Запомните</p>
      <ul>
        <li>Если case&apos;ы не объединяются, то должны содержать break или return.</li>
        <li>Выражение передаваемое в switch представляется в любом виде (примитив, переменная, вычисляемое значение или вызов функции).</li>
        <li>Порядок случаев не важен.</li>
        <li>Блок default не является обязательным, но его удобно использовать на случай ошибок или значений по умолчанию.</li>
        <li>При наличии одинаковых случаев будет выбран первый попавшийся</li>
      </ul>
    </section>
  );
}
export default OperatorsIfAndSwitch;
