import React from 'react';

function Function() {

  return (
    <section className="conspect">
      <h1>Функция-помощник</h1>
      <p>В любом языке программирования есть возможность разбить код на небольшие подпрограммы — самостоятельные фрагменты кода.</p>
      <p>Функция — это механизм, позволяющий разбивать код приложения на подпрограммы (фрагменты кода), тем самым давая возможность многократно переиспользовать его в разных частях программы.</p>
      <p>С точки зрения кода, функция не что иное как именованный фрагмент кода, обёрнутый оператором или специальными символами. Для выполнения кода функции применяется идентификатор — то самое имя.</p>
      <p>Функция — кусок кода, который можно написать один раз, а затем многократно использовать. Функция не просто содержит в себе значение, как переменная, а выполняет какое-то действие и решает какую-то задачу: считает, сравнивает, ищет.</p>
      <pre>{`var functionName = function () {
// Действия, которые выполняет функция или «тело функции»
};`}
      </pre>
      <p>Имена функций принято именовать в стиле camelCase, имена файлов писать маленькими и через дефис.</p>

      <h2>Объявление функций</h2>
      <p>Объявить функцию в JavaScript можно несколькими способами: декларативно (function declaration) и в виде функционального выражения (functions expression). Спецификация ECMAScript 2015 добавила дополнительный синтаксис для описания функций — стрелочные функции.</p>

      <h3>Декларативное объявление</h3>
      <p>При декларативном способе объявления, функция определяется в основном потоке кода. Для объявления функции применяется оператор function. После него следует имя функции. После имени функции в круглых скобках описываются аргументы функции. Аргументы — это входные данные.  Количество аргументов не ограничено. Их может и вовсе не быть. Через аргументы мы сможем передать для функции произвольные значения. Внутри функции к ним можно обратиться как к обычным переменным.</p>
      <p>Функция может не принимать никаких аргументов, быть самостоятельной. В этом случае следует указать пустые круглые скобки. После круглых скобок открываются фигурные и в них описывается тело функции. В теле описываются действия (код), которые должна выполнять функция — тот самый фрагмент кода.</p>
      <pre>{`
function <Имя функции>([Аргументы функции]) {
  // Тело функции
}
`}
      </pre>
      <p>Для возврата значения из функции в языке предусмотрен оператор return. Выполнив оператор return, функция прекратит работу и вернёт значение.</p>
      <p>Оператор return необязателен, если его не указать, функция всё равно будет возвращать значение. По умолчанию функция всегда возвращает undefined.</p>
      <p>В JavaScript есть встроенные функции языка, например объект Math (математические константы и функции).</p>

      <h2>Вызов функции</h2>
      <p>Нужно обратиться к функции по её имени, а затем указать круглые скобки. Если функция принимает аргументы, то в этих скобках следует передать значения для каждого из них</p>
      <pre>{`
functionName();
`}
      </pre>
      <p>Обратите внимание, что вызов функции должен идти в коде после её определения.</p>
      <p>Если функция что-то возвращает, то результат её выполнения следует куда-то сохранить, чтобы потом воспользоваться этим значением. Например, определяем переменную result и присваиваем в неё вызов функцию.</p>
      <pre>{`
const result = sum(10, 4);
`}
      </pre>
      <pre>{`
var getString = function () {
  return 'Привет из функции!';
}

console.log(getString);    // Выведет код функции
console.log(getString()); // Выведет: Привет из функции!
`}
      </pre>
      <p>Мы передали функцию и вызов функции в console.log. А ведь console.log() — тоже функция!</p>

      <h3>Функциональное выражение</h3>
      <p> При объявлении функции в виде функционального выражения, результат определения функции записывается в переменную и имя функции не указывается. В остальном синтаксис идентичен.</p>
      <pre>{`
// Объявление функции в виде функционального
// выражения.
const sum = function (firstNumber, secondNumber) {
  return firstNumber + secondNumber;
}
`}
      </pre>
      <p>Для вызова функции, записанной в переменную sum, мы просто обращаемся к этой переменной.</p>
      <p><span className="hl-3">Чаще всего в JavaScript применяется именно второй способ: функциональное выражение.</span></p>
      <p>Функции, объявленные декларативно, создаются до выполнения основного кода.Перед выполнением сценария, движок JavaScript находит и создаёт все функции, описанные декларативным способом. Таким образом, в коде можно обратиться к функции до её объявления.</p>
      <p>В случае с функциональными выражениями, функция создаётся в момент выполнения кода, поэтому обратиться к ней можно только после объявления.</p>
      <p>Другой плюс декларативного объявления функции — читаемость. Такие функции проще выхватывать глазом в общем потоке кода.</p>
      <p>Так какой же способ выбрать? Всё зависит от задачи и стиля, принятого в проекте. Следует выбрать один способ и придерживаться его на протяжении создания всего проекта.</p>
      <p>Параметры — значения, с помощью которых можно настраивать функции, делать функцию универсальной. Так мы можем узнать результат работы функции для разных случаев.</p>
      <pre>{`
var showTime = function (hours, minutes) {
console.log('Текущее время: ' + hours + ':' + minutes);
};

showTime(3, 15);    // Выведет: Текущее время: 3:15
showTime(16, 20);   // Выведет: Текущее время: 16:20
`}
      </pre>
      <p>Чтобы функция работала с параметрами, их надо как-то передать и дать им названия</p>
      <ol>
        <li>Задаём параметры.
          <pre>{`var showTime = function (hours, minutes) {
…
};`}
          </pre>
          <p>В момент объявления функции, в круглых скобках, мы создаём параметры. Здесь всё, как с переменными: сначала задаём параметрам имена, которые описывают, что за значения будут в них записаны. Если параметров несколько, они записываются через запятую.</p>
        </li>
        <li>Используем параметры.
          <pre>{`
var showTime = function (hours, minutes) {
console.log('Текущее время: ' + hours + ':' + minutes);
};`}
          </pre>
          <p>Параметры работают так же, как переменные. Мы подставляем их вместо фиксированных значений в операции внутри функции. При выполнении кода вместо каждого параметра подставится его значение.</p>
        </li>
        <li>Функция получает значения параметров</li>
      </ol>
      <pre>{`
showTime(3, 15);    // Выведет: Текущее время: 3:15
showTime(16, 20);   // Выведет: Текущее время: 16:20
`}
      </pre>
      <p>Правильно говорить «функция принимает параметры», но при этом мы «передаём функции аргументы». Почему аргументы? Речь же шла о параметрах! Дело в том, что <span className="hl-3">параметрами называются значения, которые мы задаём в момент объявления функции</span>. Их же мы используем и в теле функции. А <span className="hl-3">аргументами называют значения, которые мы передаём в функцию при её вызове</span>.</p>
      <p className="hl-6">Мы выяснили, что переопределение глобальных переменных влияет на результат работы функции, которая эти переменные использует. Но, вообще-то, так делать не стоит — это не лучшая практика. Переопределение переменных, которые использует функция, может приводить к неожиданным последствиям и ошибкам в коде. Поэтому и существуют параметры, чтобы переиспользовать функции, явно передавая необходимые значения.</p>
      <p className="hl-6">С параметрами всё легко и понятно, если мы хотим сразу вызвать функцию и получить результат её работы.</p>

      <h2>Стрелочные функции</h2>
      <p>В ECMAScript 2015 появился новый синтаксис стрелочных функций (arrow function). Он более лаконичен и особенно удобен при описании функций, выполняющих одно действие.</p>
      <pre>{`// Пример стрелочной функции
(param1, param2, paramN) => {
    // Действие 1
    // Действие N
    // return <Результат>
}

// Пример стрелочной функции без параметров
() => {
    // действие
}

// Стрелочная функция из одного действия
() => expression;

const multiply = (a, b) => {
  return a * b;
}

multiply(2, 2); // 4

// Ещё более короткий синтаксис
const multiply = (a, b) => a * b;
multiply(2, 2); // 4
`}
      </pre>
      <p>Важно запомнить: стрелочная функция всегда анонимна. Мы не можем задать для неё имя и объявить декларативно. Поэтому, если требуется описать стрелочную функцию, к которой планируется обращение в будущем, необходимо сохранить на неё ссылку в переменную.</p>

      <h3>Вернуть объект</h3>
      <p>А что если единственная задача стрелочной функции вернуть объект, созданный с помощью литерала? Можно ли в этом случае воспользоваться сокращённым синтаксисом, рассмотренным в прошлом разделе? Попробуем выполнить пример, представленный ниже. Увы, результатом станет не объект с единственным свойством stringCount, а значение undefined.</p>
      <pre>{`
const getGuitar = () => { stringCount: 6 };
getGuitar(); // undefined
`}
      </pre>
      <p>Почему так произошло? Дело в том, что интерпретатор не смог понять, что мы от него хотим. Точнее растолковал фигурные скобки в контексте описания тела функции. Ведь ранее мы об этом и говорили: для описания тела функции применяются фигурные скобки. Как же быть тогда с объектом?</p>
      <p>Решить эту проблему можно двумя способами. Первый самый простой: определить объект в теле функции и вернуть его в виде результата функции при помощи оператора return. Второй способ заключается в применении сокращённого синтаксиса. Только результат (новый объект) следует обернуть в круглые скобки. Тогда интерпретатор точно поймёт, что в скобках именно объект:</p>
      <pre>{`
const getGuitar = () => ({ stringCount: 6 });
getGuitar(); // { stringCount: 6 }
`}
      </pre>

      <h3>Отбрасываем скобки</h3>
      <p>В случаях, когда стрелочная функция принимает лишь один параметр, круглые скобки можно не писать. Рассмотрим на примере:</p>
      <pre>{`
const addTwo = count => count + 2;
addTwo(2); // 4
`}
      </pre>
      <p>Определение функции addTwo выглядит ещё короче за счёт отказа от скобок. Однако мы рекомендуем не применять такой способ, а всегда описывать параметры стрелочной функции в скобках. Это удобно по нескольким причинам: при чтении кода глазу проще отделить тело функции от параметров. Причина субъективная, но многие разработчики сходятся в этом мнении. Другая причина заключается в упрощении рефакторинга. Если потребуется добавить второй параметр, то придётся возвращать скобки. Мелочь, но фактически дополнительное неудобство.</p>

      <h3>Отсутствует arguments</h3>
      <p>Вы уже знаете, что внутри function доступна локальная переменная arguments. Это массивоподобный объект, содержащий все аргументы, переданные в функцию. Напомним на примере:</p>
      <pre>{`
function multiply(a, b) {
  console.log(arguments[0]);
  console.log(arguments[1]);
}

multiply(2, 5); // 2, 5
`}
      </pre>
      <p>Стрелочным функциям переменная arguments недоступна. Если к ней обратиться, то вместо вывода значений аргументов, возникнет ошибка arguments is not defined. А как же тогда быть, если требуется описать функцию с неопределённым количеством параметров? Решить задачу поможет rest-оператор. Он соберёт все параметры в массив. Рассмотрим на примере:</p>
      <pre>{`
const numbersToArray = (...numbers) => numbers;
console.log(numbersToArray(2, 5, 6, 6, 7)); // [2, 5, 6, 6, 7]
`}
      </pre>
      <p>Совмещая эту возможность с методами массивов, можно получить интересные комбинации. Например, написать функцию для подсчёта суммы чисел и так далее (см. метод reduce).</p>

      <h3>Другие особенности</h3>
      <p>Стрелочные функции не могут использоваться в качестве функций-конструкторов. Они не образуют собственный контекст (this), а используют контекст окружения, в котором объявлены. Из-за отсутствия контекста стрелочные функции не могут вызываться с помощью оператора new.</p>
      <p>А раз стрелочные функции не образуют собственный контекст, то применение методов apply, call и bind теряет смысл. Переопределить или задать произвольное значение контекста попросту не получится.</p>
      <p>Может показаться, что из-за отсутствия собственного контекста, стрелочные функции имеют ограниченное применение. Это не так. Особенность с контекстом реализована намерено, так как позволяет избавиться от потери окружения. До появления стрелочных функций его приходилось сохранять самостоятельно, что не очень удобно. Рассмотрим на примере:</p>
      <pre>{`
const musicStore = {
  artist: 'Bon Jovi',
  albums: [
      'Runaway',
      'Slippery when wet',
      'New Jersey',
      'Keep the faith',
  ],

  print() {
      this.albums.forEach(function(album) {
          console.log('&dollar;{this.artist} — &dollar;{album}');
      });
  }
}
`}
      </pre>
      <p>Если выполнить этот небольшой фрагмент кода в консоли браузера, вместо имени артиста будет выведено значение undefined. Внутри анонимной функции, которая передаёт в forEach другой контекст. Поэтому вместо вывода значения поля artist мы получаем undefined. Исправить проблему можно несколькими способами.</p>
      <p>Первый заключается в применении старого подхода — предварительное сохранение контекста в отдельную переменную. Например:</p>
      <pre>{`
print() {
  // Сохраним контекст
  const self = this;
  this.albums.forEach(function(album) {
      // Вместо 'this' обратимся к 'self'
      console.log('&dollar;{self.artist} — &dollar;{album}');
  });
}
`}
      </pre>
      <p>Попробуйте обновить функцию (метод) print и вновь запустить пример. В этот раз результат вывода совпадёт с ожидаемым.</p>
      <p>Второй способ решения — воспользоваться стрелочной функцией. Поскольку стрелочные функции не образуют свой контекст, то ничего сохранять больше не нужно:</p>
      <pre>{`
print() {
  this.albums.forEach((album) => {
      console.log('&dollar;{this.artist} — &dollar;{album}');
  });
}
`}
      </pre>

      <h2>Области видимости</h2>
      <p>Область видимости — это набор всех значений, доступных функции. Выделяют 3 области видимости: локальную, блочную и глобальную.</p>

      <h3>Локальная</h3>
      <p>В область видимости функции входят параметры функции и переменные, объявленные в ней.</p>
      <p>Области видимости создаются только функциями. Поэтому, если переменная была создана в другой конструкции, например, в цикле, она будет доступна для чтения из функции.</p>
      <pre>{`var name = 'Keks';
console.log(name); // 'Keks'

var makeAnimalTypeVariable = function () {
var animalType = 'Cat';
}
makeAnimalTypeVariable();
console.log(animalType); // animalType is not defined`}
      </pre>

      <h2>Глобальная область видимости</h2>
      <p>Глобальная область видимости — набор значений доступный везде. В неё попадают все переменные, объявленные «прямо в JS-файле», то есть вне функций. Переменные, объявленные в глобальной области видимости, попадают в объект window, который описывает текущую вкладку браузера (исключая вложенные iframe, для каждого из них создаётся свой объект window).</p>
      <p>Благодаря глобальной области видимости можно объявить переменную в одном файле, задать ей значение в другом файле, а воспользоваться ей вообще в третьем месте. У этого подхода есть как преимущества, так и недостатки.</p>
      <p>Основное преимущество заключается в том, что с помощью глобальной области видимости можно обмениваться данными между файлами.</p>
      <p>Основной недостаток — это возможность случайно изменить значение глобальной переменной в одном из файлов — затереть исходное значение.</p>

      <h3>Блочная область видимости</h3>
      <p>Блочная область видимости — область видимости, обусловленная блоком фигурных скобок {}.</p>
      <p>Блок фигурных скобок может быть самостоятельным или быть частью других конструкций (for, if, ...).</p>
      <p className="hl-3">Обратите внимание, что объект — это не блок фигурных скобок!</p>
      <p>Глобальные области видимости используются довольно редко. Можно использовать там, где вы точно знаете что у вас один файл на проекте, либо один тег script, либо вы хотите организовать модульность, тем не менее во всех остальных случаях, нужно стараться глобальные области видимости не использовать, если в этом нет серьёзной необходимости.</p>
      <p>Появление в ECMAScript 2015 новых способов объявления переменных с помощью ключевых слов let и const позволяют избежать проблем, о которых было необходимо помнить при использовании var (как пример — потеря окружения).</p>

      <h3>Синтаксис оставшихся параметров функции <span className="hl-10">rest</span></h3>
      <p>При работе с функциями можно использовать синтаксис оставшихся параметров для того, чтобы организовать приём любого количества аргументов в виде массива.</p>
      <p>Выведем массив, содержащий аргументы, переданные функции.</p>
      <pre>{`function displayArgumentsArray(...theArguments) {
  console.log(theArguments);
}

displayArgumentsArray('hi', 'there', 'bud');
// В консоли будет выведен массив ['hi', 'there', 'bud']`}
      </pre>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">MDN. Rest parameters</a></p>

      <h2>Замыкания</h2>
      <p>Замыкание — функция, которая помнит о своём окружении. Это функция + все значения вне локальной области видимости, которые она использует.</p>
      <p>Благодаря замыканиям мы можем зафиксировать какое-то значение в функции, а использовать саму функцию позже.</p>
      <pre>{`var collectContainer = function () {
var food = 'макароны';
var eatDinner = function () {
  console.log('Поел ' + food);
}
return eatDinner;
};

var schoolkid = collectContainer();
schoolkid();
// Выведет: Поел макароны


var collectContainer = function () {
var food = 'макароны';
var eatDinner = function () {
  console.log('Поел ' + food);
};
return eatDinner;
};

var schoolkid = collectContainer();
console.log(schoolkid);
// Выведет: function () { console.log('Поел ' + food); }
`}
      </pre>
      <p>Мы хотим, чтобы функция получила фиксированное значение, которое бы не зависело от изменений в глобальной области видимости. При этом результат работы функции мы хотим получить не сразу. Как с событиями, когда мы создаём обработчик, но ждём выполнение события не сразу.</p>
      <p>Код из примера работает так: мы вызываем collectContainer → функция collectContainer возвращает eatDinner → вызываем eatDinner.</p>
      <p>Мы создаём функцию внутри функции. Таким образом мы создаём одну область видимости внутри другой области видимости. У eatDinner своя область видимости, в которой идёт обращение к переменной food. Эта переменная объявлена внутри collectContainer, у которой своя область видимости.</p>
      <p>Функция eatDinner не находит внутри себя создание переменной food, смотрит в соседнюю область видимости (в область видимости collectContainer). Там она находит переменную food, узнаёт, что её значение равно строке &apos;макароны&apos;, и фиксирует это значение в памяти.</p>
      <p>Код самой функции не меняется, просто в памяти вместе с функцией хранится то значение переменной, которое было при объявлении этой функции. Поэтому eatDinner «помнит» значение food. Это особенность функций, они помнят своё окружение в момент своего создания. В таком случае говорят о замыкании. Замыкание — функция, которая помнит о своём окружении. То есть это функция + все значения переменных вне локальной области видимости этой функции. Речь идёт только о переменных, которые функция использует в своём коде.</p>
      <p>В нашем примере функция eatDinner вместе с переменной food являются замыканием.</p>
      <p>Именно благодаря замыканиям код из примера выше работает. eatDinner помнит о значении food при своём создании, поэтому использует это значение в момент вызова. Как если бы мама сказала нам купить картошки, когда мы будем идти мимо магазина. Мы запомнили про картошку и пошли по своим делам. Когда мы увидели магазин, мы вспомнили, что именно картошка была нужна, мы её купили и пошли домой.</p>
      <p>Наш пример рабочий, но он жёстко привязан к значению внутри функции collectContainer. Может школьник не хочет есть каждый раз только макароны? Нужно дать ему возможность выбора. Да и чаще всего мы передаём какие-то значения в функцию, а не жёстко фиксируем их внутри локальной области видимости. Добавим функции collectContainer параметр.</p>
      <pre>{`var collectContainer = function (food) {
return function () {
  console.log('Поел ' + food);
};
};

var schoolkid = collectContainer('макароны');
schoolkid();
// Выведет: Поел макароны`}
      </pre>
      <p>Теперь значение food будет использовано из параметра, а не из локальной переменной функции collectContainer. Работать всё будет точно так же. Функция, которую возвращает collectContainer, будет запоминать значение параметра и использовать его при своём вызове.</p>
      <p>Внутреннюю функцию мы сделали анонимной, потому что имя eatDinner нигде не используется. Это никак не повлияет на работу функции.</p>
      <p>Обратите внимание, что каждый раз, когда мы будем вызывать функцию collectContainer и записывать результат в переменную, в памяти будет создаваться новое замыкание, которое будет помнить о значении параметра food в момент своего создания.</p>

      <h2>Замыкания и асинхронность</h2>
      <p>Некоторые функции выполняются асинхронно, поэтому в момент выполнения кода значение переменной может уже измениться. Чтобы избавиться от этой проблемы, нужно создать отдельную область видимости. Так все переменные будут под контролем и замыкания не позволят потерять необходимые значения.</p>
      <pre>{`var thumbnails = document.querySelectorAll('.gallery__photo-preview');
var fullPhoto = document.querySelector('.full-photo');

var addThumbnailClickHandler = function (thumbnail, photo) {
thumbnail.addEventListener('click', function () {
  fullPhoto.src = photo;
});
};

for (var i = 0; i < thumbnails.length; i++) {
addThumbnailClickHandler(thumbnails[i], photos[i]);
}`}
      </pre>

      <h2>Функции обратного вызова</h2>
      <p>Колбэк-функция или функция обратного вызова — функция, предназначенная для отложенного выполнения.</p>
      <p>Запрос на получение данных с сервера не выполняется мгновенно: браузеру понадобится время, чтобы найти IP-адрес сервера, установить соединение, передать запрос, дождаться ответа и т. д. Все эти действия занимают разное количество времени. Временные задержки будут постоянно отличаться и зависеть от скорости соединения с сетью, времени выполнения запроса на сервере и некоторых других факторов.</p>
      <p>Синхронные запросы к серверу будут блокировать дальнейшее выполнение веб-приложения, и это уже очень плохо. Представьте, что каждый раз при отправке запроса к серверу интерфейс вашего приложения становится полностью недоступным.</p>
      <p>Эту проблему решает асинхронность, и длительные операции лучше выполнять именно асинхронно. В этом варианте мы как бы откладываем длительную операцию «на потом» и вместо ожидания завершения выполняем другой код. В этой схеме прозрачно всё, кроме вопроса: «Как выполнить код после завершения асинхронной операции?». Ответ прост — функции обратного вызова.</p>
      <p>В JavaScript функции являются объектами высшего порядка. Это означает, что функции можно передавать в другие функции в виде параметров или возвращать в виде результата выполнения.</p>
      <p>Рассмотрим пример:</p>
      <pre>{`const foo = function () {
 return 'Hello, world!';
}

// Вызываем функцию и выводим результат в консоль
console.log(foo()); // Hello, world

// Выводим функцию в консоль без вызова
console.log(foo); // ƒ () { return 'Hello, world!'; }`}
      </pre>
      <p>В первом случае мы вызываем функцию foo при помощи круглых скобок и выводим результат выполнения в консоль. Во втором примере мы не делаем вызов функции (обратите внимание на отсутствие круглых скобок), и в консоль выводится содержимое функции. Выходит, нам ничего не мешает передать функцию в виде параметра для других функций:</p>
      <pre>{`const runIt = function (fn) {
  return fn(); // Вызываем функцию, переданную в качестве параметра
}

console.log(runIt(foo)); // Hello, world`}
      </pre>
      <p>Мы передали функцию foo в виде параметра и вызывали её внутри функции runIt. Вызов функции мы сделали стандартным образом — применяя круглые скобки.</p>
      <p>Что в итоге? Мы передали ссылку на функцию в виде параметра и вызвали её внутри другой функции. В этом и заключается идея колбэков: мы передаём в виде параметров функции, которые будут вызваны «когда-нибудь потом».</p>
      <p>Вернёмся к примеру с приготовлением пиццы. Попробуем поэкспериментировать с кодом и перевести его на асинхронные рельсы. Напомню, наша задача — попросить приготовить пиццу, и читать книгу, пока пицца не будет готова.</p>
      <pre>{`const makePizza = function (title, cb) {
console.log('Заказ на приготовление пиццы «{title}» получен. Начинаем готовить…');
setTimeout(cb, 3000);
}

const readBook = function () {
console.log('Читаю книгу «Колдун и кристалл»…');
}

const eatPizza = function () {
  console.log('Ура! Пицца готова, пора подкрепиться.');
}

makePizza('Пеперонни', eatPizza);
readBook();`}
      </pre>
      <p>Это рабочий код, попробуйте выполнить его в консоли и посмотреть на результат вывода. Он будет таким:</p>
      <pre>{`Заказ на приготовление пиццы «Пепперони» получен. Начинаем готовить…
Читаю книгу «Колдун и кристалл»…

// Здесь будет пауза

Ура! Пицца готова, пора подкрепиться.`}
      </pre>
      <p>Функция makePizza выполняется мгновенно, и сразу за ней последовал вызов readBook. Пока мы читали книгу, приготовилась пицца, и произошёл вызов функции eatPizza из функции makePizza. Задержку выполнения мы сделали искусственно с помощью setTimeout.</p>

      <h3>Функции обратного вызова на практике</h3>
      <p>Практически любое приложение на JavaScript взаимодействует с сервером. Нам постоянно приходится получать данные с помощью методологии AJAX. Попробуем запросить информацию о произвольном аккаунте с GitHub и вывести её в консоль. Такая программа может выглядеть так:</p>
      <pre>{`const loadData = function(url, cb) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.responseType = 'json';
  // После получения данных выполним cb.
  xhr.addEventListener('load', cb);
  xhr.send();
}

loadData('https://api.github.com/users/AntonovIgor', function (evt) {
  const response = evt.currentTarget.response;
  console.log(response);
});`}
      </pre>
      <p>В этом коде мы делаем запрос к серверу с помощью объекта XMLHttpRequest. Для удобства мы создали функцию loadData, которая принимает два параметра: адрес сервера, который отдаст нам набор информации, и функцию обратного вызова. Вызов этой функции произойдёт сразу после получения данных от сервера. cb — Это общепринятый вариант обозначения функций обратного вызова (сокращение от callback). При виде cb становится очевидно, что в этот параметр должна передаваться ссылка на функцию.</p>
      <p>loadData - то эта функция делает запрос к серверу и вызывает нашу функцию после получения ответа.</p>
      <p>Обратите внимание, как мы вызываем функцию loadData. В первый параметр мы передаём адрес сервера, а во второй — ссылку на функцию. В этот раз мы не описывали функцию отдельно, а сделали это прямо «в параметре» — создали анонимную функцию. Подобный подход часто применяется, когда функция нужна один раз. В таких ситуациях нет смысла писать отдельный код — достаточно создать анонимную функцию в нужном месте.</p>
      <p>Наша функция сработает сразу после получения ответа от сервера (произойдёт событие load) и выведет ответ сервера в консоль.</p>
      <p>Всякий раз, когда вы пишете код, похожий на этот, вы применяете функции обратного вызова:</p>
      <pre>{`[1, 2, 3, 4].forEach(function(it) {
  console.log(it)
});`}
      </pre>
      <p>Аналогично с установкой обработчиков событий. Каждый раз, когда вы подписываетесь на событие с помощью addEventListener, через её второй параметр вы определяете функцию обратного вызова, которая сработает при наступлении события. В мире JavaScript колбэки повсюду.</p>

      <h4>Как передать параметры в колбэк-функцию</h4>
      <p>Проблема в том, что мы привыкли передавать параметры явно: пишем имя функции, открываем круглые скобки и передаём значения. Этот подход применяется постоянно, но с колбэк-функциями дело обстоит иначе. Если мы укажем круглые скобки, то произойдёт вызов функции, а нам требуется передать ссылку на неё. Как поступить в этом случае?</p>
      <p>Для этого нужно вспомнить про замыкания. Функции в JavaScript могут возвращать в качестве результата выполнения другие функции. А уже у них будет доступ к вышестоящей области видимости. С таким подходом легко решить задачу передачи параметров в колбэк-функцию.</p>
      <p>Код заказа пиццы, который мы написали в первой части, выглядел так:</p>
      <pre>{`const makePizza = function (title, cb) {
  console.log('Заказ на приготовление пиццы «{title}» получен. Начинаем готовить…');
  setTimeout(cb, 3000);
}

const readBook = function () {
  console.log('Читаю книгу «Колдун и кристалл»…');
}

const eatPizza = function () {
  console.log('Ура! Пицца готова, пора подкрепиться.');
}

makePizza('Пеперонни', eatPizza);
readBook();

Давайте модифицируем его и добавим для функции eatPizza параметр drink, через который будем передавать напиток:

const makePizza = function (title, cb) {
  console.log('Заказ на приготовление пиццы «{title}» получен. Начинаем готовить…');
  setTimeout(cb, 3000);
}

const readBook = function () {
  console.log('Читаю книгу «Колдун и кристалл»…');
}

const eatPizza = function (drink) {
  return function() {
    console.log('Ура! Пицца готова, пора подкрепиться и запить {drink}.');
  }
}

makePizza('Пепперони', eatPizza('Coca-Cola'));
readBook();`}
      </pre>
      <p>Первое, что мы сделали — внесли изменения в функцию eatPizza. Теперь она принимает параметр drink и возвращает новую функцию. В теле новой функции происходит вывод информации в консоль. Помимо текста, который у нас был, мы добавили вывод информации о напитке (drink). Теперь самое интересное. Функция eatPizza перестаёт быть функцией обратного вызова, вместо неё эту роль будет исполнять функция, которую возвращает eatPizza.</p>
      <p>Мы изменили тело функции, и теперь нам требуется обновить вызов makePizza. Вторым параметром мы указываем не ссылку на eatPizza, а вызов функции, передав информацию о напитке. Получается, на место второго параметра будет передана новая функция, полученная в результате выполнения eatPizza.</p>
      <p>Если представленный пример вызывает затруднение — обязательно перечитайте теорию замыканий.</p>

      <h3>Метод bind</h3>
      <p>Любую задачу можно решить несколькими способами, и передача параметров колбэк-функции — не исключение. Мы можем воспользоваться методом bind, который есть у любой функции.</p>
      <p>Метод bind всё упрощает. Результатом его вызова будет новая функция, которой мы можем передать произвольный набор параметров и задать контекст выполнения. Давайте исправим код заказа пиццы, используя метод bind.</p>
      <pre>{`const makePizza = function (title, cb) {
  console.log('Заказ на приготовление пиццы «{title}» получен. Начинаем готовить…');
  setTimeout(cb, 3000);
}

const readBook = function () {
  console.log('Читаю книгу «Колдун и кристалл»…');
}

const eatPizza = function (drink) {
  console.log('Ура! Пицца готова, пора подкрепиться и запить {drink}.');

makePizza('Пепперони', eatPizza.bind(null, 'Coca-Cola'));
readBook();
}`}
      </pre>
      <p>Мы вернули функцию eatPizza к первоначальному состоянию, избавившись от возврата новой функции. В остальном всё без изменений. При передаче функции обратного вызова мы воспользовались методом bind. Первый параметр (null) позволяет задать произвольный контекст для функции, но так как эта возможность нас не интересует, мы передаём null. Во втором параметре мы передаём значение для параметра drink. Мы можем передать любое количество параметров для функции обратного вызова, перечисляя их через запятую.</p>


      <p><a href="examples/function-create-card-of-store/index.html">Функция, создающая карточки товаров для интернет-магазина</a></p>
      <p><a href="examples/function-create-card-of-store-ice/index.html">Функция, создающая карточки товаров для интернет-магазина мороженного</a></p>
      <p><a href="examples/photo-gallery/index.html">Пример использования замыкания в функции - реализация фотогалереи</a></p>
      <p><a href="examples/function-closure-example/index.html">Пример использования замыкания в функции - Вывод имени</a></p>
    </section>
  );
}
export default Function;
