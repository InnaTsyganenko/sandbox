import React from 'react';

function ArchitectureOfFrontEndApplications() {

  return (
    <section className="conspect">
      <h1>Как сделать проект по MVP, пошагово:</h1>
      <p><a href="https://doka.guide/tools/bundlers/" target="_blank" rel="noopener noreferrer">Системы сборки</a></p>
      <p><a href="https://doka.guide/tools/webpack/" target="_blank" rel="noopener noreferrer">Что такое Webpack</a></p>
      <p><a href="https://learn.javascript.ru/polyfills" target="_blank" rel="noopener noreferrer">Babel: траспайлер и полифилы</a></p>
      <p><a href="https://github.com/webpack/webpack-dev-server#readme" target="_blank" rel="noopener noreferrer">webpack-dev-server</a></p>
      <p><a href="https://medium.com/devschacht/polymorphism-207d9f9cd78" target="_blank" rel="noopener noreferrer">Полиморфизм простыми словами</a></p>
      <p><a href="https://doka.guide/js/oop/" target="_blank" rel="noopener noreferrer">Объектно-ориентированное программирование</a></p>
      <p><a href="https://refactoring.guru/ru/design-patterns/observer" target="_blank" rel="noopener noreferrer">О паттерне «Наблюдатель» на сайте Гуру Рефакторинга</a></p>
      <p><a href="https://habr.com/ru/post/321050/" target="_blank" rel="noopener noreferrer">Охота на мифический MVC</a></p>
      <p><a href="https://habr.com/ru/company/htmlacademy/blog/569610/" target="_blank" rel="noopener noreferrer">Как искать и выбирать npm-пакеты? Шпаргалка для начинающих</a></p>
      <p><a href="https://refactoring.guru/ru/design-patterns/adapter" target="_blank" rel="noopener noreferrer">Паттерн «Адаптер» на сайте Гуру рефакторинга</a></p>
      <p><a href="https://bespoyasov.ru/blog/adapter-pattern/" target="_blank" rel="noopener noreferrer">Лекарство от сломанной обратной совместимости</a></p>
      <p><a href="https://alistapart.com/article/prototypal-object-oriented-programming-using-javascript/" target="_blank" rel="noopener noreferrer">Prototypal Object-Oriented Programming</a></p>
      <h2>Настройка сборки.</h2>
      <p>Настройте сборку проекта так, чтобы зависимости в JS собирались при помощи сборщика модулей Webpack. Для этого выполните следующие шаги:</p>
      <p>Установите из npm пакеты webpack и webpack-cli. Обратите внимание, здесь и далее нужно устанавливать конкретные версии зависимостей, указанные в файле requirements.md в вашем репозитории.</p>
      <p>Создайте в корне проекта файл webpack.config.js и опишите конфигурацию сборки:</p>
      <ul>
        <li>задайте main.js точкой входа;</li>
        <li>в качестве директории для сборки укажите папку public. Помните, что путь должен быть абсолютный. Используйте path.resolve;</li>
        <li>файл сборки (бандл) назовите bundle.js;</li>
        <li>активируйте генерацию source-maps.</li>
      </ul>
      <p>Добавьте в package.json скрипт с именем build, со значением webpack --mode development, для сборки кода с помощью Webpack в режиме сборки для разработки. Когда наш проект будет готов, мы перенастроим этот скрипт на сборку для публикации.</p>
      <p>Собираемые с помощью Webpack файлы (именно файлы, а не вся директория public) не должны попасть в репозиторий. Поэтому добавьте их в .gitignore.</p>

      <h2>Настройка сервера для разработки.</h2>
      <p>Чтобы на каждое изменение кодовой базы не собирать бандл и не открывать public/index.html в браузере руками, настроим сервер для разработки. Установите из npm пакет webpack-dev-server. Опишите настройки сервера в webpack.config.js, отключив горячую замену модулей (англ. hot module replacement, иногда просто hot):</p>
      <pre>{`devServer: {
        hot: false
      }`}
      </pre>
      <p>Осталось добавить npm-скрипт и можно пользоваться. Назовём его start. Значением будет команда запуска сервера и настройки: webpack serve --open --mode development.</p>
      <p>Теперь достаточно выполнить команду npm start. Браузер с нужным адресом откроется автоматически. Если этого не произойдёт, откройте приложение вручную. Адрес будет указан в терминале после запуска команды.</p>

      <h2>Настройка Babel</h2>
      <p>Настройте Babel, чтобы использовать новые возможности JavaScript.</p>
      <p>Установите из npm основной пакет @babel/core. Установите плагины: @babel/plugin-proposal-class-properties, @babel/plugin-proposal-nullish-coalescing-operator, @babel/plugin-proposal-optional-chaining.</p>
      <p>Создайте файл настроек babel.config.json и опишите в нём используемые плагины. Если затрудняетесь, подсмотрите в демо-проекте.</p>
      <p>Установите лоадер для Webpack babel-loader и подключите его в webpack.config.js.</p>
      <p>Установите дополнительный парсер для линтера @babel/eslint-parser и укажите его в .eslintrc.yml.</p>

      <h2>Создаём view</h2>
      <p>В директории src создаём директорию view. Нарезаем вёрстку на отдельные компоненты (элементы интерфейса). Импортируем эти модули в main.js. Отрисовываем компоненты на страницу</p>
      <p>Отделим данные от представления: избавимся от статического контента в шаблонах компонентов и создадим для каждого из компонентов подходящую структуру данных.</p>
      <p>Чтобы понять, что должно оказаться в данных, а что нет, задайте себе вопрос: «Есть ли смысл скачивать эту информацию с сервера отдельно, может ли она измениться?» Не стоит заводить в данных структуру, которая описывает размеры логотипа или статический текст, в структурах должны храниться только те данные, которыми мы будем оперировать в проекте: получать их с сервера, изменять, отправлять на сервер обратно.</p>
      <p>Напишите функцию, которая будет возвращать готовые объекты по структуре из предыдущего пункта. С помощью этой функции в main.js сгенерируйте временные данные (моки). Побольше… 15-20 объектов. Для удобства их лучше сложить в массив.</p>

      <h2>Классы</h2>
      <ol>
        <li>Представим все наши компоненты в виде классов.</li>
        <li>Функции, которые мы использовали для получения шаблона разметки, превратим в геттер класса. Он по-прежнему должен возвращать разметку.</li>
        <li>Перепишем передачу данных в разметку. Ранее мы брали данные из аргументов функции, теперь же мы будем брать данные из свойств класса, обращаясь через this. Но прежде их нужно туда записать. Передавать данные мы будем через параметры конструктора (при вызове с new), поэтому в описании метода constructor возьмём данные из аргументов и запишем их как приватные свойства класса.</li>
        <li>Добавим геттер, который будет создавать DOM-элемент на основе шаблона, записывать его в приватное свойство класса (например, #element) и возвращать созданный DOM-элемент. Для этого потребуется описать вспомогательную функцию, например createElement. Лучше завести под такие функции отдельный файл, например /src/render.js. А также нужно будет позаботиться о том, чтобы DOM-элемент создавался только в случае, когда он ещё не был создан.</li>
        <li>И сразу же создадим метод для удаления элемента. Он нам понадобится для очищения ресурсов. В нем мы должны удалить ссылку на созданный DOM-элемент. Для этого достаточно записать null в свойство класса #element.</li>
        <li>Прежде, чем править наш код в main.js, нужно изменить функцию для отрисовки (вставки в DOM), которую мы написали в самом начале. Раньше это была функция-обёртка над insertAdjacentHTML, которая принимала контейнер, шаблон и позицию отрисовки. Теперь вместо шаблона мы будем передавать DOM-элемент, поэтому insertAdjacentHTML нужно заменить на другую стандартную функцию, которая умеет вставлять DOM-элементы.</li>
        <li>Теперь, когда подготовительные работы закончены, используйте в main.js для создания компонентов не функции, а классы.</li>
      </ol>

      <h2>Абстрактный класс</h2>
      <p>Нам нужно выделить общие части компонентов в абстрактный класс.</p>
      <p>Изучите структуру существующих компонентов, чтобы понять, какая логика и какие данные повторяются. Не всегда ответ на этот вопрос очевиден, и порой придётся подумать, порисовать, порефакторить. Но если вы описали метод по удалению элемента, геттер элемента и свойства вроде #element, как мы просили в предыдущих заданиях, то общими будут именно они.</p>
      <p>Опишите абстрактный класс. Это точно такой же класс, как все остальные, только создавать объекты напрямую из него нельзя. От него можно только наследоваться. Поэтому добавьте в конструкторе проверку на new.target и бросьте исключение, если условие истинно.</p>
      <p>Далее объявите в абстрактном классе общие свойства и методы, пока что пустые.</p>
      <p>У всех наших компонентов-наследников обязательно должен быть реализован геттер шаблона, который возвращает разметку. Абстрактный класс поможет нам об этом не забыть. Для этого опишите в абстрактном классе геттер шаблона, внутри которого бросьте исключение. Теперь, если вы забудете в своём компоненте реализовать геттер шаблона, об этом вам напомнит ошибка в консоли.</p>
      <p>А теперь унаследуем все наши компоненты от абстрактного класса с помощью языковой конструкции extends.</p>
      <p>В заключение перенесём реализацию общих методов из потомков (наших компонентов) в родителя (абстрактный класс). Теперь, благодаря ООП и наследованию, у всех наших потомков будут методы, объявленные в родителе, а не дублированные в каждом компоненте. Не забудьте, что геттер шаблона должен остаться в компонентах, как и прочие частные методы.</p>

      <h3>Больше абстракций богу абстракций</h3>
      <p>На этом шаге мы максимально абстрагируемся от работы с DOM напрямую в пользу работы с нашими компонентами.</p>
      <p>У нас появилось больше вспомогательных функций по работе с DOM (вроде render). Измените реализацию этих функций, чтобы в них можно было передавать наши компоненты, а не только DOM-элементы.</p>
      <p>У нас осталось последнее место, где мы работаем с DOM напрямую — это подписка на события. Откажемся от прямого использования addEventListener в main.js, оставив его только в компонентах. Для этого добавьте в компоненты методы для установки обработчиков событий, а в тело этих методов перенесите использование addEventListener. Глобальные обработчики — на document и window — остаются как есть.</p>
      <p>Теперь мы ничего не знаем о внутреннем устройстве компонентов и их реальных событиях. Важным для нас остаётся лишь их интерфейс — набор методов, которыми они обладают. Мы можем менять разметку и реальные события отдельных компонентов безболезненно для всего приложения. Главное, сохранять интерфейс компонентов.</p>

      <h2>Презентер</h2>
      <p>Пришло время разгрузить main.js и вынести часть связанной логики в отдельную сущность — презентер. Задача презентера — создавать компоненты, добавлять их на страницу, навешивать обработчики. То есть реализовывать бизнес-логику и поведение приложения.</p>
      <ol>
        <li>Заведите директорию для презентеров /src/presenter.</li>
        <li>Создайте класс для презентера списка фильмов и для презентера фильма (например, MovieListPresenter и MoviePresenter).</li>
        <li>Конструктор презентера должен принимать необходимые данные.</li>
        <li>Разнесите по презентерам всю логику по отрисовке фильмов и кнопки «Show more», а также по навешиванию на них обработчиков, из main.js.</li>
        <li>В main.js создайте экземпляры презентеров, передайте данные и инициализируйте их.</li>
      </ol>

      <h3>Частичный датабиндинг</h3>
      <p>Реализуем обработку кликов на кнопках «Add to watchlist», «Already watched», «Add to favorites» у карточки фильма и у попапа подробной информации о фильме. Обработчики должны изменять данные фильма — добавлять или удалять из избранного и списка к просмотру, а также помечать его просмотренным или наоборот, и на основе изменённых данных перерисовывать компоненты.</p>
      <p>Для этого:</p>
      <ol>
        <li>В компоненте фильма и попапа добавьте методы для установки обработчиков клика для каждой кнопки.</li>
        <li>В презентере списка фильмов опишите метод изменения данных. Задача метода — обновить моки и вызвать обновление конкретного фильма.</li>
        <li>В презентер одного фильма передайте эту функцию изменения данных. Функция должна вызываться в обработчике клика и получать на вход обновлённые данные.</li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ol>

      <h4>Только один попап</h4>
      <p>Добавьте в презентер метод для скрытия попапа. Передайте в презентер фильма колбэк, который нужно вызвать перед тем, как открыть новый попап. В презентере списка фильмов реализуйте метод для этого колбэка, который скроет попап, если таковой уже открыт. Обратите внимание, вы можете реализовать эту логику, используя паттерн «Наблюдатель» по примеру демо-проекта.</p>

      <h2>Smart-компонент</h2>
      <p>Попап c подробной информацией о фильме довольно сложный интерактивный компонент. Но это поведение — не часть бизнес-логики приложения. Это «бизнес-логика» самого компонента. Поэтому для реализации этой логики заведём Smart-компонент (от англ. smart — умный), который может себя перерисовывать.</p>
      <p>Создайте абстрактный класс SmartView, унаследовав его от AbstractView, с несколькими методами:</p>
      <ol>
        <li>абстрактный метод restoreHandlers, его нужно будет реализовать в наследнике. Его задача — восстанавливать обработчики событий после перерисовки;</li>
        <li>обычный метод updateElement, его задачи:
          <ol>
            <li>удалить старый DOM-элемент компонента;</li>
            <li>создать новый DOM-элемент;</li>
            <li>поместить новый элемент вместо старого;</li>
            <li>восстановить обработчики событий, вызвав restoreHandlers.</li>
          </ol>
        </li>
        <li>обычный метод updateData, который будет обновлять данные и, если нужно, вызывать метод updateElement.</li>
      </ol>
      <p>Унаследуйте компонент попапа с подробной информацией о фильме от SmartView с пока пустым методом restoreHandlers.</p>
      <p>Теперь нужно реализовать перерисовку попапа после взаимодействия с пользователем: при клике на эмоцию подставлять её в соответствующий блок.</p>
      <p>При перерисовке компонента все обработчики событий будут утеряны, поэтому их нужно будет навесить заново.</p>

      <h2>Модель данных</h2>
      <ol>
        <li>Создайте директорию /src/model с новым файлом movies-model.js, в котором опишите класс MoviesModel или с любым другим именем на ваше усмотрение.</li>
        <li>Добавьте в класс 2 метода: один для получения фильмов, другой для их записи.</li>
        <li>Добавьте ещё один метод для обновления конкретного фильма.</li>
        <li>В main.js создайте экземпляр модели и передайте в неё, с помощью созданного на втором шаге метода записи, моковые данные.</li>
        <li>В main.js передайте модель в конструктор презентера, а передачу моковых данных в метод init — удалите.</li>
        <li>В презентере замените прямую работу с моковым массивом фильмов на работу с моделью: для получения и обновления данных используйте соответствующие методы модели.</li>
      </ol>
      <p>Для реализации фильтрации создайте отдельную модель: добавьте в неё методы для установки и получения фильтра. Передайте модель в презентер фильтров и реализуйте обработчик выбора фильтра, который будет передавать в модель новое значение.</p>
      <p>Но как презентер списка фильмов будет узнавать об изменении активного фильтра? Подход уже вам известен:</p>
      <ul>
        <li>передайте модель в презентер;</li>
        <li>в методе получения данных из модели фильма учитывайте текущий фильтр.</li>
      </ul>
      <p>Реализуйте обновление счётчика у фильтров при изменении, а в будущем при добавлении и удалении, данных:</p>
      <ul>
        <li>в презентер фильтров передайте модель;</li>
        <li>при изменении модели с данными, получите новый список и пересчитайте счётчики.</li>
      </ul>
      <p>Осталось добавить показ заглушки, если в отфильтрованном списке не осталось фильмов, удовлетворяющих фильтру. Набор фраз для каждого фильтра вы найдёте в файле list-empty.html в директории с разметкой.</p>

      <h3>Удаление и добавление данных</h3>
      <p>Удаление и добавление комментариев можно реализовать разными способами. Предлагаем один из самых простых. Попап с подробной информацией о фильме уже умеет перерисовываться при изменении данных. Значит для того, чтобы удалить комментарий, достаточно изменить данные (удалить из них конкретный комментарий).</p>
      <p>Для удаления научим обработчик пользовательских действий принимать тип действия «Удаление». Логика следующая: заводим константу со всеми возможными действиями пользователя, в обработчике пользовательских действий описываем switch по типу действия, где вызываем соответствующие методы модели.</p>
      <p>Дальше добавим в попап обработчик события click по кнопке удаления комментария, где вызовем функцию обновления данных с нужным типом. Теперь провернём всё то же самое, только для добавления. В конце останется лишь обработать отправку формы или её закрытие.</p>

      <h3>Безопасность превыше всего</h3>
      <p>Данные в нашем приложении создаются, удаляются, изменяются... пользователями. А где есть пользовательский ввод, там потенциальная дыра в безопасности. Поэтому пора подумать о том, как обезопасить приложение и добропорядочных пользователей от «хакеров». Установите из npm и подключите в проект библиотеку для превращения в строку возможного HTML или JavaScript кода в пользовательском вводе. Мы рекомендуем библиотеку he.</p>

      <h2>Смена экранов</h2>
      <p>У нас в приложении несколько экранов, и нужно научиться корректно их переключать.</p>
      <ul>
        <li>Подключите в main.js и отрисуйте компонент со статистикой. Пока что список фильмов и статистика покажутся друг под другом, сейчас мы с этим разберёмся.</li>
        <li>Теперь, когда в main.js есть все необходимые компоненты, реализуйте здесь логику переключения экранов при выборе соответствующего пункта в меню. Для удаления ненужного элемента можете использовать функцию remove.</li>
      </ul>

      <h3>Безжалостная статистика</h3>
      <p>Начнём показ статистики с её программирования. В статистике отображается сводная информация о просмотренных фильмах. Для удобства просмотра и анализа эта информация представлена в виде графиков и диаграмм. Построить диаграммы полностью самостоятельно — нетривиальная задача, поэтому мы воспользуемся пакетом chart.js.</p>
      <ol>
        <li>Установите из npm пакет chart.js и плагин chartjs-plugin-datalabels.</li>
        <li>Импортируйте chart.js и chartjs-plugin-datalabels в модуль, который будет отвечать за формирование статистики.</li>
        <li>При помощи установленных пакетов отрисуйте диаграмму, которая показывает количество просмотренных фильмов в разрезе жанров. Подробное описание каждой диаграммы есть в техническом задании.</li>
        <li>Чтобы упростить вам задачу, ваш коллега написал код самой диаграммы, но не успел его встроить в проект. Закончите за него работу: разберитесь в чужом коде и настройте вывод актуальной информации. Нужно будет доработать код, проверить на соответствие критериям и техзаданию, дописать недостающие части и исправить ошибки, если таковые имеются. Если возникнут трудности, подробное описание всех параметров вы найдёте в документации к chart.js.</li>
      </ol>
      <p>Настройте выбор периода, за который нужно отобразить статистику. Графики должны обновляться при изменении периода в поле выбора периода. Неизменным остаётся только звание пользователя.</p>

      <h2>Загрузка данных</h2>
      <p>В этом разделе мы синхронизируем локальные данные с сервером через REST API. Сервер, который мы подготовили для вас, работает по адресу: https://16.ecmascript.pages.academy/cinemaddict.</p>
      <ol>
        <li>Добавьте в проект модуль, который будет отправлять на сервер REST-запросы, и спроектируйте его интерфейс (публичные методы).</li>
        <li>Реализуйте паттерн «Адаптер» для преобразования данных, полученных с сервера: при скачивании вы получаете данные в формате сервера, и вам нужно преобразовать их в тот формат, который вы разработали в разделе о структурах данных. Например, если где-то в своих данных вы используете Set, вам нужно создать его самостоятельно. Потому что данные по сети передаются в формате JSON, в котором нет множеств, а могут быть только массивы.</li>
        <li>Удалите из проекта моковые данные и функции для работы с ними.</li>
        <li>Создайте в точке входа экземпляр API.</li>
        <li>С помощью созданного модуля сделайте GET-запрос на адрес /movies, чтобы получить список всех фильмов с сервера. Измените отрисовку списка фильмов так, чтобы она происходила только после получения данных. На время загрузки вместо списка выведите информирующее сообщение (разметку смотрите в /markup). Сообщение должно показываться единожды на старте приложения, пока данные загружаются. В случае, если при загрузке произошла ошибка, приложение должно отработать так, как будто данных нет, и показать соответствующую заглушку.</li>
        <li>Для загрузки комментариев для конкретного фильма сделайте GET-запрос на адрес /comments/:movieId, где :movieId — id конкретного фильма. Комментарии к конкретному фильму нужно загружать при открытии попапа с подробной информацией.</li>
      </ol>

      <h3>Обновление данных</h3>
      <p>Пришло время научиться синхронизировать обновлённые данные с сервером. Основная задача в том, чтобы полученные изменения от пользователя сначала отправить на сервер, получить от него одобрение и, в случае успеха, отобразить изменения в интерфейсе.</p>
      <ol>
        <li>Опишите в API метод для обновления фильма на сервере. Для этого нужно выполнить PUT-запрос на адрес /movies/:movieId, где :movieId — id конкретного фильма, передав в теле запроса обновлённые данные.</li>
        <li>Перепишите в модели код, который отвечает за обновление данных, чтобы он обновлял данные на сервере, и только потом в самой модели. Обратите внимание, перед отправкой запроса на обновление нужно преобразовать данные из внутреннего формата приложения в формат сервера. Потребуется написать ещё один адаптер, теперь уже в обратную сторону — для преобразования данных в формат сервера.</li>
      </ol>
      <p>В случае удачного запроса, сервер вернёт вам обновлённые данные. Это должно вызвать отрисовку и обновление списка фильмов. Обратите внимание, что изменения в DOM должны происходить только после успешного запроса к серверу, иначе мы получим несогласованность — ситуацию, когда интерфейс не отражает реальных данных.</p>

      <h2>Создание и удаление данных</h2>
      <ol>
        <li>Опишите в API методы для создания (POST) и удаления (DELETE) комментария на сервере.</li>
        <li>Измените код обновления данных так, чтобы при отправке формы, сначала отправлялся POST-запрос на сервер и, только в случае его успешного завершения, в попап добавлялся новый комментарий. Форма при этом должна очиститься, в том числе выбранная эмоция.</li>
        <li>Измените код обновления данных так, чтобы при нажатии на кнопку «Delete», сначала отправлялся DELETE-запрос на сервер, который бы удалял комментарий и, только в случае успешного завершения, комментарий скрывался в попапе.</li>
      </ol>

      <h3>Обратная связь</h3>
      <p>Доработаем интерфейс так, чтобы в нём появилась прозрачная обратная связь о состоянии всех запросов и ошибках.</p>
      <p>При отправке нового комментария или удалении комментария реализуйте следующие шаги:</p>
      <ol>
        <li>Заблокируйте форму (в случае создания нового комментария), заблокируйте кнопку и замените её текст c «Delete» на «Deleting...» (в случае удаления комментария).</li>
        <li>В случае успешного запроса к серверу должны произойти все те манипуляции, что мы описали ранее.</li>
        <li>Если в процессе запроса произошла ошибка:
          <ul>
            <li>разблокируйте форму (в случае создания нового комментария), разблокируйте кнопку (в случае удаления комментария);</li>
            <li>добавьте эффект «покачивания головой» всей форме (в случае создания нового комментария) или блоку с комментарием (в случае удаления комментария). CSS-код для эффекта вы найдёте ниже, а можете реализовать самостоятельно.</li>
          </ul>
        </li>
      </ol>
      <pre>{`<style>
    @keyframes shake {
        0%,
        100% {
            transform: translateX(0);
        }

        10%,
        30%,
        50%,
        70%,
        90% {
            transform: translateX(-5px);
        }

        20%,
        40%,
        60%,
        80% {
            transform: translateX(5px);
        }
    }

    .shake {
        animation: shake 0.6s;
    }
</style>`}
      </pre>
    </section>
  );
}
export default ArchitectureOfFrontEndApplications;
