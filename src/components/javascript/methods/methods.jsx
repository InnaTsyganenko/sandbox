/* eslint-disable no-irregular-whitespace */
import React from 'react';

function Methods() {

  return (
    <section className="conspect">
      <h1>Методы</h1>
      <h2>Методы querySelector, querySelectorAll</h2>
      <h3>querySelector</h3>
      <p>Этот метод принимает CSS-селектор и возвращает первый подходящий элемент. Он понимает любые CSS-селекторы:</p>
      <pre>{`document.querySelector('селектор');

// Поиск элемента по тегу
var list = document.querySelector('ul');

// Поиск последнего элемента из списка
var lastProduct = document.querySelector('li:last-child');

// Поиск элемента по классу
var price = document.querySelector('.price');

// Поиск третьего элемента из списка товаров
var thirdProduct = document.querySelector('.product:nth-child(3)');
`}
      </pre>
      <p>Эта инструкция состоит из двух частей. Первая часть — элемент, внутри которого будет искать JavaScript. Словом document обозначается веб-страница, к которой скрипт подключён. Неважно, как называется файл на самом деле, в JavaScript это всегда «документ». Он является элементом-родителем для любого другого элемента на странице.</p>
      <p>Вторая часть инструкции — это то, что нужно сделать. Её называют <span className="hl-5">методом</span>.</p>
      <p>Обратите внимание, что дочерние элементы не обязательно искать в document:</p>
      <pre>{`
const userDialog = document.querySelector('.setup');
const similarListElement = userDialog.querySelector('.setup-similar-list');
`}
      </pre>
      <p className="hl-4">Если найден родитель элемента, избыточно запускать поиск по всему документу. Это ресурсоёмкая операция, потому что документ может быть очень большим.</p>

      <h3>querySelectorAll</h3>
      <p>Возвращает список (коллекцию) всех элементов, подходящих по селектору.</p>
      <p>Обратите внимание, что DOM-коллекция, полученная через querySelectorAll похожа на массив. Это действительно так, она похожа, но им не является. Поэтому ещё одно название таких коллекций — псевдомассив. Его можно перебирать с помощью цикла for.</p>
      <a href="examples/method-queryselectorall/index.html" target="blank">Посмотреть пример работы метода</a>

      <h2>Метод createElement, создание элемента</h2>
      <p>Метод принимает на вход строку с именем тега и возвращает созданный DOM-элемент. Этот элемент можно записать в переменную для дальнейших манипуляций.</p>
      <p>Обратите внимание, что createElement — метод именно объекта document. То есть с его помощью мы создаём какой-то элемент для этого документа, пока не указывая, где он будет находиться в DOM.</p>
      <pre>{'document.createElement(имя тега);'}</pre>
      <p>Новый элемент будет доступен из скрипта, но в разметке не появится, пока мы не скажем JavaScript, где разместить новый элемент. Для этого можно использовать метод append.</p>

      <h3>Метод appendChild(), добавление содержимого</h3>
      <p>элемент-родитель.append(добавляемый-элемент);</p>
      <p>Метод append добавляет указанный в скобках элемент в конец элемента-родителя.</p>
      <p>При этом содержимое элемента-родителя не затирается.</p>
      <p>C помощью этого метода можно и элементы, и простые строки. Метод append не копирует элементы, а перемещает.</p>
      <p>Если указать в скобках элемент, который уже есть в разметке, этот элемент исчезнет со своего прежнего места и появится там, куда его добавил метод append. Получить таким образом несколько элементов не выйдет.</p>

      <pre>{`// Находим элемент-родитель
let parent = document.querySelector('.parent');

// Добавляем новый элемент на страницу
parent.append(newElement);


var list = document.querySelector('.cards');
var card = document.createElement('li');
card.classList.add('card');

// После вызова этого метода новый элемент отрисуется на странице
list.appendChild(card);
`}
      </pre>
      <p>Последовательность добавления элемента в DOM может быть другой: можно создать элемент с помощью createElement и сразу вставить его в родительский элемент, а уже затем добавлять классы. Но это не лучший путь — каждое изменение в DOM вызывает перерисовку страницы, а это дорогая операция, она занимает много времени.</p>

      <h2>Методы для изменения классов - объект classList</h2>
      <p>Так как DOM-элементы — объекты, все они имеют набор свойств и методов. Среди свойств DOM-элементов — объект classList. Он содержит методы для управления классами DOM-элемента</p>
      <p>Синтаксис простой. Сначала мы указываем DOM-элемент, которому хотим добавить класс, затем обращаемся к свойству classList через точку и вызываем метод add(), передав ему строку с необходимым классом.</p>
      <p className="hl-2">Кстати, обратите внимание, мы ставим точку, когда ищем элемент по селектору, но не ставим её при удалении или добавлении класса. Это правило важно запомнить. Чтобы было легче, можно помнить о том, что названия classList.remove и classList.add говорят сами за себя. Мы что-то делаем с классом элемента, поэтому нам надо передать только строку с названием класса. А искать элемент через querySelector можно разными способами. Мы говорили об этом раньше. Поэтому мы ставим точку перед названием класса, чтобы явно указать, что мы ищем именно по классу, а не тегу или как-то иначе.:</p>
      <pre>{`
// Когда ищем элемент по классу, используем точку
var product = document.querySelector('.product');

// Но когда добавляем класс, точки нет!
product.classList.add('product--sale');
`}
      </pre>

      <h3>Метод classList.contains, проверяем наличие класса</h3>
      <p>элемент.classList.contains(&apos;класс&apos;);</p>
      <p>Метод вернёт true (истина), если класс у элемента есть, и false (ложь), если класса нет.</p>

      <h3>Метод classList.remove</h3>
      <p>Убирает с элемента тот класс, который указан в скобках:</p>
      <pre>{`
элемент.classList.remove('класс');

var popup = document.querySelector('.popup');
// Перед названием селектора ставим точку

popup.classList.remove('popup--open');
// Перед названием класса точка не ставится
Результат в разметке такой же, как при удалении класса вручную.

<!-- Исходное состояние разметки -->
<section className="popup popup--open">
…
</section>

<!-- Состояние после вызова classList.remove -->
<section className="popup">
…
</section>
`}
      </pre>

      <h3>Метод classList.add</h3>
      <p>Чтобы добавить элементу класс, нужно использовать метод classList.add:</p>
      <pre>{`
элемент.classList.add('класс');`}
      </pre>
      Метод-переключатель classList.toggle убирает у элемента указанный класс, если он есть, и добавляет, если этого класса нет:
      <pre>{`
элемент.classList.toggle('класс');`}
      </pre>

      <a href="examples/ice-cream-shop/index.html" target="blank">Посмотреть пример работы методов</a>

      <h2>Методы padStart() и padEnd()</h2>
      <p>JavaScript метод padStart() позволяет дополнить текущую строку, начиная с её начала (слева) с помощью пробельного символа (по умолчанию), или заданной строкой, таким образом чтобы результирующая строка достигла заданной длины.</p>
      <p>Если Вам необходимо дополнить текущую строку, начиная с её конца (справа), то Вы можете воспользоваться методом padEnd().</p>
      <pre>{`// дополнить текущую строку пробельными символами до заданной длины
string.padStart( targetLength );

// дополнить текущую строку переданными символами до заданной длины
string.padStart( targetLength, padString  ); `}
      </pre>
      <dl>
        <dt>targetLength</dt><dd>Целое число, которое определяет длину текущей строки после того как она будет заполнена. Если значение отсутствует, или меньше длины текущей строки, то текущая строка будет возвращена с той же длиной (останется без изменений).</dd>
        <dt>padString</dt><dd>Определяет строковое значение, которым будет дополнена текущая строка. При необходимости заданная строка может быть повторена с целью достижения заданной длины для текущей строки, или усечена, если заданная длина строки была достигнута ранее. Значение по умолчанию для этого параметра - &quot; &quot; (U+0020).</dd>
      </dl>
      <p>Подготовить и вывести на консоль значения из массива, выравнивая при этом длину строки конкретного элемента для удобного просмотра и чтения выведенной информации:</p>
      <pre>{`let array = ["147.13", "20.11", "40.99", "13.06", "255", "189"];
let outputValues = array.map( val => parseFloat( val ).toFixed( 2 ).padStart( 10 ).padEnd( 14, " RUR"));

console.log( outputValues.join( "\n") );

// результат вывода будет следующим:

  147.13 RUR
   20.11 RUR
   40.99 RUR
   13.06 RUR
  255.00 RUR
  189.00 RUR`}
      </pre>

      <h3>String.prototype.trim()</h3>
      <p>Метод trim() удаляет пробельные символы с начала и конца строки. Пробельными символами в этом контексте считаются все собственно пробельные символы (пробел, табуляция, неразрывный пробел и прочие) и все символы конца строки (LF, CR и прочие).</p>
      <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank" rel="noopener noreferrer">String.prototype.trim() MDN</a></p>
    </section>
  );
}
export default Methods;
